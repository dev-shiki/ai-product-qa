{
  "timestamp": "E:\\porto\\ai-product-qa",
  "total_files": 17,
  "coverage_data": {
    ".": 0.0,
    "main.py": 0.0,
    "api": 0.0,
    "api/__init__.py": 100.0,
    "api/products.py": 0.0,
    "api/queries.py": 0.0,
    "models": 100.0,
    "models/__init__.py": 100.0,
    "models/product.py": 100.0,
    "services": 61.040000000000006,
    "services/__init__.py": 100.0,
    "services/ai_service.py": 32.26,
    "services/local_product_service.py": 82.42,
    "services/product_data_service.py": 35.370000000000005,
    "utils": 100.0,
    "utils/__init__.py": 100.0,
    "utils/config.py": 100.0
  },
  "lowest_coverage_files": [
    {
      "filepath": "app/services/ai_service.py",
      "coverage": 32.26,
      "content": "import logging\nfrom google import genai\nfrom app.utils.config import get_settings\nfrom app.services.product_data_service import ProductDataService\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass AIService:\n    def __init__(self):\n        \"\"\"Initialize AI service with Google AI API\"\"\"\n        try:\n            settings = get_settings()\n            # Use the new Google AI client\n            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)\n            self.product_service = ProductDataService()\n            logger.info(\"Successfully initialized AI service with Google AI client\")\n        except Exception as e:\n            logger.error(f\"Error initializing AI service: {str(e)}\")\n            raise\n\n    async def get_response(self, question: str) -> str:\n        \"\"\"Get AI response with product context and fallback message\"\"\"\n        try:\n            logger.info(f\"Getting AI response for question: {question}\")\n\n            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)\n            import re\n            category = None\n            max_price = None\n            \n            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)\n            question_lower = question.lower()\n            category_mapping = {\n                'laptop': ['laptop', 'notebook', 'komputer'],\n                'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],\n                'tablet': ['tablet', 'ipad'],\n                'headphone': ['headphone', 'earphone', 'headset', 'audio'],\n                'kamera': ['kamera', 'camera', 'fotografi'],\n                'audio': ['audio', 'speaker', 'sound'],\n                'tv': ['tv', 'televisi'],\n                'drone': ['drone', 'quadcopter'],\n                'jam': ['jam', 'watch', 'smartwatch']\n            }\n            \n            for cat, keywords in category_mapping.items():\n                if any(keyword in question_lower for keyword in keywords):\n                    category = cat\n                    break\n            \n            # Deteksi budget\n            price_match = re.search(r'(\\d+)\\s*juta', question_lower)\n            if price_match:\n                max_price = int(price_match.group(1)) * 1000000\n            elif 'budget' in question_lower or 'murah' in question_lower:\n                max_price = 5000000\n\n            # Gunakan smart_search_products\n            products, fallback_message = await self.product_service.smart_search_products(\n                keyword=question, category=category, max_price=max_price, limit=5\n            )\n\n            # Build context\n            context = f\"Question: {question}\\n\\n\"\n            context += f\"{fallback_message}\\n\\n\"\n            if products:\n                context += \"Relevant Products:\\n\"\n                for i, product in enumerate(products, 1):\n                    context += f\"{i}. {product.get('name', 'Unknown')}\\n\"\n                    context += f\"   Price: Rp {product.get('price', 0):,.0f}\\n\"\n                    context += f\"   Brand: {product.get('brand', 'Unknown')}\\n\"\n                    context += f\"   Category: {product.get('category', 'Unknown')}\\n\"\n                    context += f\"   Rating: {product.get('specifications', {}).get('rating', 0)}/5\\n\"\n                    context += f\"   Description: {product.get('description', 'No description')[:200]}...\\n\\n\"\n            else:\n                context += \"No specific products found, but I can provide general recommendations.\\n\\n\"\n\n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\\n\\n{context}\\n\\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision. Focus on being helpful and natural in your response.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n        \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            return \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n\n    def generate_response(self, context: str) -> str:\n        \"\"\"Generate response using Google AI (legacy method)\"\"\"\n        try:\n            logger.info(\"Generating AI response\")\n            \n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.0-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n            \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            raise ",
      "existing_test": "import pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nimport logging\nimport sys\nimport os\n\n# Adjusting sys.path to allow imports from the 'app' directory\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))\n\nfrom app.services.ai_service import AIService\nfrom app.utils.config import Settings # Assuming Settings class is defined in app.utils.config\n\n# --- Fixtures ---\n\n@pytest.fixture\ndef mock_settings():\n    \"\"\"Mocks the get_settings function to return a mock Settings object.\"\"\"\n    settings = Mock(spec=Settings)\n    settings.GOOGLE_API_KEY = \"test_api_key_123\"\n    return settings\n\n@pytest.fixture\ndef mock_genai_client():\n    \"\"\"\n    Mocks the google.genai.Client instance.\n    The `generate_content` method is an AsyncMock for `get_response` (awaited)\n    and also configured to work for `generate_response` (not awaited).\n    \"\"\"\n    mock_client = Mock()\n    mock_client.models = Mock() # Ensure models attribute exists\n    \n    # Configure the generate_content method to be an AsyncMock.\n    # The return_value will be the awaited result for AsyncMock.\n    mock_generate_content_result = Mock()\n    mock_generate_content_result.text = \"Mocked AI response text for awaited call.\"\n    \n    # The AsyncMock instance itself needs a `.text` attribute for the\n    # `generate_response` method, which does not await.\n    mock_genai_method = AsyncMock(return_value=mock_generate_content_result)\n    mock_genai_method.text = \"Mocked AI response text for sync access.\"\n\n    mock_client.models.generate_content = mock_genai_method\n    return mock_client\n\n@pytest.fixture\ndef mock_product_data_service():\n    \"\"\"Mocks the ProductDataService instance.\"\"\"\n    mock_service = Mock()\n    mock_service.smart_search_products = AsyncMock() # smart_search_products is an async method\n    # Default return for product search: no products\n    mock_service.smart_search_products.return_value = ([], \"No specific products found.\")\n    return mock_service\n\n@pytest.fixture\ndef ai_service_instance(mock_settings, mock_genai_client, mock_product_data_service):\n    \"\"\"\n    Provides an AIService instance with its dependencies (settings, genai client,\n    and product service) mocked.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', return_value=mock_genai_client), \\\n         patch('app.services.product_data_service.ProductDataService', return_value=mock_product_data_service):\n        service = AIService()\n        yield service # Use yield to allow for potential cleanup or specific patching in tests\n\n# --- Tests for AIService Initialization ---\n\ndef test_aiservice_init_success(ai_service_instance, mock_genai_client, mock_product_data_service, caplog):\n    \"\"\"\n    Tests successful initialization of AIService.\n    Verifies that client and product_service are set and a log message is emitted.\n    \"\"\"\n    with caplog.at_level(logging.INFO):\n        assert isinstance(ai_service_instance.client, Mock)\n        assert ai_service_instance.client == mock_genai_client\n        assert isinstance(ai_service_instance.product_service, Mock)\n        assert ai_service_instance.product_service == mock_product_data_service\n        assert \"Successfully initialized AI service with Google AI client\" in caplog.text\n    # Ensure client and product service are indeed the mocked objects and their constructors were called\n    mock_genai_client.assert_called_once()\n    mock_product_data_service.assert_called_once()\n\n\ndef test_aiservice_init_get_settings_failure(caplog):\n    \"\"\"\n    Tests AIService initialization failure when get_settings raises an exception.\n    Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', side_effect=Exception(\"Config error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Config error\"):\n            AIService()\n        assert \"Error initializing AI service: Config error\" in caplog.text\n\ndef test_aiservice_init_genai_client_failure(mock_settings, caplog):\n    \"\"\"\n    Tests AIService initialization failure when google.genai.Client constructor\n    raises an exception. Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', side_effect=Exception(\"Client init error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Client init error\"):\n            AIService()\n        assert \"Error initializing AI service: Client init error\" in caplog.text\n\ndef test_aiservice_init_product_service_failure(mock_settings, mock_genai_client, caplog):\n    \"\"\"\n    Tests AIService initialization failure when ProductDataService constructor\n    raises an exception. Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', return_value=mock_genai_client), \\\n         patch('app.services.product_data_service.ProductDataService', side_effect=Exception(\"Product service init error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Product service init error\"):\n            AIService()\n        assert \"Error initializing AI service: Product service init error\" in caplog.text\n\n\n# --- Tests for get_response method ---\n\n@pytest.mark.asyncio\nasync def test_get_response_success_with_products(ai_service_instance, mock_product_data_service, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when product search returns relevant products.\n    Verifies correct context building and AI response.\n    \"\"\"\n    question = \"Cari laptop gaming di bawah 10 juta\"\n    mock_products = [\n        {\"name\": \"Awesome Laptop\", \"price\": 9500000, \"brand\": \"BrandX\", \"category\": \"laptop\", \"specifications\": {\"rating\": 4.5}, \"description\": \"High performance gaming laptop for pros.\"},\n        {\"name\": \"Budget Laptop\", \"price\": 7000000, \"brand\": \"BrandY\", \"category\": \"laptop\", \"specifications\": {\"rating\": 4.0}, \"description\": \"Affordable gaming laptop for casual gamers who want value.\"}\n    ]\n    mock_fallback_message = \"Found some great laptops for you!\"\n\n    mock_product_data_service.smart_search_products.return_value = (mock_products, mock_fallback_message)\n    mock_genai_client.models.generate_content.return_value.text = \"Based on your interest, Awesome Laptop and Budget Laptop are good options.\"\n\n    with caplog.at_level(logging.INFO):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Based on your interest, Awesome Laptop and Budget Laptop are good options.\"\n        mock_product_data_service.smart_search_products.assert_called_once_with(\n            keyword=question, category=\"laptop\", max_price=10000000, limit=5\n        )\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        prompt = call_args[0]['contents']\n\n        assert \"Question: Cari laptop gaming di bawah 10 juta\" in prompt\n        assert \"Found some great laptops for you!\" in prompt\n        assert \"Relevant Products:\" in prompt\n        assert \"1. Awesome Laptop\" in prompt\n        assert \"Price: Rp 9,500,000\" in prompt\n        assert \"Brand: BrandX\" in prompt\n        assert \"Category: laptop\" in prompt\n        assert \"Rating: 4.5/5\" in prompt\n        assert \"Description: High performance gaming laptop for pros...\" in prompt # Checks truncation\n        assert \"2. Budget Laptop\" in prompt\n        assert \"Successfully generated AI response\" in caplog.text\n        assert \"gemini-2.5-flash\" in call_args[0]['model']\n\n\n@pytest.mark.asyncio\nasync def test_get_response_success_no_products(ai_service_instance, mock_product_data_service, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when product search returns no relevant products.\n    Verifies correct context building (without products) and AI response.\n    \"\"\"\n    question = \"Can you recommend a very specific item I just made up?\"\n    mock_product_data_service.smart_search_products.return_value = ([], \"Could not find products matching your exact query.\")\n    mock_genai_client.models.generate_content.return_value.text = \"I'm sorry, I couldn't find specific products for that. Can I help with general info?\"\n\n    with caplog.at_level(logging.INFO):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"I'm sorry, I couldn't find specific products for that. Can I help with general info?\"\n        mock_product_data_service.smart_search_products.assert_called_once_with(\n            keyword=question, category=None, max_price=None, limit=5\n        )\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        prompt = call_args[0]['contents']\n\n        assert \"Question: Can you recommend a very specific item I just made up?\" in prompt\n        assert \"Could not find products matching your exact query.\" in prompt\n        assert \"No specific products found, but I can provide general recommendations.\" in prompt\n        assert \"Relevant Products:\" not in prompt # Ensure this is not present\n        assert \"Successfully generated AI response\" in caplog.text\n\n@pytest.mark.asyncio\nasync def test_get_response_ai_generation_failure(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when the AI client fails to generate a response.\n    Verifies that a friendly fallback message is returned and an error is logged.\n    \"\"\"\n    question = \"Tell me something.\"\n    mock_genai_client.models.generate_content.side_effect = Exception(\"AI API error\")\n\n    with caplog.at_level(logging.ERROR):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n        mock_genai_client.models.generate_content.assert_called_once()\n        assert \"Error generating AI response: AI API error\" in caplog.text\n\n@pytest.mark.asyncio\nasync def test_get_response_product_data_service_failure(ai_service_instance, mock_product_data_service, caplog):\n    \"\"\"\n    Tests get_response when the product data service fails.\n    Verifies that a friendly fallback message is returned and an error is logged.\n    \"\"\"\n    question = \"Cari laptop.\"\n    mock_product_data_service.smart_search_products.side_effect = Exception(\"Product service internal error\")\n\n    with caplog.at_level(logging.ERROR):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n        mock_product_data_service.smart_search_products.assert_called_once()\n        assert \"Error generating AI response: Product service internal error\" in caplog.text\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"question, expected_category, expected_max_price\",\n    [\n        (\"Cari laptop gaming 10 juta\", \"laptop\", 10_000_000),\n        (\"Smartphone murah\", \"smartphone\", 5_000_000), # Detects 'smartphone' and 'murah' for price\n        (\"Tablet di bawah 5 juta\", \"tablet\", 5_000_000), # Detects 'tablet' and '5 juta' for price\n        (\"earphone bluetooth\", \"headphone\", None),\n        (\"Kamera DSLR bagus\", \"kamera\", None),\n        (\"TV Samsung 20 juta\", \"tv\", 20_000_000),\n        (\"Jam tangan pintar\", \"jam\", None),\n        (\"Ponsel dengan budget 7 juta\", \"smartphone\", 7_000_000),\n        (\"Headset gaming\", \"headphone\", None),\n        (\"Cari produk audio\", \"audio\", None),\n        (\"Apa rekomendasi terbaik?\", None, None), # No category, no price\n        (\"Saya mau beli HP dengan 3 juta\", \"smartphone\", 3_000_000),\n        (\"drone budget 10 juta\", \"drone\", 10_000_000),\n        (\"notebook 8 juta\", \"laptop\", 8_000_000),\n        (\"ipad pro\", \"tablet\", None),\n        (\"handphone 2 juta\", \"smartphone\", 2_000_000),\n        (\"TV yang murah\", \"tv\", 5_000_000), # Test 'murah' with category\n        (\"budget murah untuk audio\", \"audio\", 5_000_000), # Test 'budget' with category\n        (\"telepon seluler\", \"smartphone\", None), # Test synonym\n        (\"komputer baru\", \"laptop\", None), # Test synonym\n        (\"fotografi gear\", \"kamera\", None), # Test synonym\n        (\"speaker bluetooth\", \"audio\", None), # Test synonym\n        (\"ponsel android 4 juta\", \"smartphone\", 4_000_000), # Combined\n        (\"smartwatch 1 juta\", \"jam\", 1_000_000), # Combined\n        (\"Produk\", None, None), # Very general, no category or price\n        (\"laptop budget\", \"laptop\", 5_000_000), # Category + \"budget\"\n        (\"Headphone murah banget\", \"headphone\", 5_000_000), # Category + \"murah\"\n        (\"Cari smartphone\", \"smartphone\", None), # Just category\n        (\"Harga 2 juta\", None, 2_000_000), # Just price (no category)\n        (\"Sebuah kamera\", \"kamera\", None), # Basic category detection\n        (\"TV\", \"tv\", None), # Minimal category detection\n    ]\n)\nasync def test_get_response_category_and_price_detection(\n    ai_service_instance, mock_product_data_service, mock_genai_client,\n    question, expected_category, expected_max_price\n):\n    \"\"\"\n    Tests that get_response correctly extracts category and max_price from various questions.\n    \"\"\"\n    await ai_service_instance.get_response(question)\n\n    mock_product_data_service.smart_search_products.assert_called_once()\n    call_args, _ = mock_product_data_service.smart_search_products.call_args\n\n    assert call_args[1]['category'] == expected_category\n    assert call_args[1]['max_price'] == expected_max_price\n    assert call_args[1]['keyword'] == question # Ensure keyword is always passed\n\n\n@pytest.mark.asyncio\nasync def test_get_response_empty_question(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests get_response with an empty question string.\n    Ensures smart_search_products is called with keyword=\"\", category=None, max_price=None.\n    \"\"\"\n    question = \"\"\n    await ai_service_instance.get_response(question)\n\n    mock_product_data_service.smart_search_products.assert_called_once_with(\n        keyword=\"\", category=None, max_price=None, limit=5\n    )\n    mock_genai_client.models.generate_content.assert_called_once()\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n    assert \"Question: \\n\\nNo specific products found, but I can provide general recommendations.\" in prompt\n    assert \"gemini-2.5-flash\" in call_args[0]['model']\n\n@pytest.mark.asyncio\nasync def test_get_response_product_context_missing_keys(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests that product context building handles missing keys gracefully by using default values.\n    \"\"\"\n    question = \"Products with missing info\"\n    mock_products = [\n        # Missing 'name', 'brand', 'category', 'specifications' (and thus rating)\n        {\"price\": 1000000, \"description\": \"A very basic product description.\"},\n        # Missing 'price', 'description', has empty 'specifications'\n        {\"name\": \"Product B\", \"brand\": \"BrandB\", \"category\": \"tablet\", \"specifications\": {}},\n        # All fields present, but rating is missing within specifications\n        {\"name\": \"Product C\", \"price\": 5000000, \"brand\": \"BrandC\", \"category\": \"laptop\", \"specifications\": {\"display\": \"13 inch\"}, \"description\": \"Another product description.\"},\n    ]\n    mock_fallback_message = \"Some products with incomplete data.\"\n    mock_product_data_service.smart_search_products.return_value = (mock_products, mock_fallback_message)\n    mock_genai_client.models.generate_content.return_value.text = \"Response about products with missing info.\"\n\n    response = await ai_service_instance.get_response(question)\n\n    assert response == \"Response about products with missing info.\"\n    mock_genai_client.models.generate_content.assert_called_once()\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n\n    assert \"1. Unknown\" in prompt\n    assert \"Price: Rp 1,000,000\" in prompt\n    assert \"Brand: Unknown\" in prompt\n    assert \"Category: Unknown\" in prompt\n    assert \"Rating: 0/5\" in prompt\n    assert \"Description: A very basic product description....\" in prompt # Default description truncation\n\n    assert \"2. Product B\" in prompt\n    assert \"Price: Rp 0\" in prompt # Default for missing price\n    assert \"Brand: BrandB\" in prompt\n    assert \"Category: tablet\" in prompt\n    assert \"Rating: 0/5\" in prompt # Default for missing rating\n    assert \"Description: No description...\" in prompt # Default for missing description\n\n    assert \"3. Product C\" in prompt\n    assert \"Price: Rp 5,000,000\" in prompt\n    assert \"Brand: BrandC\" in prompt\n    assert \"Category: laptop\" in prompt\n    assert \"Rating: 0/5\" in prompt # Default for rating if key is missing in specifications\n    assert \"Description: Another product description....\" in prompt\n\n\n@pytest.mark.asyncio\nasync def test_get_response_product_description_truncation(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests that product descriptions are truncated to 200 characters with '...' correctly.\n    \"\"\"\n    question = \"Long description product\"\n    long_description = \"A\" * 250\n    mock_products = [\n        {\"name\": \"Product with Long Desc\", \"price\": 100, \"brand\": \"Test\", \"category\": \"test\", \"specifications\": {\"rating\": 5}, \"description\": long_description},\n    ]\n    mock_product_data_service.smart_search_products.return_value = (mock_products, \"Found one.\")\n    mock_genai_client.models.generate_content.return_value.text = \"Truncated description response.\"\n\n    await ai_service_instance.get_response(question)\n\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n\n    expected_truncated_desc = long_description[:200] + \"...\"\n    assert f\"Description: {expected_truncated_desc}\\n\\n\" in prompt\n    assert len(prompt) > 200 # Ensure the full prompt is still long\n    assert prompt.count(\"...\") > 0 # Check for truncation ellipsis\n\n\n# --- Tests for generate_response method (legacy) ---\n\ndef test_generate_response_success(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests successful execution of the legacy generate_response method.\n    Verifies the correct AI model and content are used.\n    Note: This method does not 'await' the genai client call. The test accounts for this\n    by ensuring the mock returns an object with a '.text' attribute directly.\n    \"\"\"\n    context = \"This is a test context for legacy generation.\"\n    expected_response_text = \"Legacy AI response.\"\n\n    # Configure the mock_genai_client fixture's generate_content method for this specific test\n    # to return the expected text directly, as it's not awaited in generate_response.\n    # The fixture already sets `mock_genai_method.text = \"...\"` on the AwaitableMock.\n    mock_genai_client.models.generate_content.text = expected_response_text\n    \n    with caplog.at_level(logging.INFO):\n        response = ai_service_instance.generate_response(context)\n\n        assert response == expected_response_text\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        assert call_args[0]['model'] == \"gemini-2.0-flash\"\n        expected_prompt_part = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n        assert expected_prompt_part in call_args[0]['contents']\n        assert \"Successfully generated AI response\" in caplog.text\n\ndef test_generate_response_ai_generation_failure(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests generate_response when the AI client fails to generate a response.\n    Ensures an exception is re-raised and an error is logged.\n    \"\"\"\n    context = \"Failing context.\"\n    \n    # Configure the mock_genai_client fixture's generate_content method to raise an exception\n    # directly when called (as it's not awaited here).\n    mock_genai_client.models.generate_content.side_effect = Exception(\"Legacy AI API error\")\n\n    with caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Legacy AI API error\"):\n            ai_service_instance.generate_response(context)\n        mock_genai_client.models.generate_content.assert_called_once()\n        assert \"Error generating AI response: Legacy AI API error\" in caplog.text"
    },
    {
      "filepath": "app/services/product_data_service.py",
      "coverage": 35.370000000000005,
      "content": "import logging\nfrom typing import List, Dict, Optional\nfrom app.services.local_product_service import LocalProductService\n\nlogger = logging.getLogger(__name__)\n\nclass ProductDataService:\n    \"\"\"\n    Service untuk mengambil data produk dari sumber lokal yang reliable\n    \"\"\"\n    \n    def __init__(self):\n        # Use LocalProductService as primary data source\n        self.local_service = LocalProductService()\n        logger.info(\"ProductDataService initialized with LocalProductService\")\n    \n    async def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Search products using local data\"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            # Use awaitable wrapper for sync method\n            import asyncio\n            loop = asyncio.get_event_loop()\n            products = await loop.run_in_executor(None, self.local_service.search_products, keyword, limit)\n            logger.info(f\"Found {len(products)} products for keyword: {keyword}\")\n            return products\n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    async def get_products(self, limit: int = 20, category: Optional[str] = None, search: Optional[str] = None) -> List[Dict]:\n        \"\"\"Get products with optional filtering\"\"\"\n        try:\n            if search:\n                return await self.search_products(search, limit)\n            elif category:\n                return self.get_products_by_category(category, limit)\n            else:\n                return self.get_all_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return self.local_service.get_products(limit)\n    \n    async def get_categories(self) -> List[str]:\n        \"\"\"Get available categories\"\"\"\n        try:\n            return self.local_service.get_categories()\n        except Exception as e:\n            logger.error(f\"Error getting categories: {str(e)}\")\n            return []\n    \n    async def get_top_rated_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get top rated products\"\"\"\n        try:\n            return self.local_service.get_top_rated_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    async def get_best_selling_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get best selling products\"\"\"\n        try:\n            return self.local_service.get_best_selling_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products_by_category(self, category: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by category\"\"\"\n        try:\n            return self.local_service.get_products_by_category(category)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_all_products(self, limit: int = 20) -> List[Dict]:\n        \"\"\"Get all products\"\"\"\n        try:\n            return self.local_service.get_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting all products: {str(e)}\")\n            return []\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"Get product details by ID\"\"\"\n        try:\n            return self.local_service.get_product_details(product_id)\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"Get available brands\"\"\"\n        try:\n            return self.local_service.get_brands()\n        except Exception as e:\n            logger.error(f\"Error getting brands: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by brand\"\"\"\n        try:\n            return self.local_service.get_products_by_brand(brand)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    async def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: gunakan LocalProductService.smart_search_products secara async.\n        Return: (list produk, pesan)\n        \"\"\"\n        import asyncio\n        loop = asyncio.get_event_loop()\n        products, message = await loop.run_in_executor(\n            None, self.local_service.smart_search_products, keyword, category, max_price, limit\n        )\n        return products, message ",
      "existing_test": "import logging\nimport pytest\nimport asyncio\nfrom unittest.mock import MagicMock, AsyncMock, patch\n\n# Define the path to the module under test for patching purposes\nPRODUCT_DATA_SERVICE_MODULE = 'app.services.product_data_service'\n\n# Define a mock specification for LocalProductService methods\n# This helps ensure that methods called on the mock exist on the real object,\n# preventing silent errors from typos in method names.\nclass MockLocalProductServiceSpec:\n    def search_products(self, keyword: str, limit: int = 10): pass\n    def get_products(self, limit: int = 20): pass # This method takes limit\n    def get_categories(self) -> list: pass\n    def get_top_rated_products(self, limit: int = 10) -> list: pass\n    def get_best_selling_products(self, limit: int = 10) -> list: pass\n    def get_products_by_category(self, category: str) -> list: pass # ProductDataService applies limit by slicing\n    def get_product_details(self, product_id: str): pass\n    def get_brands(self) -> list: pass\n    def get_products_by_brand(self, brand: str) -> list: pass # ProductDataService applies limit by slicing\n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5): pass\n\n\n@pytest.fixture\ndef mock_local_service(mocker):\n    \"\"\"\n    Mocks the LocalProductService that ProductDataService uses.\n    This fixture patches the imported LocalProductService within the target module.\n    \"\"\"\n    # Patch `LocalProductService` as it's imported within `product_data_service.py`\n    mock_lps = mocker.patch(\n        f'{PRODUCT_DATA_SERVICE_MODULE}.LocalProductService',\n        autospec=MockLocalProductServiceSpec # Use autospec to validate method calls\n    ).return_value\n\n    # Set default return values for the mock methods to prevent NoneType errors\n    # for methods that are not specifically configured in a test.\n    mock_lps.get_products_by_category.return_value = []\n    mock_lps.get_products.return_value = []\n    mock_lps.get_product_details.return_value = None\n    mock_lps.get_brands.return_value = []\n    mock_lps.get_products_by_brand.return_value = []\n    mock_lps.get_categories.return_value = []\n    mock_lps.get_top_rated_products.return_value = []\n    mock_lps.get_best_selling_products.return_value = []\n    mock_lps.search_products.return_value = []\n    mock_lps.smart_search_products.return_value = ([], \"\")\n\n    return mock_lps\n\n\n@pytest.fixture\ndef product_data_service(mock_local_service):\n    \"\"\"\n    Provides an instance of ProductDataService with its dependencies mocked.\n    Import is done inside the fixture to ensure the patch is active when the class is defined.\n    \"\"\"\n    # Import ProductDataService after LocalProductService has been patched\n    from app.services.product_data_service import ProductDataService\n    service = ProductDataService()\n    # Assert that the service uses our mock\n    assert service.local_service is mock_local_service\n    return service\n\n\n@pytest.fixture\ndef mock_run_in_executor(mocker):\n    \"\"\"\n    Mocks asyncio.get_event_loop().run_in_executor to return an awaitable.\n    This allows controlling the return value or side effect of the executor.\n    \"\"\"\n    # Patch `asyncio.get_event_loop`\n    mock_loop = mocker.patch(f'{PRODUCT_DATA_SERVICE_MODULE}.asyncio.get_event_loop').return_value\n    \n    # Create an AsyncMock for the return value of run_in_executor.\n    # When `await mock_loop.run_in_executor(...)` is called, it will resolve to this mock's value.\n    mock_executor_awaitable = AsyncMock()\n    mock_loop.run_in_executor.return_value = mock_executor_awaitable\n    \n    # The fixture returns the AsyncMock itself, so tests can set its return_value or side_effect.\n    return mock_executor_awaitable\n\n\n# --- Test Cases for ProductDataService ---\n\nclass TestProductDataService:\n\n    @pytest.mark.asyncio\n    async def test_init(self, mock_local_service, caplog):\n        \"\"\"Test ProductDataService initialization.\"\"\"\n        from app.services.product_data_service import ProductDataService\n        with caplog.at_level(logging.INFO):\n            service = ProductDataService()\n            assert service.local_service is mock_local_service\n            assert \"ProductDataService initialized with LocalProductService\" in caplog.text\n\n    @pytest.mark.asyncio\n    async def test_search_products_success(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"1\", \"name\": \"Laptop\", \"price\": 1200}]\n        mock_run_in_executor.return_value = expected_products\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"laptop\", limit=5)\n            assert products == expected_products\n            assert \"Searching products with keyword: laptop\" in caplog.text\n            assert \"Found 1 products for keyword: laptop\" in caplog.text\n        \n        # Verify run_in_executor was called with the correct local_service method and arguments\n        product_data_service.local_service.search_products.assert_called_once_with(\"laptop\", 5)\n\n    @pytest.mark.asyncio\n    async def test_search_products_no_results(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products returns an empty list when no products are found.\"\"\"\n        mock_run_in_executor.return_value = []\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"nonexistent\", limit=10)\n            assert products == []\n            assert \"Found 0 products for keyword: nonexistent\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"nonexistent\", 10)\n\n    @pytest.mark.asyncio\n    async def test_search_products_exception(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products handles exceptions gracefully and logs an error.\"\"\"\n        mock_run_in_executor.side_effect = Exception(\"Local service error during search\")\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.search_products(\"error_case\")\n            assert products == []\n            assert \"Error searching products: Local service error during search\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"error_case\", 10)\n\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_search(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test get_products dispatches to search_products when 'search' keyword is present.\"\"\"\n        expected_products = [{\"id\": \"s1\", \"name\": \"Search Result\"}]\n        # Mock the underlying call that search_products uses\n        product_data_service.local_service.search_products.return_value = expected_products\n        mock_run_in_executor.return_value = expected_products # Ensures the await in search_products gets the value\n        \n        products = await product_data_service.get_products(search=\"query\", limit=5)\n        assert products == expected_products\n        # Verify that local_service.search_products was called via run_in_executor\n        product_data_service.local_service.search_products.assert_called_once_with(\"query\", 5)\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_category(self, product_data_service):\n        \"\"\"Test get_products dispatches to get_products_by_category when 'category' is present.\"\"\"\n        expected_products = [{\"id\": \"c1\", \"name\": \"Category Item\"}]\n        # This will be called by ProductDataService's get_products_by_category method, not directly by get_products\n        product_data_service.local_service.get_products_by_category.return_value = expected_products\n        \n        products = await product_data_service.get_products(category=\"electronics\", limit=10)\n        assert products == expected_products\n        # local_service's method is called by the ProductDataService's internal method\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    @pytest.mark.asyncio\n    async def test_get_products_no_filters(self, product_data_service):\n        \"\"\"Test get_products dispatches to get_all_products when no filters are present.\"\"\"\n        expected_products = [{\"id\": \"a1\", \"name\": \"All Item\"}]\n        # This will be called by ProductDataService's get_all_products method\n        product_data_service.local_service.get_products.return_value = expected_products\n        \n        products = await product_data_service.get_products(limit=15)\n        assert products == expected_products\n        # local_service's method is called by the ProductDataService's internal method\n        product_data_service.local_service.get_products.assert_called_once_with(15)\n\n    @pytest.mark.asyncio\n    async def test_get_products_exception_fallback(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test get_products falls back to local_service.get_products on error in 'search' dispatch.\"\"\"\n        # Simulate an error in the search path to trigger the fallback\n        mock_run_in_executor.side_effect = Exception(\"Search path failed\")\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback\", \"name\": \"Fallback Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(search=\"err\", limit=5)\n            assert products == fallback_products\n            assert \"Error getting products: Search path failed\" in caplog.text\n        \n        # Verify fallback call\n        product_data_service.local_service.get_products.assert_called_once_with(5)\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_category_exception_fallback(self, product_data_service, mocker, caplog):\n        \"\"\"\n        Test get_products falls back to local_service.get_products when\n        get_products_by_category (called internally) raises an exception.\n        \"\"\"\n        # Patch the internal method get_products_by_category to raise an exception\n        mocker.patch.object(product_data_service, 'get_products_by_category', side_effect=Exception(\"Category processing failed\"))\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback_cat\", \"name\": \"Fallback Category Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(category=\"error_cat\", limit=7)\n            assert products == fallback_products\n            assert \"Error getting products: Category processing failed\" in caplog.text\n        \n        # Verify that get_products_by_category was attempted and then fallback occurred\n        product_data_service.get_products_by_category.assert_called_once_with(\"error_cat\", 7)\n        product_data_service.local_service.get_products.assert_called_once_with(7)\n\n\n    @pytest.mark.asyncio\n    async def test_get_products_no_filters_exception_fallback(self, product_data_service, mocker, caplog):\n        \"\"\"\n        Test get_products falls back to local_service.get_products when\n        get_all_products (called internally) raises an exception.\n        \"\"\"\n        # Patch the internal method get_all_products to raise an exception\n        mocker.patch.object(product_data_service, 'get_all_products', side_effect=Exception(\"All products processing failed\"))\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback_all\", \"name\": \"Fallback All Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(limit=12)\n            assert products == fallback_products\n            assert \"Error getting products: All products processing failed\" in caplog.text\n        \n        # Verify that get_all_products was attempted and then fallback occurred\n        product_data_service.get_all_products.assert_called_once_with(12)\n        product_data_service.local_service.get_products.assert_called_once_with(12)\n\n\n    @pytest.mark.asyncio\n    async def test_get_categories_success(self, product_data_service):\n        \"\"\"Test get_categories returns categories successfully.\"\"\"\n        expected_categories = [\"Electronics\", \"Books\", \"Clothing\"]\n        product_data_service.local_service.get_categories.return_value = expected_categories\n        \n        categories = await product_data_service.get_categories()\n        assert categories == expected_categories\n        product_data_service.local_service.get_categories.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_get_categories_exception(self, product_data_service, caplog):\n        \"\"\"Test get_categories handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_categories.side_effect = Exception(\"Category service down\")\n        \n        with caplog.at_level(logging.ERROR):\n            categories = await product_data_service.get_categories()\n            assert categories == []\n            assert \"Error getting categories: Category service down\" in caplog.text\n        \n        product_data_service.local_service.get_categories.assert_called_once()\n\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_success(self, product_data_service):\n        \"\"\"Test get_top_rated_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"t1\", \"name\": \"Top Product\", \"rating\": 5.0}]\n        product_data_service.local_service.get_top_rated_products.return_value = expected_products\n        \n        products = await product_data_service.get_top_rated_products(limit=2)\n        assert products == expected_products\n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(2)\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_top_rated_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_top_rated_products.side_effect = Exception(\"Top rated service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_top_rated_products()\n            assert products == []\n            assert \"Error getting top rated products: Top rated service error\" in caplog.text\n        \n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(10)\n\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_success(self, product_data_service):\n        \"\"\"Test get_best_selling_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"b1\", \"name\": \"Best Seller\", \"sales\": 1000}]\n        product_data_service.local_service.get_best_selling_products.return_value = expected_products\n        \n        products = await product_data_service.get_best_selling_products(limit=3)\n        assert products == expected_products\n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(3)\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_best_selling_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_best_selling_products.side_effect = Exception(\"Best selling service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_best_selling_products()\n            assert products == []\n            assert \"Error getting best selling products: Best selling service error\" in caplog.text\n        \n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(10)\n\n\n    def test_get_products_by_category_success(self, product_data_service):\n        \"\"\"Test get_products_by_category returns products and applies limit.\"\"\"\n        # Simulate more products than limit to test slicing\n        all_cat_products = [{\"id\": \"c1\"}, {\"id\": \"c2\"}, {\"id\": \"c3\"}, {\"id\": \"c4\"}]\n        product_data_service.local_service.get_products_by_category.return_value = all_cat_products\n        \n        products = product_data_service.get_products_by_category(\"electronics\", limit=2)\n        assert products == [{\"id\": \"c1\"}, {\"id\": \"c2\"}]\n        # local_service.get_products_by_category does not take limit directly\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    def test_get_products_by_category_no_results(self, product_data_service):\n        \"\"\"Test get_products_by_category returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products_by_category.return_value = []\n        \n        products = product_data_service.get_products_by_category(\"unknown_category\")\n        assert products == []\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"unknown_category\")\n\n    def test_get_products_by_category_exception(self, product_data_service, caplog):\n        \"\"\"Test get_products_by_category handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products_by_category.side_effect = Exception(\"Category DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_products_by_category(\"failed_cat\")\n            assert products == []\n            assert \"Error getting products by category: Category DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"failed_cat\")\n\n\n    def test_get_all_products_success(self, product_data_service):\n        \"\"\"Test get_all_products returns products and passes limit to local service.\"\"\"\n        # local_service.get_products takes limit directly\n        all_products = [{\"id\": \"a1\"}, {\"id\": \"a2\"}, {\"id\": \"a3\"}]\n        product_data_service.local_service.get_products.return_value = all_products\n        \n        products = product_data_service.get_all_products(limit=2)\n        # Note: The service's get_all_products calls local_service.get_products(limit).\n        # It does NOT apply slicing *after* that call, so if local_service.get_products\n        # returns more than 'limit', this test needs to reflect that behavior.\n        # The current mock returns exactly `all_products` for `get_products`,\n        # so the assertion should be `all_products[:limit]` if the LocalProductService\n        # itself doesn't guarantee the limit. However, the mock spec implies\n        # local_service.get_products takes the limit and should respect it.\n        # So, if mock returns 3 but limit is 2, the mock should actually return 2.\n        # Let's adjust mock_lps.get_products return value to reflect the limit properly.\n        product_data_service.local_service.get_products.return_value = all_products[:2] # Explicitly mock what the underlying service would return given the limit\n        \n        products = product_data_service.get_all_products(limit=2)\n        assert products == all_products[:2]\n        product_data_service.local_service.get_products.assert_called_once_with(2)\n\n    def test_get_all_products_no_results(self, product_data_service):\n        \"\"\"Test get_all_products returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products.return_value = []\n        \n        products = product_data_service.get_all_products()\n        assert products == []\n        product_data_service.local_service.get_products.assert_called_once_with(20)\n\n    def test_get_all_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_all_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products.side_effect = Exception(\"All products DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_all_products()\n            assert products == []\n            assert \"Error getting all products: All products DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products.assert_called_once_with(20)\n\n\n    def test_get_product_details_success(self, product_data_service):\n        \"\"\"Test get_product_details returns product details.\"\"\"\n        expected_details = {\"id\": \"p123\", \"name\": \"Widget X\", \"description\": \"A fine widget.\"}\n        product_data_service.local_service.get_product_details.return_value = expected_details\n        \n        details = product_data_service.get_product_details(\"p123\")\n        assert details == expected_details\n        product_data_service.local_service.get_product_details.assert_called_once_with(\"p123\")\n\n    def test_get_product_details_not_found(self, product_data_service):\n        \"\"\"Test get_product_details returns None if product not found.\"\"\"\n        product_data_service.local_service.get_product_details.return_value = None\n        \n        details = product_data_service.get_product_details(\"nonexistent\")\n        assert details is None\n        product_data_service.local_service.get_product_details.assert_called_once_with(\"nonexistent\")\n\n    def test_get_product_details_exception(self, product_data_service, caplog):\n        \"\"\"Test get_product_details handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_product_details.side_effect = Exception(\"Details service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            details = product_data_service.get_product_details(\"error_id\")\n            assert details is None\n            assert \"Error getting product details: Details service error\" in caplog.text\n        \n        product_data_service.local_service.get_product_details.assert_called_once_with(\"error_id\")\n\n\n    def test_get_brands_success(self, product_data_service):\n        \"\"\"Test get_brands returns list of brands.\"\"\"\n        expected_brands = [\"Brand A\", \"Brand B\", \"Brand C\"]\n        product_data_service.local_service.get_brands.return_value = expected_brands\n        \n        brands = product_data_service.get_brands()\n        assert brands == expected_brands\n        product_data_service.local_service.get_brands.assert_called_once()\n\n    def test_get_brands_exception(self, product_data_service, caplog):\n        \"\"\"Test get_brands handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_brands.side_effect = Exception(\"Brand service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            brands = product_data_service.get_brands()\n            assert brands == []\n            assert \"Error getting brands: Brand service error\" in caplog.text\n        \n        product_data_service.local_service.get_brands.assert_called_once()\n\n\n    def test_get_products_by_brand_success(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns products and applies limit.\"\"\"\n        all_brand_products = [{\"id\": \"br1\"}, {\"id\": \"br2\"}, {\"id\": \"br3\"}, {\"id\": \"br4\"}]\n        product_data_service.local_service.get_products_by_brand.return_value = all_brand_products\n        \n        products = product_data_service.get_products_by_brand(\"brandx\", limit=2)\n        assert products == [{\"id\": \"br1\"}, {\"id\": \"br2\"}]\n        # local_service.get_products_by_brand does not take limit directly\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"brandx\")\n\n    def test_get_products_by_brand_no_results(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products_by_brand.return_value = []\n        \n        products = product_data_service.get_products_by_brand(\"unknown_brand\")\n        assert products == []\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"unknown_brand\")\n\n    def test_get_products_by_brand_exception(self, product_data_service, caplog):\n        \"\"\"Test get_products_by_brand handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products_by_brand.side_effect = Exception(\"Brand DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_products_by_brand(\"failed_brand\")\n            assert products == []\n            assert \"Error getting products by brand: Brand DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"failed_brand\")\n\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_success(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products returns products and message successfully.\"\"\"\n        expected_products = [{\"id\": \"s_s1\", \"name\": \"Smart Item\"}]\n        expected_message = \"Smart search completed.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result # What the await resolves to\n\n        products, message = await product_data_service.smart_search_products(\n            keyword=\"smart\", category=\"books\", max_price=50, limit=3\n        )\n        assert products == expected_products\n        assert message == expected_message\n        \n        product_data_service.local_service.smart_search_products.assert_called_once_with(\n            \"smart\", \"books\", 50, 3\n        )\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_default_args(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products uses default arguments correctly.\"\"\"\n        expected_products = [{\"id\": \"s_s_def\", \"name\": \"Default Search\"}]\n        expected_message = \"Default search.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result\n\n        products, message = await product_data_service.smart_search_products() # No args\n        assert products == expected_products\n        assert message == expected_message\n        \n        # Verify that the local service method was called with default values\n        product_data_service.local_service.smart_search_products.assert_called_once_with(\n            '', None, None, 5\n        )\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_exception(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products propagates exceptions as it has no try-except.\"\"\"\n        mock_run_in_executor.side_effect = Exception(\"Smart search internal error\")\n\n        with pytest.raises(Exception, match=\"Smart search internal error\"):\n            await product_data_service.smart_search_products(\"fail_keyword\")\n\n        # Verify that the local service method was still attempted to be called\n        product_data_service.local_service.smart_search_products.assert_called_once_with(\"fail_keyword\", None, None, 5)"
    },
    {
      "filepath": "app/services/local_product_service.py",
      "coverage": 82.42,
      "content": "import logging\nimport json\nimport random\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass LocalProductService:\n    \"\"\"\n    Service untuk data produk lokal yang reliable dan tidak bergantung pada API eksternal\n    \"\"\"\n    \n    def __init__(self):\n        self.products = self._load_local_products()\n        logger.info(f\"Loaded {len(self.products)} local products from JSON file\")\n    \n    def _load_local_products(self) -> List[Dict]:\n        \"\"\"Load produk dari file JSON lokal\"\"\"\n        try:\n            # Get the path to the data/products.json file\n            current_dir = Path(__file__).parent.parent.parent\n            json_file_path = current_dir / \"data\" / \"products.json\"\n            \n            if not json_file_path.exists():\n                logger.error(f\"Products JSON file not found at: {json_file_path}\")\n                return self._get_fallback_products()\n            \n            # Try different encodings\n            encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n            \n            for encoding in encodings:\n                try:\n                    with open(json_file_path, 'r', encoding=encoding) as file:\n                        content = file.read()\n                        # Remove BOM if present\n                        if content.startswith('\\ufeff'):\n                            content = content[1:]\n                        \n                        data = json.loads(content)\n                        products = data.get('products', [])\n                        \n                        # Transform products to match expected format\n                        transformed_products = []\n                        for product in products:\n                            transformed_product = {\n                                \"id\": product.get('id', ''),\n                                \"name\": product.get('name', ''),\n                                \"category\": product.get('category', ''),\n                                \"brand\": product.get('brand', ''),\n                                \"price\": product.get('price', 0),\n                                \"currency\": product.get('currency', 'IDR'),\n                                \"description\": product.get('description', ''),\n                                \"specifications\": {\n                                    \"rating\": product.get('rating', 0),\n                                    \"sold\": random.randint(100, 2000),  # Add random sold count\n                                    \"stock\": product.get('stock_count', 0),\n                                    \"condition\": \"Baru\",\n                                    \"shop_location\": \"Indonesia\",\n                                    \"shop_name\": f\"{product.get('brand', 'Unknown')} Store\",\n                                    **product.get('specifications', {})\n                                },\n                                \"availability\": product.get('availability', 'in_stock'),\n                                \"reviews_count\": product.get('reviews_count', 0),\n                                \"images\": [f\"https://example.com/{product.get('id', 'product')}.jpg\"],\n                                \"url\": f\"https://shopee.co.id/{product.get('id', 'product')}\"\n                            }\n                            transformed_products.append(transformed_product)\n                        \n                        logger.info(f\"Successfully loaded {len(transformed_products)} products from JSON file using {encoding} encoding\")\n                        return transformed_products\n                        \n                except (UnicodeDecodeError, json.JSONDecodeError) as e:\n                    logger.warning(f\"Failed to load with {encoding} encoding: {str(e)}\")\n                    continue\n            \n            # If all encodings fail, use fallback\n            logger.error(\"All encoding attempts failed, using fallback products\")\n            return self._get_fallback_products()\n                \n        except Exception as e:\n            logger.error(f\"Error loading products from JSON file: {str(e)}\")\n            return self._get_fallback_products()\n    \n    def _get_fallback_products(self) -> List[Dict]:\n        \"\"\"Fallback products if JSON file cannot be loaded\"\"\"\n        logger.warning(\"Using fallback products due to JSON file loading error\")\n        return [\n            {\n                \"id\": \"1\",\n                \"name\": \"iPhone 15 Pro Max\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Apple\",\n                \"price\": 25000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPhone 15 Pro Max dengan chip A17 Pro, kamera 48MP, dan layar 6.7 inch Super Retina XDR. Dilengkapi dengan titanium design dan performa gaming yang luar biasa.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 1250,\n                    \"stock\": 50,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Titanium Natural\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"A17 Pro\",\n                    \"camera\": \"48MP Main + 12MP Ultra Wide + 12MP Telephoto\",\n                    \"display\": \"6.7 inch Super Retina XDR\"\n                },\n                \"images\": [\"https://example.com/iphone15.jpg\"],\n                \"url\": \"https://shopee.co.id/iphone-15-pro-max\"\n            },\n            {\n                \"id\": \"2\", \n                \"name\": \"Samsung Galaxy S24 Ultra\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Samsung\",\n                \"price\": 22000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy S24 Ultra dengan S Pen, kamera 200MP, dan AI features canggih. Dilengkapi dengan Snapdragon 8 Gen 3 dan layar AMOLED 6.8 inch.\",\n                \"specifications\": {\n                    \"rating\": 4.7,\n                    \"sold\": 980,\n                    \"stock\": 35,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"512GB\",\n                    \"color\": \"Titanium Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 3\",\n                    \"camera\": \"200MP Main + 12MP Ultra Wide + 50MP Telephoto + 10MP Telephoto\",\n                    \"display\": \"6.8 inch Dynamic AMOLED 2X\"\n                },\n                \"images\": [\"https://example.com/s24-ultra.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-s24-ultra\"\n            },\n            {\n                \"id\": \"3\",\n                \"name\": \"MacBook Pro 14 inch M3\",\n                \"category\": \"Laptop\",\n                \"brand\": \"Apple\",\n                \"price\": 35000000,\n                \"currency\": \"IDR\",\n                \"description\": \"MacBook Pro dengan chip M3, layar 14 inch Liquid Retina XDR, dan performa tinggi untuk profesional. Cocok untuk video editing, programming, dan gaming.\",\n                \"specifications\": {\n                    \"rating\": 4.9,\n                    \"sold\": 450,\n                    \"stock\": 25,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"1TB\",\n                    \"color\": \"Space Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M3\",\n                    \"ram\": \"16GB Unified Memory\",\n                    \"display\": \"14 inch Liquid Retina XDR\"\n                },\n                \"images\": [\"https://example.com/macbook-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/macbook-pro-m3\"\n            },\n            {\n                \"id\": \"4\",\n                \"name\": \"AirPods Pro 2nd Gen\",\n                \"category\": \"Audio\",\n                \"brand\": \"Apple\",\n                \"price\": 4500000,\n                \"currency\": \"IDR\",\n                \"description\": \"AirPods Pro dengan Active Noise Cancellation dan Spatial Audio. Dilengkapi dengan chip H2 untuk performa audio yang lebih baik dan fitur Find My.\",\n                \"specifications\": {\n                    \"rating\": 4.6,\n                    \"sold\": 2100,\n                    \"stock\": 100,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"color\": \"White\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"6 jam dengan ANC, 30 jam dengan case\",\n                    \"features\": \"Active Noise Cancellation, Spatial Audio, Find My\"\n                },\n                \"images\": [\"https://example.com/airpods-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/airpods-pro-2\"\n            },\n            {\n                \"id\": \"5\",\n                \"name\": \"iPad Air 5th Gen\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Apple\",\n                \"price\": 12000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPad Air dengan chip M1, layar 10.9 inch Liquid Retina, dan Apple Pencil support. Cocok untuk kreativitas, note-taking, dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.5,\n                    \"sold\": 750,\n                    \"stock\": 40,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Medan\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Blue\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M1\",\n                    \"display\": \"10.9 inch Liquid Retina\",\n                    \"features\": \"Apple Pencil support, Magic Keyboard support\"\n                },\n                \"images\": [\"https://example.com/ipad-air.jpg\"],\n                \"url\": \"https://shopee.co.id/ipad-air-5\"\n            },\n            {\n                \"id\": \"6\",\n                \"name\": \"ASUS ROG Strix G15\",\n                \"category\": \"Laptop\",\n                \"brand\": \"ASUS\",\n                \"price\": 18000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Laptop gaming ASUS ROG Strix G15 dengan RTX 4060, AMD Ryzen 7, dan layar 15.6 inch 144Hz. Dilengkapi dengan RGB keyboard dan cooling system yang powerful.\",\n                \"specifications\": {\n                    \"rating\": 4.4,\n                    \"sold\": 320,\n                    \"stock\": 15,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"ASUS Store\",\n                    \"storage\": \"512GB SSD\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"2 Tahun\",\n                    \"processor\": \"AMD Ryzen 7 7735HS\",\n                    \"gpu\": \"NVIDIA RTX 4060 8GB\",\n                    \"ram\": \"16GB DDR5\",\n                    \"display\": \"15.6 inch FHD 144Hz\"\n                },\n                \"images\": [\"https://example.com/rog-strix.jpg\"],\n                \"url\": \"https://shopee.co.id/asus-rog-strix-g15\"\n            },\n            {\n                \"id\": \"7\",\n                \"name\": \"Sony WH-1000XM5\",\n                \"category\": \"Audio\",\n                \"brand\": \"Sony\",\n                \"price\": 5500000,\n                \"currency\": \"IDR\",\n                \"description\": \"Headphone wireless Sony WH-1000XM5 dengan noise cancellation terbaik di kelasnya. Dilengkapi dengan 30 jam battery life dan quick charge.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 890,\n                    \"stock\": 30,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Sony Store\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"30 jam dengan ANC\",\n                    \"features\": \"Industry-leading noise cancellation, Quick Charge, Multipoint connection\"\n                },\n                \"images\": [\"https://example.com/sony-wh1000xm5.jpg\"],\n                \"url\": \"https://shopee.co.id/sony-wh1000xm5\"\n            },\n            {\n                \"id\": \"8\",\n                \"name\": \"Samsung Galaxy Tab S9\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Samsung\",\n                \"price\": 15000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy Tab S9 dengan S Pen, layar AMOLED 11 inch, dan Snapdragon 8 Gen 2. Cocok untuk productivity dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.3,\n                    \"sold\": 280,\n                    \"stock\": 20,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Graphite\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 2\",\n                    \"display\": \"11 inch Dynamic AMOLED 2X\",\n                    \"features\": \"S Pen included, DeX mode, Multi-window\"\n                },\n                \"images\": [\"https://example.com/galaxy-tab-s9.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-galaxy-tab-s9\"\n            }\n        ]\n    \n    def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"\n        Search products berdasarkan keyword\n        \"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            \n            keyword_lower = keyword.lower()\n            filtered_products = []\n            \n            # Extract price range from keyword\n            max_price = self._extract_price_from_keyword(keyword)\n            \n            for product in self.products:\n                product_price = product.get('price', 0)\n                \n                # Check if product matches price range\n                if max_price and product_price <= max_price:\n                    filtered_products.append(product)\n                    continue\n                \n                # Search in name, description, category, brand, and specifications\n                searchable_text = (\n                    product.get('name', '') + ' ' +\n                    product.get('description', '') + ' ' +\n                    product.get('category', '') + ' ' +\n                    product.get('brand', '') + ' ' +\n                    str(product.get('specifications', {}))\n                ).lower()\n                \n                if keyword_lower in searchable_text:\n                    filtered_products.append(product)\n            \n            # Sort by relevance (exact matches first, then by price if budget search)\n            def relevance_score(product):\n                score = 0\n                if keyword_lower in product.get('name', '').lower():\n                    score += 10\n                if keyword_lower in product.get('brand', '').lower():\n                    score += 5\n                if keyword_lower in product.get('category', '').lower():\n                    score += 3\n                \n                # For budget searches, prefer lower prices\n                if max_price or any(word in keyword_lower for word in ['murah', 'budget', 'hemat', 'terjangkau']):\n                    score += (10000000 - product.get('price', 0)) / 1000000  # Higher score for lower prices\n                \n                return score\n            \n            filtered_products.sort(key=relevance_score, reverse=True)\n            \n            logger.info(f\"Found {len(filtered_products)} products\")\n            return filtered_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    def _extract_price_from_keyword(self, keyword: str) -> Optional[int]:\n        \"\"\"\n        Extract maximum price from keyword\n        \"\"\"\n        try:\n            keyword_lower = keyword.lower()\n            \n            # Common price patterns\n            price_patterns = [\n                (r'(\\d+)\\s*juta', lambda x: int(x) * 1000000),\n                (r'(\\d+)\\s*ribu', lambda x: int(x) * 1000),\n                (r'rp\\s*(\\d+)', lambda x: int(x)),\n                (r'(\\d+)\\s*rp', lambda x: int(x)),\n                (r'(\\d+)\\s*k', lambda x: int(x) * 1000),\n                (r'(\\d+)\\s*m', lambda x: int(x) * 1000000),\n            ]\n            \n            import re\n            for pattern, converter in price_patterns:\n                match = re.search(pattern, keyword_lower)\n                if match:\n                    return converter(match.group(1))\n            \n            # Budget keywords\n            budget_keywords = {\n                'murah': 5000000,  # 5 juta\n                'budget': 5000000,\n                'hemat': 3000000,  # 3 juta\n                'terjangkau': 4000000,  # 4 juta\n                'ekonomis': 2000000,  # 2 juta\n            }\n            \n            for word, max_price in budget_keywords.items():\n                if word in keyword_lower:\n                    return max_price\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error extracting price from keyword: {str(e)}\")\n            return None\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"\n        Get detail produk berdasarkan ID\n        \"\"\"\n        try:\n            for product in self.products:\n                if product.get('id') == product_id:\n                    return product\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_categories(self) -> List[str]:\n        \"\"\"\n        Get daftar kategori produk\n        \"\"\"\n        categories = set()\n        for product in self.products:\n            categories.add(product.get('category', ''))\n        return sorted(list(categories))\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"\n        Get daftar brand produk\n        \"\"\"\n        brands = set()\n        for product in self.products:\n            brands.add(product.get('brand', ''))\n        return sorted(list(brands))\n    \n    def get_products_by_category(self, category: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan kategori\n        \"\"\"\n        try:\n            category_lower = category.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if category_lower in product.get('category', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan brand\n        \"\"\"\n        try:\n            brand_lower = brand.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if brand_lower in product.get('brand', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    def get_top_rated_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"\n        Get produk dengan rating tertinggi\n        \"\"\"\n        try:\n            sorted_products = sorted(\n                self.products, \n                key=lambda x: x.get('specifications', {}).get('rating', 0), \n                reverse=True\n            )\n            return sorted_products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    def get_best_selling_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"Get produk dengan penjualan tertinggi\"\"\"\n        try:\n            logger.info(f\"Getting best selling products, limit: {limit}\")\n            \n            # Sort berdasarkan sold count\n            sorted_products = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n            \n            logger.info(f\"Returning {min(limit, len(sorted_products))} best selling products\")\n            return sorted_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get semua produk\"\"\"\n        try:\n            logger.info(f\"Getting all products, limit: {limit}\")\n            return self.products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return []\n    \n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: cari produk sesuai kriteria, lalu fallback bertingkat dengan notifikasi.\n        Return: (list produk, pesan)\n        \"\"\"\n        keyword_lower = (keyword or '').lower()\n        \n        # Deteksi permintaan \"terbaik\"\n        is_best_request = 'terbaik' in keyword_lower or 'best' in keyword_lower\n        \n        # 1. Jika user minta \"terbaik\" tanpa kategori spesifik\n        if is_best_request and not category:\n            # Tampilkan produk terbaik secara umum (top 5 berdasarkan rating)\n            best_products = sorted(self.products, \n                                 key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                 reverse=True)\n            return best_products[:limit], \"Berikut produk terbaik berdasarkan rating:\"\n        \n        # 2. Jika user minta \"terbaik\" dengan kategori spesifik\n        if is_best_request and category:\n            category_products = [p for p in self.products \n                               if category.lower() in p.get('category', '').lower()]\n            if category_products:\n                category_products.sort(key=lambda x: x.get('specifications', {}).get('rating', 0), reverse=True)\n                return category_products[:limit], f\"Berikut {category} terbaik berdasarkan rating:\"\n            else:\n                # Fallback ke produk terbaik secara umum jika kategori tidak ditemukan\n                best_products = sorted(self.products, \n                                     key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                     reverse=True)\n                return best_products[:limit], f\"Tidak ada produk kategori {category}, berikut produk terbaik secara umum:\"\n        \n        # 3. Cari produk yang memenuhi semua kriteria (non-terbaik)\n        results = [\n            p for p in self.products\n            if (not category or category.lower() in p.get('category', '').lower())\n            and (not max_price or p.get('price', 0) <= max_price)\n            and (not keyword or keyword_lower in (p.get('name', '') + ' ' + p.get('description', '') + ' ' + p.get('category', '') + ' ' + p.get('brand', '') + str(p.get('specifications', {}))).lower())\n        ]\n        if results:\n            return results[:limit], \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n        # 4. Jika tidak ada, cari produk di kategori yang sama (tanpa filter harga)\n        if category:\n            category_results = [\n                p for p in self.products\n                if category.lower() in p.get('category', '').lower()\n            ]\n            if category_results:\n                category_results.sort(key=lambda x: x.get('price', 0))\n                return category_results[:limit], \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\n        # 5. Jika tetap tidak ada, tampilkan produk lain yang sesuai budget\n        if max_price:\n            budget_results = [\n                p for p in self.products\n                if p.get('price', 0) <= max_price\n            ]\n            if budget_results:\n                return budget_results[:limit], \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\n        # 6. Jika tetap tidak ada, tampilkan produk terpopuler/terlaris\n        popular_results = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n        return popular_results[:limit], \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\" ",
      "existing_test": "import pytest\nfrom unittest.mock import patch, mock_open, MagicMock, call\nimport logging\nimport json\nimport random\nfrom pathlib import Path\nimport sys\nimport builtins # Added for patching open\n\n# Add the parent directory of 'app' to the sys.path\n# This allows imports like 'from app.services.local_product_service import LocalProductService'\n# to work correctly when tests are run from a different root.\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom app.services.local_product_service import LocalProductService\n\n# Mock data for testing\n# MOCK_PRODUCTS_RAW_FOR_JSON represents the data structure *read from the JSON file*\nMOCK_PRODUCTS_RAW_FOR_JSON = [\n    {\n        \"id\": \"prod1\",\n        \"name\": \"Product A\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 100000,\n        \"currency\": \"IDR\",\n        \"description\": \"Description A. A very good product.\",\n        \"specifications\": {\"rating\": 4.5, \"sold\": 500, \"stock_count\": 100, \"extra_spec\": \"value1\"},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 10,\n        \"images\": [\"url_a.jpg\"],\n        \"url\": \"url_a\"\n    },\n    {\n        \"id\": \"prod2\",\n        \"name\": \"Product B\",\n        \"category\": \"Category2\",\n        \"brand\": \"BrandY\",\n        \"price\": 200000,\n        \"currency\": \"IDR\",\n        \"description\": \"Description B, also Product A related. A moderate product.\",\n        \"specifications\": {\"rating\": 3.8, \"sold\": 300, \"stock_count\": 50},\n        \"availability\": \"out_of_stock\",\n        \"reviews_count\": 5,\n        \"images\": [\"url_b.jpg\"],\n        \"url\": \"url_b\"\n    },\n    {\n        \"id\": \"prod3\",\n        \"name\": \"Product C\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 50000, # Cheapest product\n        \"currency\": \"IDR\",\n        \"description\": \"Cheapest product, high quality.\",\n        \"specifications\": {\"rating\": 4.9, \"sold\": 1200, \"stock_count\": 200}, # Highest rated\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 20,\n        \"images\": [\"url_c.jpg\"],\n        \"url\": \"url_c\"\n    },\n    {\n        \"id\": \"prod4\",\n        \"name\": \"Product D\",\n        \"category\": \"Category3\",\n        \"brand\": \"BrandZ\",\n        \"price\": 5000000, # 5 juta\n        \"currency\": \"IDR\",\n        \"description\": \"Expensive gadget. This is a very pricy item.\",\n        \"specifications\": {\"rating\": 4.0, \"sold\": 100, \"stock_count\": 10},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 2,\n        \"images\": [\"url_d.jpg\"],\n        \"url\": \"url_d\"\n    },\n    {\n        \"id\": \"prod5\",\n        \"name\": \"Product E (Best Seller)\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 150000,\n        \"currency\": \"IDR\",\n        \"description\": \"Best seller in Category1. Popular choice.\",\n        \"specifications\": {\"rating\": 4.6, \"sold\": 15000, \"stock_count\": 1000}, # Highest sold\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 150,\n        \"images\": [\"url_e.jpg\"],\n        \"url\": \"url_e\"\n    },\n    {\n        \"id\": \"prod6\",\n        \"name\": \"Product F (Budget)\",\n        \"category\": \"Category2\",\n        \"brand\": \"BrandY\",\n        \"price\": 4000000, # 4 juta\n        \"currency\": \"IDR\",\n        \"description\": \"A budget friendly product. Very affordable.\",\n        \"specifications\": {\"rating\": 3.0, \"sold\": 50, \"stock_count\": 20},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 1,\n        \"images\": [\"url_f.jpg\"],\n        \"url\": \"url_f\"\n    },\n    # Add a product with minimal fields to test defaults in transformation\n    {\n        \"id\": \"prod7\",\n        \"name\": \"Minimal Product\",\n        \"description\": \"This product has minimal details.\",\n    },\n    # Add a product with custom spec that should be merged\n    {\n        \"id\": \"prod8\",\n        \"name\": \"Custom Spec Product\",\n        \"category\": \"Electronics\",\n        \"price\": 750000,\n        \"specifications\": {\n            \"custom_field\": \"custom_value\",\n            \"rating\": 4.2,\n            \"stock_count\": 70,\n        },\n    }\n]\n\n# TRANSFORMED_MOCK_PRODUCTS_DATA represents the data structure *stored internally* by the service\n# after loading and applying transformations (e.g., random sold count, default fields).\n# The 'sold' count will be mocked to 1000 for deterministic tests in the fixture.\nTRANSFORMED_MOCK_PRODUCTS_DATA = [\n    {\n        \"id\": \"prod1\", \"name\": \"Product A\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 100000, \"currency\": \"IDR\", \"description\": \"Description A. A very good product.\",\n        \"specifications\": {\"rating\": 4.5, \"sold\": 1000, \"stock\": 100, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\", \"extra_spec\": \"value1\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 10, \"images\": [\"https://example.com/prod1.jpg\"], \"url\": \"https://shopee.co.id/prod1\"\n    },\n    {\n        \"id\": \"prod2\", \"name\": \"Product B\", \"category\": \"Category2\", \"brand\": \"BrandY\", \"price\": 200000, \"currency\": \"IDR\", \"description\": \"Description B, also Product A related. A moderate product.\",\n        \"specifications\": {\"rating\": 3.8, \"sold\": 1000, \"stock\": 50, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandY Store\"},\n        \"availability\": \"out_of_stock\", \"reviews_count\": 5, \"images\": [\"https://example.com/prod2.jpg\"], \"url\": \"https://shopee.co.id/prod2\"\n    },\n    {\n        \"id\": \"prod3\", \"name\": \"Product C\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 50000, \"currency\": \"IDR\", \"description\": \"Cheapest product, high quality.\",\n        \"specifications\": {\"rating\": 4.9, \"sold\": 1000, \"stock\": 200, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 20, \"images\": [\"https://example.com/prod3.jpg\"], \"url\": \"https://shopee.co.id/prod3\"\n    },\n    {\n        \"id\": \"prod4\", \"name\": \"Product D\", \"category\": \"Category3\", \"brand\": \"BrandZ\", \"price\": 5000000, \"currency\": \"IDR\", \"description\": \"Expensive gadget. This is a very pricy item.\",\n        \"specifications\": {\"rating\": 4.0, \"sold\": 1000, \"stock\": 10, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandZ Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 2, \"images\": [\"https://example.com/prod4.jpg\"], \"url\": \"https://shopee.co.id/prod4\"\n    },\n    {\n        \"id\": \"prod5\", \"name\": \"Product E (Best Seller)\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 150000, \"currency\": \"IDR\", \"description\": \"Best seller in Category1. Popular choice.\",\n        \"specifications\": {\"rating\": 4.6, \"sold\": 1000, \"stock\": 1000, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 150, \"images\": [\"https://example.com/prod5.jpg\"], \"url\": \"https://shopee.co.id/prod5\"\n    },\n    {\n        \"id\": \"prod6\", \"name\": \"Product F (Budget)\", \"category\": \"Category2\", \"brand\": \"BrandY\", \"price\": 4000000, \"currency\": \"IDR\", \"description\": \"A budget friendly product. Very affordable.\",\n        \"specifications\": {\"rating\": 3.0, \"sold\": 1000, \"stock\": 20, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandY Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 1, \"images\": [\"https://example.com/prod6.jpg\"], \"url\": \"https://shopee.co.id/prod6\"\n    },\n    {   # prod7 - minimal fields\n        \"id\": \"prod7\", \"name\": \"Minimal Product\", \"category\": \"\", \"brand\": \"\", \"price\": 0, \"currency\": \"IDR\", \"description\": \"This product has minimal details.\",\n        \"specifications\": {\"rating\": 0, \"sold\": 1000, \"stock\": 0, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"Unknown Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 0, \"images\": [\"https://example.com/prod7.jpg\"], \"url\": \"https://shopee.co.id/prod7\"\n    },\n    {   # prod8 - custom spec\n        \"id\": \"prod8\", \"name\": \"Custom Spec Product\", \"category\": \"Electronics\", \"brand\": \"\", \"price\": 750000, \"currency\": \"IDR\", \"description\": \"\",\n        \"specifications\": {\"rating\": 4.2, \"sold\": 1000, \"stock\": 70, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"Unknown Store\", \"custom_field\": \"custom_value\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 0, \"images\": [\"https://example.com/prod8.jpg\"], \"url\": \"https://shopee.co.id/prod8\"\n    }\n]\n\n\n@pytest.fixture\ndef mock_local_product_service_instance():\n    \"\"\"\n    Fixture to provide a LocalProductService instance with pre-defined mock products,\n    bypassing the file loading mechanism for most tests.\n    Also mocks random.randint for deterministic 'sold' values during transformation.\n    \"\"\"\n    with patch('random.randint', return_value=1000), \\\n         patch('app.services.local_product_service.LocalProductService._load_local_products',\n               return_value=TRANSFORMED_MOCK_PRODUCTS_DATA) as mock_load:\n        service = LocalProductService()\n        mock_load.assert_called_once() # Ensure init calls _load_local_products\n        yield service\n\n@pytest.fixture\ndef mock_logger():\n    \"\"\"Fixture to mock the logger to capture log messages.\"\"\"\n    with patch('app.services.local_product_service.logger') as mock_log:\n        yield mock_log\n\n# --- Tests for __init__ and _load_local_products ---\n\ndef test_init_success(mock_logger):\n    \"\"\"\n    Test that LocalProductService initializes successfully by loading products.\n    \"\"\"\n    # Mock _load_local_products to return a specific list\n    with patch('random.randint', return_value=1000), \\\n         patch('app.services.local_product_service.LocalProductService._load_local_products',\n               return_value=TRANSFORMED_MOCK_PRODUCTS_DATA) as mock_load:\n        service = LocalProductService()\n        mock_load.assert_called_once()\n        assert service.products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        mock_logger.info.assert_called_with(f\"Loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} local products from JSON file\")\n\ndef test_load_local_products_file_not_found(mock_logger):\n    \"\"\"\n    Test _load_local_products when the JSON file does not exist.\n    It should log an error and return fallback products.\n    \"\"\"\n    # Mock Path.exists to return False, and mock Path constructor to return a mock object\n    with patch('app.services.local_product_service.Path.exists', return_value=False), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback, \\\n         patch('app.services.local_product_service.Path') as MockPath:\n        \n        # Configure MockPath to simulate the file path construction\n        mock_file_path = MagicMock(spec=Path) # Use spec=Path to ensure Path methods exist\n        # This mocks the entire path construction: Path(__file__).parent.parent.parent / \"data\" / \"products.json\"\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n        \n        # Create an instance to call the internal method\n        service = LocalProductService() \n        result = service._load_local_products()\n        \n        mock_logger.error.assert_called_once()\n        assert \"Products JSON file not found at:\" in mock_logger.error.call_args[0][0]\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value # Ensure fallback products are returned\n\ndef test_load_local_products_valid_json_utf8(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid UTF-8 JSON file.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000): # Mock random.randint for predictable sold count\n        \n        # Simulate the Path resolution\n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        # Create an instance to call the internal method\n        service = LocalProductService() \n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        # Compare to the TRANSFORMED_MOCK_PRODUCTS_DATA\n        assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-8 encoding\")\n        \n        # Verify that open was called with utf-8 encoding (and potentially others if previous ones failed)\n        assert any(call.kwargs['encoding'] == 'utf-8' for call in builtins.open.call_args_list)\n\ndef test_load_local_products_valid_json_utf16le_with_bom(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid UTF-16-LE JSON file containing a BOM.\n    \"\"\"\n    mock_json_content_str = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n    \n    def open_side_effect(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        if encoding == 'utf-16-le':\n            # This simulates reading a file that *was* UTF-16-LE with BOM,\n            # and `file.read()` returns the decoded string (which still has the BOM char at start).\n            m_file.read.return_value = '\\ufeff' + mock_json_content_str\n        elif encoding == 'utf-16':\n            # Simulate a UnicodeDecodeError for utf-16 to ensure utf-16-le is tried first\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason for utf-16\")\n        else:\n            # For other encodings, return content that will cause JSONDecodeError\n            m_file.read.return_value = \"invalid json\"\n        return m_file\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect), \\\n         patch('random.randint', return_value=1000):\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        \n        # Verify open was called with 'utf-16-le' and succeeded, potentially other encodings failed before\n        assert builtins.open.call_args_list[0].kwargs['encoding'] == 'utf-16-le'\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-16-le encoding\")\n        mock_logger.warning.assert_not_called() # No warnings if first attempt succeeds\n\ndef test_load_local_products_invalid_json_all_encodings_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products when the JSON content is invalid for all encoding attempts.\n    It should log warnings and return fallback products.\n    \"\"\"\n    invalid_json_content = \"this is not json {\"\n    \n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Configure mock_open to always return invalid content, causing JSONDecodeError\n    def open_side_effect_invalid_json(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        m_file.read.return_value = invalid_json_content\n        return m_file\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect_invalid_json), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        # Check that warnings were logged for each encoding attempt\n        encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n        for encoding in encodings:\n            mock_logger.warning.assert_any_call(f\"Failed to load with {encoding} encoding: json.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\")\n        \n        mock_logger.error.assert_called_with(\"All encoding attempts failed, using fallback products\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n\ndef test_load_local_products_unicode_decode_error_all_encodings_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products when all encoding attempts result in UnicodeDecodeError.\n    It should log warnings and return fallback products.\n    \"\"\"\n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Create a mock for builtins.open that always raises UnicodeDecodeError\n    def mock_open_side_effect(file_path_arg, mode, encoding):\n        raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason\")\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=mock_open_side_effect), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        # Check that warnings were logged for each encoding attempt\n        encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n        for encoding in encodings:\n            mock_logger.warning.assert_any_call(f\"Failed to load with {encoding} encoding: mockcodec: mock reason\")\n        \n        mock_logger.error.assert_called_with(\"All encoding attempts failed, using fallback products\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n\ndef test_load_local_products_generic_exception(mock_logger):\n    \"\"\"\n    Test _load_local_products when a generic exception occurs (e.g., during file reading or JSON parsing).\n    It should log an error and return fallback products.\n    \"\"\"\n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=IOError(\"Mock IO Error\")), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        mock_logger.error.assert_called_with(\"Error loading products from JSON file: Mock IO Error\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n\ndef test_load_local_products_empty_products_list_in_json(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file but an empty 'products' list.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": []}) # Empty products list\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_json_missing_products_key(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file but missing the 'products' key.\n    \"\"\"\n    mock_json_content = json.dumps({\"some_other_key\": \"value\"}) # Missing 'products' key\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0 # Should fallback to empty list due to .get('products', [])\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_transformation_minimal_fields(mock_logger):\n    \"\"\"\n    Test _load_local_products transformation with a product having only minimal fields.\n    Ensures default values are correctly applied.\n    \"\"\"\n    minimal_product_raw = {\n        \"id\": \"minimal_prod\",\n        \"name\": \"Minimal Product\",\n        \"description\": \"This product has minimal details.\"\n    }\n    expected_transformed = {\n        \"id\": \"minimal_prod\",\n        \"name\": \"Minimal Product\",\n        \"category\": \"\",\n        \"brand\": \"\",\n        \"price\": 0,\n        \"currency\": \"IDR\",\n        \"description\": \"This product has minimal details.\",\n        \"specifications\": {\n            \"rating\": 0,\n            \"sold\": 1000, # Mocked random.randint value\n            \"stock\": 0,\n            \"condition\": \"Baru\",\n            \"shop_location\": \"Indonesia\",\n            \"shop_name\": \"Unknown Store\",\n        },\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 0,\n        \"images\": [\"https://example.com/minimal_prod.jpg\"],\n        \"url\": \"https://shopee.co.id/minimal_prod\"\n    }\n    mock_json_content = json.dumps({\"products\": [minimal_product_raw]})\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 1\n        assert products[0] == expected_transformed\n\ndef test_load_local_products_transformation_with_extra_spec_fields(mock_logger):\n    \"\"\"\n    Test _load_local_products transformation ensures extra fields in 'specifications' are preserved.\n    \"\"\"\n    product_with_custom_specs_raw = {\n        \"id\": \"custom_spec_prod\",\n        \"name\": \"Product with Custom Specs\",\n        \"specifications\": {\n            \"rating\": 4.2,\n            \"stock_count\": 70,\n            \"custom_field\": \"custom_value\",\n            \"another_custom\": True,\n        },\n        \"brand\": \"CustomBrand\"\n    }\n    expected_transformed_spec = {\n        \"rating\": 4.2,\n        \"sold\": 1000,\n        \"stock\": 70,\n        \"condition\": \"Baru\",\n        \"shop_location\": \"Indonesia\",\n        \"shop_name\": \"CustomBrand Store\",\n        \"custom_field\": \"custom_value\",\n        \"another_custom\": True,\n    }\n    mock_json_content = json.dumps({\"products\": [product_with_custom_specs_raw]})\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 1\n        assert products[0]['id'] == 'custom_spec_prod'\n        assert products[0]['specifications'] == expected_transformed_spec\n\ndef test_get_fallback_products(mock_logger):\n    \"\"\"\n    Test the _get_fallback_products method directly.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service._get_fallback_products()\n        \n        assert isinstance(products, list)\n        assert len(products) == 8 # Fallback products list should contain 8 items\n        assert \"iPhone 15 Pro Max\" in [p['name'] for p in products]\n        mock_logger.warning.assert_called_once_with(\"Using fallback products due to JSON file loading error\")\n\n# --- Tests for search_products and _extract_price_from_keyword ---\n\ndef test_search_products_basic_keyword_match(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a basic keyword matching product names/descriptions.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product a\")\n    assert len(results) == 2 # Product A and Product B (due to 'Product A related.')\n    assert results[0]['id'] == 'prod1' # Should be ranked higher due to exact name match\n\ndef test_search_products_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with case-insensitive keyword.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product b\")\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod2'\n\ndef test_search_products_no_match(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a keyword that doesn't match any product.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"nonexistent product\")\n    assert len(results) == 0\n\ndef test_search_products_with_limit(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a limit parameter.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product\", limit=1)\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod1' # First ranked product\n\ndef test_search_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product\", limit=0)\n    assert len(results) == 0\n\ndef test_search_products_keyword_in_category_brand_specs(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products finding keywords in category, brand, and specifications.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"BrandY\") # Product B, Product F\n    assert len(results) == 2\n    assert 'prod2' in [p['id'] for p in results]\n    assert 'prod6' in [p['id'] for p in results]\n    \n    results = service.search_products(\"Category3\") # Product D\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod4'\n\n    results = service.search_products(\"value1\") # Product A (extra_spec: value1)\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod1'\n\ndef test_search_products_price_extraction_juta(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"juta\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 1 juta\") # Should include products <= 1,000,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5', 'prod8'} # Product D, F are > 1 juta\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 1000000 for p in results)\n    # The sorting prioritizes exact keyword matches, then budget relevance if max_price is active.\n    # The order of products with same score is stable but not guaranteed based on attributes.\n    # We only assert presence and price criteria.\n\ndef test_search_products_price_extraction_ribu(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"ribu\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 200 ribu\") # Should include products <= 200,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 200000 for p in results)\n\ndef test_search_products_price_extraction_rp(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"Rp X\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product Rp 150000\")\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod3', 'prod5'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 150000 for p in results)\n\ndef test_search_products_price_extraction_budget_keyword(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a budget keyword (e.g., \"murah\").\n    The 'murah' keyword itself affects the relevance score by adding a price preference.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"gadget murah\") \n    # 'murah' corresponds to 5_000_000 max_price.\n    # All products have price <= 5M.\n    # Prod4 contains 'gadget'.\n    # Sorting by relevance: score based on keyword match + price preference.\n    # prod4 ('gadget' in desc) gets a boost + budget score.\n    # prod7 (price 0) gets a very high budget score.\n    # prod3 (price 50k) gets a high budget score.\n    \n    # We expect 'prod4' (gadget match) and 'prod7', 'prod3' (cheapest) to be among top results.\n    # Exact ordering can depend on tie-breaking in sort, so we check for presence among top.\n    \n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod4', 'prod5', 'prod6', 'prod7', 'prod8'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 5000000 for p in results)\n\n    # Specific check for top elements to reflect sorting by relevance\n    # Prod4 has keyword \"gadget\" and is within budget.\n    # Prod7 and Prod3 are very cheap.\n    top_ids = {p['id'] for p in results[:3]}\n    assert 'prod4' in top_ids\n    assert 'prod7' in top_ids\n    assert 'prod3' in top_ids\n\ndef test_search_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in search_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Simulate an error by modifying products list to cause an exception during iteration or access\n    with patch.object(service, 'products', new=[{'id': 'bad_data', 'price': 'invalid'}]):\n        results = service.search_products(\"test\")\n        assert results == []\n        mock_logger.error.assert_called_once()\n        assert \"Error searching products:\" in mock_logger.error.call_args[0][0]\n\ndef test_extract_price_from_keyword_juta():\n    service = LocalProductService() # No need for mocked products for this method\n    assert service._extract_price_from_keyword(\"harga 2 juta\") == 2000000\n    assert service._extract_price_from_keyword(\"10 juta\") == 10000000\n    assert service._extract_price_from_keyword(\"5.5 juta\") is None # Only integer part extracted by regex\n    assert service._extract_price_from_keyword(\"2Juta\") == 2000000 # Case insensitive\n\ndef test_extract_price_from_keyword_ribu():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"maksimal 500 ribu\") == 500000\n    assert service._extract_price_from_keyword(\"Rp 100 ribu\") == 100000\n    assert service._extract_price_from_keyword(\"250Ribu\") == 250000 # Case insensitive\n\ndef test_extract_price_from_keyword_rp():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"rp 250000\") == 250000\n    assert service._extract_price_from_keyword(\"150000 rp\") == 150000\n    assert service._extract_price_from_keyword(\"RP. 500000\") == 500000 # Test with dot and different casing\n\ndef test_extract_price_from_keyword_k_m():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"300k\") == 300000\n    assert service._extract_price_from_keyword(\"5m\") == 5000000\n    assert service._extract_price_from_keyword(\"2.5m\") is None # Only integer part extracted by regex\n    assert service._extract_price_from_keyword(\"10K\") == 10000 # Case insensitive\n\ndef test_extract_price_from_keyword_budget_keywords():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"hp murah\") == 5000000\n    assert service._extract_price_from_keyword(\"laptop budget\") == 5000000\n    assert service._extract_price_from_keyword(\"headset hemat\") == 3000000\n    assert service._extract_price_from_keyword(\"monitor terjangkau\") == 4000000\n    assert service._extract_price_from_keyword(\"mouse ekonomis\") == 2000000\n    assert service._extract_price_from_keyword(\"Harga Murah Banget\") == 5000000 # Multiple words\n\ndef test_extract_price_from_keyword_no_match():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"no price here\") is None\n    assert service._extract_price_from_keyword(\"just a keyword\") is None\n    assert service._extract_price_from_keyword(\"10 dolar\") is None # Unrecognized currency\n\ndef test_extract_price_from_keyword_multiple_patterns_first_match_wins():\n    service = LocalProductService()\n    # \"1 juta\" comes first in regex patterns than \"murah\" keyword.\n    assert service._extract_price_from_keyword(\"laptop 1 juta murah\") == 1000000\n    # \"500 ribu\" is parsed by regex before \"hemat\" keyword.\n    assert service._extract_price_from_keyword(\"mouse 500 ribu hemat\") == 500000\n    # \"rp 20000\" should match before \"murah\"\n    assert service._extract_price_from_keyword(\"hp rp 20000 murah\") == 20000\n\ndef test_extract_price_from_keyword_error_handling(mock_logger):\n    service = LocalProductService()\n    with patch('re.search', side_effect=Exception(\"Regex error\")):\n        assert service._extract_price_from_keyword(\"1 juta\") is None\n        mock_logger.error.assert_called_once()\n        assert \"Error extracting price from keyword:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for get_product_details, get_categories, get_brands ---\n\ndef test_get_product_details_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving details for an existing product ID.\n    \"\"\"\n    service = mock_local_product_service_instance\n    product = service.get_product_details(\"prod1\")\n    assert product is not None\n    assert product['id'] == 'prod1'\n    assert product['name'] == 'Product A'\n\ndef test_get_product_details_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving details for a non-existent product ID.\n    \"\"\"\n    service = mock_local_product_service_instance\n    product = service.get_product_details(\"nonexistent_id\")\n    assert product is None\n\ndef test_get_product_details_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_product_details when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        product = service.get_product_details(\"prod1\")\n        assert product is None\n        mock_logger.error.assert_not_called() # No error should be logged\n\ndef test_get_product_details_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_product_details.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Simulate an error by making products attribute raise an exception on access\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        product = service.get_product_details(\"prod1\")\n        assert product is None\n        mock_logger.error.assert_called_once()\n        assert \"Error getting product details:\" in mock_logger.error.call_args[0][0]\n\n\ndef test_get_categories(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving unique product categories.\n    \"\"\"\n    service = mock_local_product_service_instance\n    categories = service.get_categories()\n    assert sorted(categories) == sorted(['Category1', 'Category2', 'Category3', 'Electronics', '']) # '' for prod7, prod8 missing category\n\ndef test_get_categories_empty_products_list():\n    \"\"\"\n    Test get_categories when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        categories = service.get_categories()\n        assert categories == []\n\ndef test_get_categories_with_missing_category_key():\n    \"\"\"\n    Test get_categories when some products are missing the 'category' key.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    products_with_missing_cat = [\n        {\"id\": \"1\", \"name\": \"ProdA\", \"category\": \"Cat1\"},\n        {\"id\": \"2\", \"name\": \"ProdB\"}, # Missing category\n        {\"id\": \"3\", \"name\": \"ProdC\", \"category\": \"Cat2\"},\n    ]\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_cat):\n        service = LocalProductService()\n        categories = service.get_categories()\n        # An empty string is added if 'category' is missing, then sorted\n        assert sorted(categories) == ['', 'Cat1', 'Cat2']\n\ndef test_get_brands(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving unique product brands.\n    \"\"\"\n    service = mock_local_product_service_instance\n    brands = service.get_brands()\n    assert sorted(brands) == sorted(['BrandX', 'BrandY', 'BrandZ', '']) # '' for prod7, prod8 missing brand\n\ndef test_get_brands_empty_products_list():\n    \"\"\"\n    Test get_brands when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        brands = service.get_brands()\n        assert brands == []\n\ndef test_get_brands_with_missing_brand_key():\n    \"\"\"\n    Test get_brands when some products are missing the 'brand' key.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    products_with_missing_brand = [\n        {\"id\": \"1\", \"name\": \"ProdA\", \"brand\": \"Brand1\"},\n        {\"id\": \"2\", \"name\": \"ProdB\"}, # Missing brand\n        {\"id\": \"3\", \"name\": \"ProdC\", \"brand\": \"Brand2\"},\n    ]\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_brand):\n        service = LocalProductService()\n        brands = service.get_brands()\n        # An empty string is added if 'brand' is missing, then sorted\n        assert sorted(brands) == ['', 'Brand1', 'Brand2']\n\n# --- Tests for get_products_by_category/brand ---\n\ndef test_get_products_by_category_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by an existing category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"Category1\")\n    assert len(products) == 3\n    assert all(p['category'] == 'Category1' for p in products)\n    assert {'prod1', 'prod3', 'prod5'} == {p['id'] for p in products}\n\ndef test_get_products_by_category_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by category with case-insensitivity.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"category1\")\n    assert len(products) == 3\n    assert all(p['category'] == 'Category1' for p in products)\n\ndef test_get_products_by_category_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by a non-existent category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"NonExistentCategory\")\n    assert products == []\n\ndef test_get_products_by_category_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products_by_category when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products_by_category(\"Category1\")\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_by_category_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products_by_category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        products = service.get_products_by_category(\"Category1\")\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products by category:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_products_by_brand_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by an existing brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"BrandX\")\n    assert len(products) == 3\n    assert all(p['brand'] == 'BrandX' for p in products)\n    assert {'prod1', 'prod3', 'prod5'} == {p['id'] for p in products}\n\ndef test_get_products_by_brand_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by brand with case-insensitivity.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"brandx\")\n    assert len(products) == 3\n    assert all(p['brand'] == 'BrandX' for p in products)\n\ndef test_get_products_by_brand_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by a non-existent brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"NonExistentBrand\")\n    assert products == []\n\ndef test_get_products_by_brand_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products_by_brand when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products_by_brand(\"BrandX\")\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_by_brand_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products_by_brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        products = service.get_products_by_brand(\"BrandX\")\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products by brand:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for get_top_rated_products, get_best_selling_products, get_products ---\n\ndef test_get_top_rated_products(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving top-rated products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=3)\n    assert len(products) == 3\n    # Based on TRANSFORMED_MOCK_PRODUCTS_DATA ratings:\n    # prod3 (4.9), prod5 (4.6), prod1 (4.5), prod8 (4.2), prod4 (4.0), prod2 (3.8), prod6 (3.0), prod7 (0)\n    assert products[0]['id'] == 'prod3'\n    assert products[1]['id'] == 'prod5'\n    assert products[2]['id'] == 'prod1'\n\ndef test_get_top_rated_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_top_rated_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    # Still sorted by rating\n    assert products[0]['id'] == 'prod3'\n\ndef test_get_top_rated_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test get_top_rated_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=0)\n    assert len(products) == 0\n\ndef test_get_top_rated_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_top_rated_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_top_rated_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_top_rated_products_with_missing_rating_key():\n    \"\"\"\n    Test get_top_rated_products when some products are missing the 'rating' key.\n    \"\"\"\n    products_with_missing_rating = [\n        {\"id\": \"1\", \"specifications\": {\"rating\": 5.0}},\n        {\"id\": \"2\", \"specifications\": {}}, # Missing rating (defaults to 0)\n        {\"id\": \"3\", \"specifications\": {\"rating\": 4.0}},\n        {\"id\": \"4\"}, # Missing 'specifications' dict entirely (defaults to 0 rating)\n    ]\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_rating):\n        service = LocalProductService()\n        products = service.get_top_rated_products(limit=3)\n        assert len(products) == 3\n        # Products with missing rating should default to 0 and be at the bottom\n        assert products[0]['id'] == '1' # Rating 5.0\n        assert products[1]['id'] == '3' # Rating 4.0\n        # The third product should be either '2' or '4' (both have 0 rating). Order depends on stable sort.\n        assert products[2]['id'] in {'2', '4'}\n\ndef test_get_top_rated_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_top_rated_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"Sorting error\"))):\n        products = service.get_top_rated_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting top rated products:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_best_selling_products(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test retrieving best-selling products.\n    Since `random.randint` is mocked in the fixture, all products in `service.products`\n    will have a 'sold' count of 1000. To properly test sorting by 'sold' for\n    `get_best_selling_products`, we temporarily override `service.products` with\n    a list where 'sold' values are varied.\n    \"\"\"\n    products_for_sold_test = [\n        dict(p, specifications=dict(p['specifications'], sold=p['specifications'].get('sold', 0)))\n        for p in TRANSFORMED_MOCK_PRODUCTS_DATA # Start with base transformed data\n    ]\n    # Manually adjust 'sold' values for deterministic testing of sorting by 'sold'\n    for p in products_for_sold_test:\n        if p['id'] == 'prod5': p['specifications']['sold'] = 15000 # Highest\n        elif p['id'] == 'prod3': p['specifications']['sold'] = 1200 # Second highest\n        elif p['id'] == 'prod1': p['specifications']['sold'] = 500 # Third highest\n        elif p['id'] == 'prod2': p['specifications']['sold'] = 300\n        elif p['id'] == 'prod4': p['specifications']['sold'] = 100\n        elif p['id'] == 'prod6': p['specifications']['sold'] = 50\n        elif p['id'] == 'prod7': p['specifications']['sold'] = 10 # Lowest\n        elif p['id'] == 'prod8': p['specifications']['sold'] = 200 # In between\n\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', products_for_sold_test):\n        products = service.get_best_selling_products(limit=3)\n        assert len(products) == 3\n        # Expected order based on adjusted sold counts\n        assert products[0]['id'] == 'prod5' # sold=15000\n        assert products[1]['id'] == 'prod3' # sold=1200\n        assert products[2]['id'] == 'prod1' # sold=500\n        mock_logger.info.assert_any_call(\"Getting best selling products, limit: 3\")\n        mock_logger.info.assert_any_call(\"Returning 3 best selling products\")\n\ndef test_get_best_selling_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_best_selling_products when limit is greater than available products.\n    \"\"\"\n    products_for_sold_test = [\n        dict(p, specifications=dict(p['specifications'], sold=p['specifications'].get('sold', 0)))\n        for p in TRANSFORMED_MOCK_PRODUCTS_DATA\n    ]\n    for p in products_for_sold_test:\n        if p['id'] == 'prod5': p['specifications']['sold'] = 15000\n        elif p['id'] == 'prod3': p['specifications']['sold'] = 1200\n        elif p['id'] == 'prod1': p['specifications']['sold'] = 500\n        elif p['id'] == 'prod2': p['specifications']['sold'] = 300\n        elif p['id'] == 'prod4': p['specifications']['sold'] = 100\n        elif p['id'] == 'prod6': p['specifications']['sold'] = 50\n        elif p['id'] == 'prod7': p['specifications']['sold'] = 10\n        elif p['id'] == 'prod8': p['specifications']['sold'] = 200\n\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', products_for_sold_test):\n        products = service.get_best_selling_products(limit=100)\n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        # Still sorted by sold count\n        assert products[0]['id'] == 'prod5'\n\ndef test_get_best_selling_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test get_best_selling_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_best_selling_products(limit=0)\n    assert len(products) == 0\n\ndef test_get_best_selling_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_best_selling_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_best_selling_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_best_selling_products_with_missing_sold_key():\n    \"\"\"\n    Test get_best_selling_products when some products are missing the 'sold' key.\n    \"\"\"\n    products_with_missing_sold = [\n        {\"id\": \"1\", \"specifications\": {\"sold\": 1000}},\n        {\"id\": \"2\", \"specifications\": {}}, # Missing sold (defaults to 0)\n        {\"id\": \"3\", \"specifications\": {\"sold\": 500}},\n        {\"id\": \"4\"}, # Missing 'specifications' dict entirely (defaults to 0 sold)\n    ]\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_sold):\n        service = LocalProductService()\n        products = service.get_best_selling_products(limit=3)\n        assert len(products) == 3\n        # Products with missing sold should default to 0 and be at the bottom\n        assert products[0]['id'] == '1' # Sold 1000\n        assert products[1]['id'] == '3' # Sold 500\n        # The third product should be either '2' or '4' (both have 0 sold). Order depends on stable sort.\n        assert products[2]['id'] in {'2', '4'}\n\ndef test_get_best_selling_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_best_selling_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"Sorting error\"))):\n        products = service.get_best_selling_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting best selling products:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_products(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test retrieving all products with a limit.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=3)\n    assert len(products) == 3\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA[:3]\n    mock_logger.info.assert_any_call(\"Getting all products, limit: 3\")\n\ndef test_get_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n\ndef test_get_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test get_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=0)\n    assert len(products) == 0\n\ndef test_get_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List slicing error\"))):\n        products = service.get_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for smart_search_products ---\n\ndef test_smart_search_products_best_request_general(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for general \"terbaik\" request.\n    Should return top-rated products overall.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik\", limit=2)\n    assert len(products) == 2\n    # Based on TRANSFORMED_MOCK_PRODUCTS_DATA ratings: prod3 (4.9), prod5 (4.6)\n    assert products[0]['id'] == 'prod3' \n    assert products[1]['id'] == 'prod5' \n    assert message == \"Berikut produk terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_best_request_specific_category_found(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for \"terbaik\" request within a specific category that exists.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik Category1\", category=\"Category1\", limit=2)\n    assert len(products) == 2\n    # Products in Category1: prod1 (4.5), prod3 (4.9), prod5 (4.6)\n    assert products[0]['id'] == 'prod3' \n    assert products[1]['id'] == 'prod5' \n    assert message == \"Berikut Category1 terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_best_request_specific_category_not_found_fallback(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for \"terbaik\" request within a non-existent category.\n    Should fallback to general top-rated products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik NonExistent\", category=\"NonExistent\", limit=2)\n    assert len(products) == 2\n    assert products[0]['id'] == 'prod3' # Rating 4.9 (general best)\n    assert products[1]['id'] == 'prod5' # Rating 4.6 (general best)\n    assert message == \"Tidak ada produk kategori NonExistent, berikut produk terbaik secara umum:\"\n\ndef test_smart_search_products_all_criteria_match(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products where keyword, category, and max_price all match.\n    The primary search path should be taken.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"Product A\", category=\"Category1\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Products matching: prod1 (100k, Category1), prod5 (150k, Category1)\n    # The internal search algorithm will filter first, then sort by relevance.\n    # Keyword \"Product A\" matches prod1. Desc of prod2 also has \"Product A related\"\n    # But only prod1 and prod5 are in Category1 and <= 150k.\n    expected_ids = {'prod1', 'prod5'}\n    actual_ids = {p['id'] for p in products}\n    assert actual_ids == expected_ids\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_no_exact_match_fallback_to_category(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when initial search has no results, but category match is found.\n    Should sort by price within category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # \"NonExistingKeyword\" will not match, but \"Category2\" will. Max_price too low for initial match.\n    products, message = service.smart_search_products(keyword=\"NonExistingKeyword\", category=\"Category2\", max_price=50000, limit=2)\n    assert len(products) == 2\n    # Products in Category2: prod2 (200k), prod6 (4M). Sorted by price: prod2, prod6\n    assert products[0]['id'] == 'prod2' # Cheapest in Category2\n    assert products[1]['id'] == 'prod6' # Next cheapest in Category2\n    assert message == \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\ndef test_smart_search_products_no_category_match_fallback_to_budget(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when no exact match and no category match, but budget match is found.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # \"NonExistingKeyword\" and \"NonExistingCategory\" won't match. max_price will.\n    products, message = service.smart_search_products(keyword=\"NonExistingKeyword\", category=\"NonExistingCategory\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Products within 150k: prod1 (100k), prod3 (50k), prod5 (150k), prod7 (0k)\n    expected_ids_candidates = {'prod1', 'prod3', 'prod5', 'prod7'}\n    actual_ids = {p['id'] for p in products}\n    assert actual_ids.issubset(expected_ids_candidates) and len(actual_ids) == 2\n    assert message == \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\ndef test_smart_search_products_no_match_all_fallbacks_popular(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when no criteria match and all fallbacks lead to no results,\n    should return popular products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Max price 10 will ensure no products match price criteria, and no keywords/categories match.\n    # To test best-selling correctly, we need to inject products with varied 'sold' counts.\n    products_for_sold_test = [\n        dict(p, specifications=dict(p['specifications'], sold=p['specifications'].get('sold', 0)))\n        for p in TRANSFORMED_MOCK_PRODUCTS_DATA\n    ]\n    for p in products_for_sold_test:\n        if p['id'] == 'prod5': p['specifications']['sold'] = 15000\n        elif p['id'] == 'prod3': p['specifications']['sold'] = 1200\n        elif p['id'] == 'prod1': p['specifications']['sold'] = 500\n        elif p['id'] == 'prod2': p['specifications']['sold'] = 300\n        elif p['id'] == 'prod4': p['specifications']['sold'] = 100\n        elif p['id'] == 'prod6': p['specifications']['sold'] = 50\n        elif p['id'] == 'prod7': p['specifications']['sold'] = 10\n        elif p['id'] == 'prod8': p['specifications']['sold'] = 200\n\n    with patch.object(service, 'products', products_for_sold_test):\n        products, message = service.smart_search_products(keyword=\"CompletelyUniqueKeyword\", category=\"UnknownCategory\", max_price=10, limit=2)\n        assert len(products) == 2\n        assert products[0]['id'] == 'prod5' # sold=15000\n        assert products[1]['id'] == 'prod3' # sold=1200\n        assert message == \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\"\n\ndef test_smart_search_products_empty_keyword_only_category(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with empty keyword, only category specified.\n    Should go to the primary search path and filter by category, then return message.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", category=\"Category1\", limit=2)\n    assert len(products) == 2\n    # Should find all products in Category1, limit 2. These are prod1, prod3, prod5.\n    # The actual order might vary based on default sorting if keyword isn't active.\n    # Let's check presence:\n    expected_ids = {'prod1', 'prod3', 'prod5'}\n    actual_ids = {p['id'] for p in products}\n    assert actual_ids.issubset(expected_ids) and len(actual_ids) == 2\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_empty_keyword_only_max_price(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with empty keyword, only max_price specified.\n    Should go to primary search path and filter by price.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Should find products <= 150k: prod1, prod3, prod5, prod7\n    expected_ids = {'prod1', 'prod3', 'prod5', 'prod7'}\n    actual_ids = {p['id'] for p in products}\n    assert actual_ids.issubset(expected_ids) and len(actual_ids) == 2\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_empty_all_filters(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with no filters (empty keyword, no category, no max_price).\n    Should default to returning the first `limit` products from the loaded list (primary path).\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", category=None, max_price=None, limit=2)\n    assert len(products) == 2\n    # Should return first `limit` products as all products match empty criteria.\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA[:2]\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"Product\", limit=0)\n    assert len(products) == 0\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n    products, message = service.smart_search_products(keyword=\"terbaik\", limit=0)\n    assert len(products) == 0\n    assert message == \"Berikut produk terbaik berdasarkan rating:\"\n\n# Add test for 'smart_search_products' error handling if needed, though most logic is guarded by filters.\n# The primary filter for smart_search_products is a list comprehension which is usually safe.\n# If `self.products` causes an error, it would be caught by the fixture's init or `_load_local_products` tests."
    }
  ]
}