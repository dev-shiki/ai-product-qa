{
  "timestamp": "/home/runner/work/ai-product-qa/ai-product-qa",
  "total_files": 17,
  "coverage_data": {
    ".": 0.0,
    "main.py": 0.0,
    "api": 0.0,
    "api/__init__.py": 100.0,
    "api/products.py": 0.0,
    "api/queries.py": 0.0,
    "models": 100.0,
    "models/__init__.py": 100.0,
    "models/product.py": 100.0,
    "services": 12.58,
    "services/__init__.py": 100.0,
    "services/ai_service.py": 4.839,
    "services/local_product_service.py": 11.540000000000001,
    "services/product_data_service.py": 20.73,
    "utils": 86.36,
    "utils/__init__.py": 100.0,
    "utils/config.py": 86.36
  },
  "lowest_coverage_files": [
    {
      "filepath": "app/services/ai_service.py",
      "coverage": 4.839,
      "content": "import logging\nfrom google import genai\nfrom app.utils.config import get_settings\nfrom app.services.product_data_service import ProductDataService\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass AIService:\n    def __init__(self):\n        \"\"\"Initialize AI service with Google AI API\"\"\"\n        try:\n            settings = get_settings()\n            # Use the new Google AI client\n            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)\n            self.product_service = ProductDataService()\n            logger.info(\"Successfully initialized AI service with Google AI client\")\n        except Exception as e:\n            logger.error(f\"Error initializing AI service: {str(e)}\")\n            raise\n\n    async def get_response(self, question: str) -> str:\n        \"\"\"Get AI response with product context and fallback message\"\"\"\n        try:\n            logger.info(f\"Getting AI response for question: {question}\")\n\n            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)\n            import re\n            category = None\n            max_price = None\n            \n            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)\n            question_lower = question.lower()\n            category_mapping = {\n                'laptop': ['laptop', 'notebook', 'komputer'],\n                'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],\n                'tablet': ['tablet', 'ipad'],\n                'headphone': ['headphone', 'earphone', 'headset', 'audio'],\n                'kamera': ['kamera', 'camera', 'fotografi'],\n                'audio': ['audio', 'speaker', 'sound'],\n                'tv': ['tv', 'televisi'],\n                'drone': ['drone', 'quadcopter'],\n                'jam': ['jam', 'watch', 'smartwatch']\n            }\n            \n            for cat, keywords in category_mapping.items():\n                if any(keyword in question_lower for keyword in keywords):\n                    category = cat\n                    break\n            \n            # Deteksi budget\n            price_match = re.search(r'(\\d+)\\s*juta', question_lower)\n            if price_match:\n                max_price = int(price_match.group(1)) * 1000000\n            elif 'budget' in question_lower or 'murah' in question_lower:\n                max_price = 5000000\n\n            # Gunakan smart_search_products\n            products, fallback_message = await self.product_service.smart_search_products(\n                keyword=question, category=category, max_price=max_price, limit=5\n            )\n\n            # Build context\n            context = f\"Question: {question}\\n\\n\"\n            context += f\"{fallback_message}\\n\\n\"\n            if products:\n                context += \"Relevant Products:\\n\"\n                for i, product in enumerate(products, 1):\n                    context += f\"{i}. {product.get('name', 'Unknown')}\\n\"\n                    context += f\"   Price: Rp {product.get('price', 0):,.0f}\\n\"\n                    context += f\"   Brand: {product.get('brand', 'Unknown')}\\n\"\n                    context += f\"   Category: {product.get('category', 'Unknown')}\\n\"\n                    context += f\"   Rating: {product.get('specifications', {}).get('rating', 0)}/5\\n\"\n                    context += f\"   Description: {product.get('description', 'No description')[:200]}...\\n\\n\"\n            else:\n                context += \"No specific products found, but I can provide general recommendations.\\n\\n\"\n\n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\\n\\n{context}\\n\\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision. Focus on being helpful and natural in your response.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n        \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            return \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n\n    def generate_response(self, context: str) -> str:\n        \"\"\"Generate response using Google AI (legacy method)\"\"\"\n        try:\n            logger.info(\"Generating AI response\")\n            \n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.0-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n            \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            raise ",
      "existing_test": "import pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nimport logging\nimport sys\nimport os\n\n# Adjusting sys.path to allow imports from the 'app' directory\n# This is crucial for pytest to find modules when running from the project root\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))\n\nfrom app.services.ai_service import AIService\nfrom app.utils.config import Settings # Assuming Settings class is defined in app.utils.config\n\n# --- Fixtures ---\n\n@pytest.fixture\ndef mock_settings():\n    \"\"\"Mocks the get_settings function to return a mock Settings object.\"\"\"\n    settings = Mock(spec=Settings)\n    settings.GOOGLE_API_KEY = \"test_api_key_123\"\n    return settings\n\n@pytest.fixture\ndef mock_genai_client():\n    \"\"\"\n    Mocks the google.genai.Client instance and its `models.generate_content` method.\n    The `generate_content` method is configured as an AsyncMock for `get_response` (awaited)\n    and also to allow direct `.text` attribute access for `generate_response` (not awaited).\n    \"\"\"\n    mock_client = Mock()\n    mock_client.models = Mock() # Ensure models attribute exists\n    \n    # Configure the return value for the awaited call in get_response\n    mock_generate_content_result_awaited = Mock()\n    mock_generate_content_result_awaited.text = \"Mocked AI response text for awaited call.\"\n    \n    # Create an AsyncMock instance for models.generate_content\n    # Its `return_value` is what `await` will yield.\n    mock_genai_method = AsyncMock(return_value=mock_generate_content_result_awaited)\n    \n    # Additionally, set a `.text` attribute directly on the AsyncMock instance itself.\n    # This caters to the synchronous `generate_response` method which accesses `.text`\n    # directly on the object returned by `generate_content` (since it's not awaited there).\n    mock_genai_method.text = \"Mocked AI response text for sync access.\"\n\n    mock_client.models.generate_content = mock_genai_method\n    return mock_client\n\n@pytest.fixture\ndef mock_product_data_service():\n    \"\"\"Mocks the ProductDataService instance.\"\"\"\n    mock_service = Mock()\n    mock_service.smart_search_products = AsyncMock() # smart_search_products is an async method\n    # Default return for product search: no products and a generic fallback\n    mock_service.smart_search_products.return_value = ([], \"No specific products found.\")\n    return mock_service\n\n@pytest.fixture\ndef ai_service_instance(mock_settings, mock_genai_client, mock_product_data_service):\n    \"\"\"\n    Provides an AIService instance with its dependencies (settings, genai client,\n    and product service) mocked. This fixture ensures that the patched dependencies\n    are correctly used during AIService instantiation.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', return_value=mock_genai_client), \\\n         patch('app.services.product_data_service.ProductDataService', return_value=mock_product_data_service):\n        service = AIService()\n        yield service # Use yield to allow for potential cleanup or specific patching in tests\n\n# --- Tests for AIService Initialization (__init__) ---\n\ndef test_aiservice_init_success(ai_service_instance, mock_genai_client, mock_product_data_service, caplog):\n    \"\"\"\n    Tests successful initialization of AIService.\n    Verifies that client and product_service are set to the mocked instances\n    and an informational log message is emitted.\n    \"\"\"\n    with caplog.at_level(logging.INFO):\n        assert isinstance(ai_service_instance.client, Mock)\n        assert ai_service_instance.client == mock_genai_client\n        assert isinstance(ai_service_instance.product_service, Mock)\n        assert ai_service_instance.product_service == mock_product_data_service\n        assert \"Successfully initialized AI service with Google AI client\" in caplog.text\n\ndef test_aiservice_init_get_settings_failure(caplog):\n    \"\"\"\n    Tests AIService initialization failure when get_settings raises an exception.\n    Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', side_effect=Exception(\"Config error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Config error\"):\n            AIService()\n        assert \"Error initializing AI service: Config error\" in caplog.text\n\ndef test_aiservice_init_genai_client_failure(mock_settings, caplog):\n    \"\"\"\n    Tests AIService initialization failure when google.genai.Client constructor\n    raises an exception. Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', side_effect=Exception(\"Client init error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Client init error\"):\n            AIService()\n        assert \"Error initializing AI service: Client init error\" in caplog.text\n\ndef test_aiservice_init_product_service_failure(mock_settings, mock_genai_client, caplog):\n    \"\"\"\n    Tests AIService initialization failure when ProductDataService constructor\n    raises an exception. Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', return_value=mock_genai_client), \\\n         patch('app.services.product_data_service.ProductDataService', side_effect=Exception(\"Product service init error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Product service init error\"):\n            AIService()\n        assert \"Error initializing AI service: Product service init error\" in caplog.text\n\n\n# --- Tests for get_response method (async) ---\n\n@pytest.mark.asyncio\nasync def test_get_response_success_with_products(ai_service_instance, mock_product_data_service, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when product search returns relevant products.\n    Verifies correct context building with product details and successful AI response generation.\n    \"\"\"\n    question = \"Cari laptop gaming di bawah 10 juta\"\n    mock_products = [\n        {\"name\": \"Awesome Laptop\", \"price\": 9500000, \"brand\": \"BrandX\", \"category\": \"laptop\", \"specifications\": {\"rating\": 4.5}, \"description\": \"High performance gaming laptop for pros.\"},\n        {\"name\": \"Budget Laptop\", \"price\": 7000000, \"brand\": \"BrandY\", \"category\": \"laptop\", \"specifications\": {\"rating\": 4.0}, \"description\": \"Affordable gaming laptop for casual gamers who want value.\"}\n    ]\n    mock_fallback_message = \"Found some great laptops for you!\"\n\n    mock_product_data_service.smart_search_products.return_value = (mock_products, mock_fallback_message)\n    mock_genai_client.models.generate_content.return_value.text = \"Based on your interest, Awesome Laptop and Budget Laptop are good options.\"\n\n    with caplog.at_level(logging.INFO):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Based on your interest, Awesome Laptop and Budget Laptop are good options.\"\n        mock_product_data_service.smart_search_products.assert_called_once_with(\n            keyword=question, category=\"laptop\", max_price=10000000, limit=5\n        )\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        prompt = call_args[0]['contents']\n\n        assert \"Question: Cari laptop gaming di bawah 10 juta\" in prompt\n        assert \"Found some great laptops for you!\" in prompt\n        assert \"Relevant Products:\" in prompt\n        assert \"1. Awesome Laptop\" in prompt\n        assert \"Price: Rp 9,500,000\" in prompt\n        assert \"Brand: BrandX\" in prompt\n        assert \"Category: laptop\" in prompt\n        assert \"Rating: 4.5/5\" in prompt\n        assert \"Description: High performance gaming laptop for pros.\"[:200] + \"...\" in prompt # Checks truncation\n        assert \"2. Budget Laptop\" in prompt\n        assert \"Successfully generated AI response\" in caplog.text\n        assert call_args[0]['model'] == \"gemini-2.5-flash\"\n\n@pytest.mark.asyncio\nasync def test_get_response_success_no_products(ai_service_instance, mock_product_data_service, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when product search returns no relevant products.\n    Verifies correct context building (without products) and successful AI response.\n    \"\"\"\n    question = \"Can you recommend a very specific item I just made up?\"\n    mock_product_data_service.smart_search_products.return_value = ([], \"Could not find products matching your exact query.\")\n    mock_genai_client.models.generate_content.return_value.text = \"I'm sorry, I couldn't find specific products for that. Can I help with general info?\"\n\n    with caplog.at_level(logging.INFO):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"I'm sorry, I couldn't find specific products for that. Can I help with general info?\"\n        mock_product_data_service.smart_search_products.assert_called_once_with(\n            keyword=question, category=None, max_price=None, limit=5\n        )\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        prompt = call_args[0]['contents']\n\n        assert \"Question: Can you recommend a very specific item I just made up?\" in prompt\n        assert \"Could not find products matching your exact query.\" in prompt\n        assert \"No specific products found, but I can provide general recommendations.\" in prompt\n        assert \"Relevant Products:\" not in prompt # Ensure this section is not present\n        assert \"Successfully generated AI response\" in caplog.text\n        assert call_args[0]['model'] == \"gemini-2.5-flash\"\n\n@pytest.mark.asyncio\nasync def test_get_response_ai_generation_failure(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when the AI client fails to generate a response.\n    Verifies that a friendly fallback message is returned and an error is logged.\n    \"\"\"\n    question = \"Tell me something.\"\n    mock_genai_client.models.generate_content.side_effect = Exception(\"AI API error\")\n\n    with caplog.at_level(logging.ERROR):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n        mock_genai_client.models.generate_content.assert_called_once()\n        assert \"Error generating AI response: AI API error\" in caplog.text\n\n@pytest.mark.asyncio\nasync def test_get_response_product_data_service_failure(ai_service_instance, mock_product_data_service, caplog):\n    \"\"\"\n    Tests get_response when the product data service fails.\n    Verifies that a friendly fallback message is returned and an error is logged.\n    \"\"\"\n    question = \"Cari laptop.\"\n    mock_product_data_service.smart_search_products.side_effect = Exception(\"Product service internal error\")\n\n    with caplog.at_level(logging.ERROR):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n        mock_product_data_service.smart_search_products.assert_called_once()\n        assert \"Error generating AI response: Product service internal error\" in caplog.text\n\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"question, expected_category, expected_max_price\",\n    [\n        # Test cases for category and price detection\n        (\"Cari laptop gaming 10 juta\", \"laptop\", 10_000_000),\n        (\"Smartphone murah\", \"smartphone\", 5_000_000), # Detects 'smartphone' and 'murah' for price\n        (\"Tablet di bawah 5 juta\", \"tablet\", 5_000_000), # Detects 'tablet' and '5 juta' for price\n        (\"earphone bluetooth\", \"headphone\", None),\n        (\"Kamera DSLR bagus\", \"kamera\", None),\n        (\"TV Samsung 20 juta\", \"tv\", 20_000_000),\n        (\"Jam tangan pintar\", \"jam\", None),\n        (\"Ponsel dengan budget 7 juta\", \"smartphone\", 7_000_000),\n        (\"Headset gaming\", \"headphone\", None),\n        (\"Cari produk audio\", \"headphone\", None), # 'audio' keyword in question, 'headphone' category wins due to map order\n        (\"Saya mau beli HP dengan 3 juta\", \"smartphone\", 3_000_000),\n        (\"drone budget 10 juta\", \"drone\", 10_000_000),\n        (\"notebook 8 juta\", \"laptop\", 8_000_000),\n        (\"ipad pro\", \"tablet\", None),\n        (\"handphone 2 juta\", \"smartphone\", 2_000_000),\n        (\"TV yang murah\", \"tv\", 5_000_000), # Test 'murah' with category\n        (\"budget murah untuk audio\", \"headphone\", 5_000_000), # Test 'budget' with category, 'audio' in headphone keywords\n        (\"telepon seluler\", \"smartphone\", None), # Test synonym\n        (\"komputer baru\", \"laptop\", None), # Test synonym\n        (\"fotografi gear\", \"kamera\", None), # Test synonym\n        (\"speaker bluetooth\", \"audio\", None), # Test synonym, 'speaker' is in 'audio' category\n        (\"ponsel android 4 juta\", \"smartphone\", 4_000_000), # Combined\n        (\"smartwatch 1 juta\", \"jam\", 1_000_000), # Combined\n        (\"laptop budget\", \"laptop\", 5_000_000), # Category + \"budget\"\n        (\"Headphone murah banget\", \"headphone\", 5_000_000), # Category + \"murah\"\n        (\"Cari smartphone\", \"smartphone\", None), # Just category\n        (\"Harga 2 juta\", None, 2_000_000), # Just price (no category)\n        (\"Sebuah kamera\", \"kamera\", None), # Basic category detection\n        (\"TV\", \"tv\", None), # Minimal category detection\n\n        # Additional cases for 'budget' / 'murah' without explicit 'juta' and no category\n        (\"Saya cari yang murah saja\", None, 5_000_000),\n        (\"Budget saya terbatas\", None, 5_000_000),\n        (\"Sesuai budget\", None, 5_000_000),\n\n        # Test for general information questions (no category, no price detected)\n        (\"Apa itu AI?\", None, None),\n        (\"Berapa banyak produk yang kalian punya?\", None, None),\n        (\"Rekomendasi umum\", None, None),\n        (\"Apa rekomendasi terbaik?\", None, None),\n        (\"Produk\", None, None),\n\n        # Test for overlapping keywords, ensuring the first match in category_mapping applies\n        (\"Saya mau beli notebook atau hp?\", \"laptop\", None), # 'notebook' (laptop) appears before 'hp' (smartphone) in mapping\n        (\"headset dan earphone murah\", \"headphone\", 5_000_000), # Only one category, but both keywords present\n\n        # New cases to cover identified gaps\n        (\"iPhone 15 terbaru\", None, None), # Number without 'juta' should not be detected as price\n        (\"Cari TV terbaru harga 10\", \"tv\", None), # Number not followed by 'juta'\n        (\"laptop budget juta\", \"laptop\", 5_000_000), # \"budget\" detected, not \"juta\" regex\n        (\"LAPTOP GAMING 15 JUTA\", \"laptop\", 15_000_000), # Mixed casing\n        (\"saya butuh tablet 100 juta\", \"tablet\", 100_000_000), # Large number for price\n    ]\n)\nasync def test_get_response_category_and_price_detection(\n    ai_service_instance, mock_product_data_service, mock_genai_client,\n    question, expected_category, expected_max_price\n):\n    \"\"\"\n    Tests that get_response correctly extracts category and max_price from various questions.\n    It verifies the arguments passed to `smart_search_products` including the hardcoded limit.\n    \"\"\"\n    await ai_service_instance.get_response(question)\n\n    mock_product_data_service.smart_search_products.assert_called_once()\n    call_args, _ = mock_product_data_service.smart_search_products.call_args\n\n    assert call_args[1]['category'] == expected_category\n    assert call_args[1]['max_price'] == expected_max_price\n    assert call_args[1]['keyword'] == question # Ensure keyword is always passed\n    assert call_args[1]['limit'] == 5 # Ensure limit is always 5\n\n@pytest.mark.asyncio\nasync def test_get_response_empty_question(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests get_response with an empty question string.\n    Ensures smart_search_products is called with default parameters (empty keyword, None category/price)\n    and that the prompt context correctly reflects the empty question and no products found.\n    \"\"\"\n    question = \"\"\n    await ai_service_instance.get_response(question)\n\n    mock_product_data_service.smart_search_products.assert_called_once_with(\n        keyword=\"\", category=None, max_price=None, limit=5\n    )\n    mock_genai_client.models.generate_content.assert_called_once()\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n    assert \"Question: \\n\\nNo specific products found, but I can provide general recommendations.\" in prompt\n    assert call_args[0]['model'] == \"gemini-2.5-flash\"\n\n@pytest.mark.asyncio\nasync def test_get_response_product_context_missing_keys(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests that product context building handles missing product dictionary keys gracefully\n    by using default values ('Unknown', 0, 'No description').\n    \"\"\"\n    question = \"Products with missing info\"\n    mock_products = [\n        # Product with many missing keys\n        {\"price\": 1_000_000, \"description\": \"A very basic product description.\"},\n        # Product with empty specifications, missing price, description\n        {\"name\": \"Product B\", \"brand\": \"BrandB\", \"category\": \"tablet\", \"specifications\": {}},\n        # Product with all fields, but rating is missing within specifications\n        {\"name\": \"Product C\", \"price\": 5_000_000, \"brand\": \"BrandC\", \"category\": \"laptop\", \"specifications\": {\"display\": \"13 inch\"}, \"description\": \"Another product description.\"},\n    ]\n    mock_fallback_message = \"Some products with incomplete data.\"\n    mock_product_data_service.smart_search_products.return_value = (mock_products, mock_fallback_message)\n    mock_genai_client.models.generate_content.return_value.text = \"Response about products with missing info.\"\n\n    response = await ai_service_instance.get_response(question)\n\n    assert response == \"Response about products with missing info.\"\n    mock_genai_client.models.generate_content.assert_called_once()\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n\n    # Test for Product 1 (missing name, brand, category, specifications/rating)\n    assert \"1. Unknown\" in prompt\n    assert \"Price: Rp 1,000,000\" in prompt\n    assert \"Brand: Unknown\" in prompt\n    assert \"Category: Unknown\" in prompt\n    assert \"Rating: 0/5\" in prompt\n    assert \"Description: A very basic product description....\" in prompt # Default description truncation\n\n    # Test for Product 2 (missing price, description, empty specifications/rating)\n    assert \"2. Product B\" in prompt\n    assert \"Price: Rp 0\" in prompt # Default for missing price\n    assert \"Brand: BrandB\" in prompt\n    assert \"Category: tablet\" in prompt\n    assert \"Rating: 0/5\" in prompt # Default for missing rating\n    assert \"Description: No description...\" in prompt # Default for missing description\n\n    # Test for Product 3 (all fields present, but rating missing within specifications)\n    assert \"3. Product C\" in prompt\n    assert \"Price: Rp 5,000,000\" in prompt\n    assert \"Brand: BrandC\" in prompt\n    assert \"Category: laptop\" in prompt\n    assert \"Rating: 0/5\" in prompt # Default for rating if key is missing in specifications\n    assert \"Description: Another product description....\" in prompt\n\n@pytest.mark.asyncio\nasync def test_get_response_product_description_truncation_longer_than_200_chars(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests that product descriptions longer than 200 characters are truncated to 200 characters and appended with '...'.\n    \"\"\"\n    question = \"Long description product\"\n    long_description = \"A\" * 250 # Create a description longer than 200 characters\n    mock_products = [\n        {\"name\": \"Product with Long Desc\", \"price\": 100, \"brand\": \"Test\", \"category\": \"test\", \"specifications\": {\"rating\": 5}, \"description\": long_description},\n    ]\n    mock_product_data_service.smart_search_products.return_value = (mock_products, \"Found one.\")\n    mock_genai_client.models.generate_content.return_value.text = \"Truncated description response.\"\n\n    await ai_service_instance.get_response(question)\n\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n\n    expected_truncated_desc = long_description[:200] + \"...\"\n    assert f\"Description: {expected_truncated_desc}\\n\\n\" in prompt\n    assert long_description not in prompt # Ensure the full, untruncated description is not present\n    assert len(expected_truncated_desc) == 203\n\n@pytest.mark.asyncio\nasync def test_get_response_product_description_truncation_exact_200_chars(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests that product descriptions exactly 200 characters long are still appended with '...'.\n    \"\"\"\n    question = \"Exact 200 chars desc\"\n    exact_description = \"B\" * 200 # Create a description exactly 200 characters\n    mock_products = [\n        {\"name\": \"Product Exact Desc\", \"price\": 100, \"brand\": \"Test\", \"category\": \"test\", \"specifications\": {\"rating\": 5}, \"description\": exact_description},\n    ]\n    mock_product_data_service.smart_search_products.return_value = (mock_products, \"Found one.\")\n    mock_genai_client.models.generate_content.return_value.text = \"Exact 200 chars truncation response.\"\n\n    await ai_service_instance.get_response(question)\n\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n\n    expected_output = exact_description + \"...\" # Source code always appends \"...\"\n    assert f\"Description: {expected_output}\\n\\n\" in prompt\n    assert len(expected_output) == 203\n\n@pytest.mark.asyncio\nasync def test_get_response_product_description_truncation_less_than_200_chars(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests that product descriptions less than 200 characters long are still appended with '...'.\n    \"\"\"\n    question = \"Short description\"\n    short_description = \"C\" * 150 # Create a description less than 200 characters\n    mock_products = [\n        {\"name\": \"Product Short Desc\", \"price\": 100, \"brand\": \"Test\", \"category\": \"test\", \"specifications\": {\"rating\": 5}, \"description\": short_description},\n    ]\n    mock_product_data_service.smart_search_products.return_value = (mock_products, \"Found one.\")\n    mock_genai_client.models.generate_content.return_value.text = \"Short desc truncation response.\"\n\n    await ai_service_instance.get_response(question)\n\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n\n    expected_output = short_description + \"...\" # Source code always appends \"...\"\n    assert f\"Description: {expected_output}\\n\\n\" in prompt\n    assert len(expected_output) == 153 # 150 + 3 for \"...\"\n\n\n# --- Tests for generate_response method (legacy/synchronous) ---\n\ndef test_generate_response_success(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests successful execution of the legacy `generate_response` method.\n    Verifies the correct AI model and prompt content are used, and that the\n    response text is returned.\n    \"\"\"\n    context = \"This is a test context for legacy generation.\"\n    expected_response_text = \"Legacy AI response.\"\n\n    # The mock_genai_client fixture is already set up to have `mock_genai_client.models.generate_content.text`\n    # available for synchronous access, which is what `generate_response` uses.\n    mock_genai_client.models.generate_content.text = expected_response_text\n    \n    with caplog.at_level(logging.INFO):\n        response = ai_service_instance.generate_response(context)\n\n        assert response == expected_response_text\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        assert call_args[0]['model'] == \"gemini-2.0-flash\" # Explicitly check model name\n        \n        expected_prompt_part = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n        assert expected_prompt_part in call_args[0]['contents']\n        assert \"Successfully generated AI response\" in caplog.text\n\ndef test_generate_response_ai_generation_failure(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests `generate_response` when the AI client fails to generate a response.\n    Ensures an exception is re-raised and an error is logged.\n    \"\"\"\n    context = \"Failing context.\"\n    \n    # Configure the mock_genai_client fixture's `generate_content` method to raise an exception\n    # directly when called synchronously.\n    mock_genai_client.models.generate_content.side_effect = Exception(\"Legacy AI API error\")\n\n    with caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Legacy AI API error\"):\n            ai_service_instance.generate_response(context)\n        mock_genai_client.models.generate_content.assert_called_once()\n        assert \"Error generating AI response: Legacy AI API error\" in caplog.text"
    },
    {
      "filepath": "app/services/local_product_service.py",
      "coverage": 11.540000000000001,
      "content": "import logging\nimport json\nimport random\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass LocalProductService:\n    \"\"\"\n    Service untuk data produk lokal yang reliable dan tidak bergantung pada API eksternal\n    \"\"\"\n    \n    def __init__(self):\n        self.products = self._load_local_products()\n        logger.info(f\"Loaded {len(self.products)} local products from JSON file\")\n    \n    def _load_local_products(self) -> List[Dict]:\n        \"\"\"Load produk dari file JSON lokal\"\"\"\n        try:\n            # Get the path to the data/products.json file\n            current_dir = Path(__file__).parent.parent.parent\n            json_file_path = current_dir / \"data\" / \"products.json\"\n            \n            if not json_file_path.exists():\n                logger.error(f\"Products JSON file not found at: {json_file_path}\")\n                return self._get_fallback_products()\n            \n            # Try different encodings\n            encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n            \n            for encoding in encodings:\n                try:\n                    with open(json_file_path, 'r', encoding=encoding) as file:\n                        content = file.read()\n                        # Remove BOM if present\n                        if content.startswith('\\ufeff'):\n                            content = content[1:]\n                        \n                        data = json.loads(content)\n                        products = data.get('products', [])\n                        \n                        # Transform products to match expected format\n                        transformed_products = []\n                        for product in products:\n                            transformed_product = {\n                                \"id\": product.get('id', ''),\n                                \"name\": product.get('name', ''),\n                                \"category\": product.get('category', ''),\n                                \"brand\": product.get('brand', ''),\n                                \"price\": product.get('price', 0),\n                                \"currency\": product.get('currency', 'IDR'),\n                                \"description\": product.get('description', ''),\n                                \"specifications\": {\n                                    \"rating\": product.get('rating', 0),\n                                    \"sold\": random.randint(100, 2000),  # Add random sold count\n                                    \"stock\": product.get('stock_count', 0),\n                                    \"condition\": \"Baru\",\n                                    \"shop_location\": \"Indonesia\",\n                                    \"shop_name\": f\"{product.get('brand', 'Unknown')} Store\",\n                                    **product.get('specifications', {})\n                                },\n                                \"availability\": product.get('availability', 'in_stock'),\n                                \"reviews_count\": product.get('reviews_count', 0),\n                                \"images\": [f\"https://example.com/{product.get('id', 'product')}.jpg\"],\n                                \"url\": f\"https://shopee.co.id/{product.get('id', 'product')}\"\n                            }\n                            transformed_products.append(transformed_product)\n                        \n                        logger.info(f\"Successfully loaded {len(transformed_products)} products from JSON file using {encoding} encoding\")\n                        return transformed_products\n                        \n                except (UnicodeDecodeError, json.JSONDecodeError) as e:\n                    logger.warning(f\"Failed to load with {encoding} encoding: {str(e)}\")\n                    continue\n            \n            # If all encodings fail, use fallback\n            logger.error(\"All encoding attempts failed, using fallback products\")\n            return self._get_fallback_products()\n                \n        except Exception as e:\n            logger.error(f\"Error loading products from JSON file: {str(e)}\")\n            return self._get_fallback_products()\n    \n    def _get_fallback_products(self) -> List[Dict]:\n        \"\"\"Fallback products if JSON file cannot be loaded\"\"\"\n        logger.warning(\"Using fallback products due to JSON file loading error\")\n        return [\n            {\n                \"id\": \"1\",\n                \"name\": \"iPhone 15 Pro Max\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Apple\",\n                \"price\": 25000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPhone 15 Pro Max dengan chip A17 Pro, kamera 48MP, dan layar 6.7 inch Super Retina XDR. Dilengkapi dengan titanium design dan performa gaming yang luar biasa.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 1250,\n                    \"stock\": 50,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Titanium Natural\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"A17 Pro\",\n                    \"camera\": \"48MP Main + 12MP Ultra Wide + 12MP Telephoto\",\n                    \"display\": \"6.7 inch Super Retina XDR\"\n                },\n                \"images\": [\"https://example.com/iphone15.jpg\"],\n                \"url\": \"https://shopee.co.id/iphone-15-pro-max\"\n            },\n            {\n                \"id\": \"2\", \n                \"name\": \"Samsung Galaxy S24 Ultra\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Samsung\",\n                \"price\": 22000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy S24 Ultra dengan S Pen, kamera 200MP, dan AI features canggih. Dilengkapi dengan Snapdragon 8 Gen 3 dan layar AMOLED 6.8 inch.\",\n                \"specifications\": {\n                    \"rating\": 4.7,\n                    \"sold\": 980,\n                    \"stock\": 35,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"512GB\",\n                    \"color\": \"Titanium Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 3\",\n                    \"camera\": \"200MP Main + 12MP Ultra Wide + 50MP Telephoto + 10MP Telephoto\",\n                    \"display\": \"6.8 inch Dynamic AMOLED 2X\"\n                },\n                \"images\": [\"https://example.com/s24-ultra.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-s24-ultra\"\n            },\n            {\n                \"id\": \"3\",\n                \"name\": \"MacBook Pro 14 inch M3\",\n                \"category\": \"Laptop\",\n                \"brand\": \"Apple\",\n                \"price\": 35000000,\n                \"currency\": \"IDR\",\n                \"description\": \"MacBook Pro dengan chip M3, layar 14 inch Liquid Retina XDR, dan performa tinggi untuk profesional. Cocok untuk video editing, programming, dan gaming.\",\n                \"specifications\": {\n                    \"rating\": 4.9,\n                    \"sold\": 450,\n                    \"stock\": 25,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"1TB\",\n                    \"color\": \"Space Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M3\",\n                    \"ram\": \"16GB Unified Memory\",\n                    \"display\": \"14 inch Liquid Retina XDR\"\n                },\n                \"images\": [\"https://example.com/macbook-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/macbook-pro-m3\"\n            },\n            {\n                \"id\": \"4\",\n                \"name\": \"AirPods Pro 2nd Gen\",\n                \"category\": \"Audio\",\n                \"brand\": \"Apple\",\n                \"price\": 4500000,\n                \"currency\": \"IDR\",\n                \"description\": \"AirPods Pro dengan Active Noise Cancellation dan Spatial Audio. Dilengkapi dengan chip H2 untuk performa audio yang lebih baik dan fitur Find My.\",\n                \"specifications\": {\n                    \"rating\": 4.6,\n                    \"sold\": 2100,\n                    \"stock\": 100,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"color\": \"White\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"6 jam dengan ANC, 30 jam dengan case\",\n                    \"features\": \"Active Noise Cancellation, Spatial Audio, Find My\"\n                },\n                \"images\": [\"https://example.com/airpods-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/airpods-pro-2\"\n            },\n            {\n                \"id\": \"5\",\n                \"name\": \"iPad Air 5th Gen\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Apple\",\n                \"price\": 12000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPad Air dengan chip M1, layar 10.9 inch Liquid Retina, dan Apple Pencil support. Cocok untuk kreativitas, note-taking, dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.5,\n                    \"sold\": 750,\n                    \"stock\": 40,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Medan\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Blue\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M1\",\n                    \"display\": \"10.9 inch Liquid Retina\",\n                    \"features\": \"Apple Pencil support, Magic Keyboard support\"\n                },\n                \"images\": [\"https://example.com/ipad-air.jpg\"],\n                \"url\": \"https://shopee.co.id/ipad-air-5\"\n            },\n            {\n                \"id\": \"6\",\n                \"name\": \"ASUS ROG Strix G15\",\n                \"category\": \"Laptop\",\n                \"brand\": \"ASUS\",\n                \"price\": 18000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Laptop gaming ASUS ROG Strix G15 dengan RTX 4060, AMD Ryzen 7, dan layar 15.6 inch 144Hz. Dilengkapi dengan RGB keyboard dan cooling system yang powerful.\",\n                \"specifications\": {\n                    \"rating\": 4.4,\n                    \"sold\": 320,\n                    \"stock\": 15,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"ASUS Store\",\n                    \"storage\": \"512GB SSD\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"2 Tahun\",\n                    \"processor\": \"AMD Ryzen 7 7735HS\",\n                    \"gpu\": \"NVIDIA RTX 4060 8GB\",\n                    \"ram\": \"16GB DDR5\",\n                    \"display\": \"15.6 inch FHD 144Hz\"\n                },\n                \"images\": [\"https://example.com/rog-strix.jpg\"],\n                \"url\": \"https://shopee.co.id/asus-rog-strix-g15\"\n            },\n            {\n                \"id\": \"7\",\n                \"name\": \"Sony WH-1000XM5\",\n                \"category\": \"Audio\",\n                \"brand\": \"Sony\",\n                \"price\": 5500000,\n                \"currency\": \"IDR\",\n                \"description\": \"Headphone wireless Sony WH-1000XM5 dengan noise cancellation terbaik di kelasnya. Dilengkapi dengan 30 jam battery life dan quick charge.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 890,\n                    \"stock\": 30,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Sony Store\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"30 jam dengan ANC\",\n                    \"features\": \"Industry-leading noise cancellation, Quick Charge, Multipoint connection\"\n                },\n                \"images\": [\"https://example.com/sony-wh1000xm5.jpg\"],\n                \"url\": \"https://shopee.co.id/sony-wh1000xm5\"\n            },\n            {\n                \"id\": \"8\",\n                \"name\": \"Samsung Galaxy Tab S9\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Samsung\",\n                \"price\": 15000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy Tab S9 dengan S Pen, layar AMOLED 11 inch, dan Snapdragon 8 Gen 2. Cocok untuk productivity dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.3,\n                    \"sold\": 280,\n                    \"stock\": 20,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Graphite\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 2\",\n                    \"display\": \"11 inch Dynamic AMOLED 2X\",\n                    \"features\": \"S Pen included, DeX mode, Multi-window\"\n                },\n                \"images\": [\"https://example.com/galaxy-tab-s9.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-galaxy-tab-s9\"\n            }\n        ]\n    \n    def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"\n        Search products berdasarkan keyword\n        \"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            \n            keyword_lower = keyword.lower()\n            filtered_products = []\n            \n            # Extract price range from keyword\n            max_price = self._extract_price_from_keyword(keyword)\n            \n            for product in self.products:\n                product_price = product.get('price', 0)\n                \n                # Check if product matches price range\n                if max_price and product_price <= max_price:\n                    filtered_products.append(product)\n                    continue\n                \n                # Search in name, description, category, brand, and specifications\n                searchable_text = (\n                    product.get('name', '') + ' ' +\n                    product.get('description', '') + ' ' +\n                    product.get('category', '') + ' ' +\n                    product.get('brand', '') + ' ' +\n                    str(product.get('specifications', {}))\n                ).lower()\n                \n                if keyword_lower in searchable_text:\n                    filtered_products.append(product)\n            \n            # Sort by relevance (exact matches first, then by price if budget search)\n            def relevance_score(product):\n                score = 0\n                if keyword_lower in product.get('name', '').lower():\n                    score += 10\n                if keyword_lower in product.get('brand', '').lower():\n                    score += 5\n                if keyword_lower in product.get('category', '').lower():\n                    score += 3\n                \n                # For budget searches, prefer lower prices\n                if max_price or any(word in keyword_lower for word in ['murah', 'budget', 'hemat', 'terjangkau']):\n                    score += (10000000 - product.get('price', 0)) / 1000000  # Higher score for lower prices\n                \n                return score\n            \n            filtered_products.sort(key=relevance_score, reverse=True)\n            \n            logger.info(f\"Found {len(filtered_products)} products\")\n            return filtered_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    def _extract_price_from_keyword(self, keyword: str) -> Optional[int]:\n        \"\"\"\n        Extract maximum price from keyword\n        \"\"\"\n        try:\n            keyword_lower = keyword.lower()\n            \n            # Common price patterns\n            price_patterns = [\n                (r'(\\d+)\\s*juta', lambda x: int(x) * 1000000),\n                (r'(\\d+)\\s*ribu', lambda x: int(x) * 1000),\n                (r'rp\\s*(\\d+)', lambda x: int(x)),\n                (r'(\\d+)\\s*rp', lambda x: int(x)),\n                (r'(\\d+)\\s*k', lambda x: int(x) * 1000),\n                (r'(\\d+)\\s*m', lambda x: int(x) * 1000000),\n            ]\n            \n            import re\n            for pattern, converter in price_patterns:\n                match = re.search(pattern, keyword_lower)\n                if match:\n                    return converter(match.group(1))\n            \n            # Budget keywords\n            budget_keywords = {\n                'murah': 5000000,  # 5 juta\n                'budget': 5000000,\n                'hemat': 3000000,  # 3 juta\n                'terjangkau': 4000000,  # 4 juta\n                'ekonomis': 2000000,  # 2 juta\n            }\n            \n            for word, max_price in budget_keywords.items():\n                if word in keyword_lower:\n                    return max_price\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error extracting price from keyword: {str(e)}\")\n            return None\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"\n        Get detail produk berdasarkan ID\n        \"\"\"\n        try:\n            for product in self.products:\n                if product.get('id') == product_id:\n                    return product\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_categories(self) -> List[str]:\n        \"\"\"\n        Get daftar kategori produk\n        \"\"\"\n        categories = set()\n        for product in self.products:\n            categories.add(product.get('category', ''))\n        return sorted(list(categories))\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"\n        Get daftar brand produk\n        \"\"\"\n        brands = set()\n        for product in self.products:\n            brands.add(product.get('brand', ''))\n        return sorted(list(brands))\n    \n    def get_products_by_category(self, category: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan kategori\n        \"\"\"\n        try:\n            category_lower = category.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if category_lower in product.get('category', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan brand\n        \"\"\"\n        try:\n            brand_lower = brand.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if brand_lower in product.get('brand', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    def get_top_rated_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"\n        Get produk dengan rating tertinggi\n        \"\"\"\n        try:\n            sorted_products = sorted(\n                self.products, \n                key=lambda x: x.get('specifications', {}).get('rating', 0), \n                reverse=True\n            )\n            return sorted_products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    def get_best_selling_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"Get produk dengan penjualan tertinggi\"\"\"\n        try:\n            logger.info(f\"Getting best selling products, limit: {limit}\")\n            \n            # Sort berdasarkan sold count\n            sorted_products = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n            \n            logger.info(f\"Returning {min(limit, len(sorted_products))} best selling products\")\n            return sorted_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get semua produk\"\"\"\n        try:\n            logger.info(f\"Getting all products, limit: {limit}\")\n            return self.products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return []\n    \n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: cari produk sesuai kriteria, lalu fallback bertingkat dengan notifikasi.\n        Return: (list produk, pesan)\n        \"\"\"\n        keyword_lower = (keyword or '').lower()\n        \n        # Deteksi permintaan \"terbaik\"\n        is_best_request = 'terbaik' in keyword_lower or 'best' in keyword_lower\n        \n        # 1. Jika user minta \"terbaik\" tanpa kategori spesifik\n        if is_best_request and not category:\n            # Tampilkan produk terbaik secara umum (top 5 berdasarkan rating)\n            best_products = sorted(self.products, \n                                 key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                 reverse=True)\n            return best_products[:limit], \"Berikut produk terbaik berdasarkan rating:\"\n        \n        # 2. Jika user minta \"terbaik\" dengan kategori spesifik\n        if is_best_request and category:\n            category_products = [p for p in self.products \n                               if category.lower() in p.get('category', '').lower()]\n            if category_products:\n                category_products.sort(key=lambda x: x.get('specifications', {}).get('rating', 0), reverse=True)\n                return category_products[:limit], f\"Berikut {category} terbaik berdasarkan rating:\"\n            else:\n                # Fallback ke produk terbaik secara umum jika kategori tidak ditemukan\n                best_products = sorted(self.products, \n                                     key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                     reverse=True)\n                return best_products[:limit], f\"Tidak ada produk kategori {category}, berikut produk terbaik secara umum:\"\n        \n        # 3. Cari produk yang memenuhi semua kriteria (non-terbaik)\n        results = [\n            p for p in self.products\n            if (not category or category.lower() in p.get('category', '').lower())\n            and (not max_price or p.get('price', 0) <= max_price)\n            and (not keyword or keyword_lower in (p.get('name', '') + ' ' + p.get('description', '') + ' ' + p.get('category', '') + ' ' + p.get('brand', '') + str(p.get('specifications', {}))).lower())\n        ]\n        if results:\n            return results[:limit], \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n        # 4. Jika tidak ada, cari produk di kategori yang sama (tanpa filter harga)\n        if category:\n            category_results = [\n                p for p in self.products\n                if category.lower() in p.get('category', '').lower()\n            ]\n            if category_results:\n                category_results.sort(key=lambda x: x.get('price', 0))\n                return category_results[:limit], \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\n        # 5. Jika tetap tidak ada, tampilkan produk lain yang sesuai budget\n        if max_price:\n            budget_results = [\n                p for p in self.products\n                if p.get('price', 0) <= max_price\n            ]\n            if budget_results:\n                return budget_results[:limit], \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\n        # 6. Jika tetap tidak ada, tampilkan produk terpopuler/terlaris\n        popular_results = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n        return popular_results[:limit], \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\" ",
      "existing_test": "import pytest\nfrom unittest.mock import patch, mock_open, MagicMock, call\nimport logging\nimport json\nimport random\nfrom typing import List, Dict\nfrom pathlib import Path\nimport sys\nimport builtins # Added for patching open\n\n# Add the parent directory of 'app' to the sys.path\n# This allows imports like 'from app.services.local_product_service import LocalProductService'\n# to work correctly when tests are run from a different root.\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom app.services.local_product_service import LocalProductService\n\n# Mock data for testing\n# MOCK_PRODUCTS_RAW_FOR_JSON represents the data structure *read from the JSON file*\nMOCK_PRODUCTS_RAW_FOR_JSON = [\n    {\n        \"id\": \"prod1\",\n        \"name\": \"Product A\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 100000,\n        \"currency\": \"IDR\",\n        \"description\": \"Description A. A very good product.\",\n        \"specifications\": {\"rating\": 4.5, \"sold\": 500, \"stock_count\": 100, \"extra_spec\": \"value1\"},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 10,\n        \"images\": [\"url_a.jpg\"],\n        \"url\": \"url_a\"\n    },\n    {\n        \"id\": \"prod2\",\n        \"name\": \"Product B\",\n        \"category\": \"Category2\",\n        \"brand\": \"BrandY\",\n        \"price\": 200000,\n        \"currency\": \"IDR\",\n        \"description\": \"Description B, also Product A related. A moderate product.\",\n        \"specifications\": {\"rating\": 3.8, \"sold\": 300, \"stock_count\": 50},\n        \"availability\": \"out_of_stock\",\n        \"reviews_count\": 5,\n        \"images\": [\"url_b.jpg\"],\n        \"url\": \"url_b\"\n    },\n    {\n        \"id\": \"prod3\",\n        \"name\": \"Product C\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 50000, # Cheapest product, high rating\n        \"currency\": \"IDR\",\n        \"description\": \"Cheapest product, high quality. Very good.\",\n        \"specifications\": {\"rating\": 4.9, \"sold\": 1200, \"stock_count\": 200}, # Highest rated\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 20,\n        \"images\": [\"url_c.jpg\"],\n        \"url\": \"url_c\"\n    },\n    {\n        \"id\": \"prod4\",\n        \"name\": \"Product D\",\n        \"category\": \"Category3\",\n        \"brand\": \"BrandZ\",\n        \"price\": 5000000, # 5 juta\n        \"currency\": \"IDR\",\n        \"description\": \"Expensive gadget. This is a very pricy item.\",\n        \"specifications\": {\"rating\": 4.0, \"sold\": 100, \"stock_count\": 10},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 2,\n        \"images\": [\"url_d.jpg\"],\n        \"url\": \"url_d\"\n    },\n    {\n        \"id\": \"prod5\",\n        \"name\": \"Product E (Best Seller)\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 150000,\n        \"currency\": \"IDR\",\n        \"description\": \"Best seller in Category1. Popular choice.\",\n        \"specifications\": {\"rating\": 4.6, \"sold\": 15000, \"stock_count\": 1000}, # Highest sold\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 150,\n        \"images\": [\"url_e.jpg\"],\n        \"url\": \"url_e\"\n    },\n    {\n        \"id\": \"prod6\",\n        \"name\": \"Product F (Budget)\",\n        \"category\": \"Category2\",\n        \"brand\": \"BrandY\",\n        \"price\": 4000000, # 4 juta\n        \"currency\": \"IDR\",\n        \"description\": \"A budget friendly product. Very affordable.\",\n        \"specifications\": {\"rating\": 3.0, \"sold\": 50, \"stock_count\": 20},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 1,\n        \"images\": [\"url_f.jpg\"],\n        \"url\": \"url_f\"\n    },\n    # Add a product with minimal fields to test defaults in transformation\n    {\n        \"id\": \"prod7\",\n        \"name\": \"Minimal Product\",\n        \"description\": \"This product has minimal details.\",\n    },\n    # Add a product with custom spec that should be merged\n    {\n        \"id\": \"prod8\",\n        \"name\": \"Custom Spec Product\",\n        \"category\": \"Electronics\",\n        \"price\": 750000,\n        \"specifications\": {\n            \"custom_field\": \"custom_value\",\n            \"rating\": 4.2,\n            \"stock_count\": 70,\n        },\n    }\n]\n\n# TRANSFORMED_MOCK_PRODUCTS_DATA represents the data structure *stored internally* by the service\n# after loading and applying transformations (e.g., random sold count, default fields).\n# The 'sold' count will be mocked to 1000 for deterministic tests in the fixture.\nTRANSFORMED_MOCK_PRODUCTS_DATA = [\n    {\n        \"id\": \"prod1\", \"name\": \"Product A\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 100000, \"currency\": \"IDR\", \"description\": \"Description A. A very good product.\",\n        \"specifications\": {\"rating\": 4.5, \"sold\": 1000, \"stock\": 100, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\", \"extra_spec\": \"value1\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 10, \"images\": [\"https://example.com/prod1.jpg\"], \"url\": \"https://shopee.co.id/prod1\"\n    },\n    {\n        \"id\": \"prod2\", \"name\": \"Product B\", \"category\": \"Category2\", \"brand\": \"BrandY\", \"price\": 200000, \"currency\": \"IDR\", \"description\": \"Description B, also Product A related. A moderate product.\",\n        \"specifications\": {\"rating\": 3.8, \"sold\": 1000, \"stock\": 50, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandY Store\"},\n        \"availability\": \"out_of_stock\", \"reviews_count\": 5, \"images\": [\"https://example.com/prod2.jpg\"], \"url\": \"https://shopee.co.id/prod2\"\n    },\n    {\n        \"id\": \"prod3\", \"name\": \"Product C\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 50000, \"currency\": \"IDR\", \"description\": \"Cheapest product, high quality. Very good.\",\n        \"specifications\": {\"rating\": 4.9, \"sold\": 1000, \"stock\": 200, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 20, \"images\": [\"https://example.com/prod3.jpg\"], \"url\": \"https://shopee.co.id/prod3\"\n    },\n    {\n        \"id\": \"prod4\", \"name\": \"Product D\", \"category\": \"Category3\", \"brand\": \"BrandZ\", \"price\": 5000000, \"currency\": \"IDR\", \"description\": \"Expensive gadget. This is a very pricy item.\",\n        \"specifications\": {\"rating\": 4.0, \"sold\": 1000, \"stock\": 10, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandZ Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 2, \"images\": [\"https://example.com/prod4.jpg\"], \"url\": \"https://shopee.co.id/prod4\"\n    },\n    {\n        \"id\": \"prod5\", \"name\": \"Product E (Best Seller)\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 150000, \"currency\": \"IDR\", \"description\": \"Best seller in Category1. Popular choice.\",\n        \"specifications\": {\"rating\": 4.6, \"sold\": 1000, \"stock\": 1000, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 150, \"images\": [\"https://example.com/prod5.jpg\"], \"url\": \"https://shopee.co.id/prod5\"\n    },\n    {\n        \"id\": \"prod6\", \"name\": \"Product F (Budget)\", \"category\": \"Category2\", \"brand\": \"BrandY\", \"price\": 4000000, \"currency\": \"IDR\", \"description\": \"A budget friendly product. Very affordable.\",\n        \"specifications\": {\"rating\": 3.0, \"sold\": 1000, \"stock\": 20, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandY Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 1, \"images\": [\"https://example.com/prod6.jpg\"], \"url\": \"https://shopee.co.id/prod6\"\n    },\n    {   # prod7 - minimal fields\n        \"id\": \"prod7\", \"name\": \"Minimal Product\", \"category\": \"\", \"brand\": \"\", \"price\": 0, \"currency\": \"IDR\", \"description\": \"This product has minimal details.\",\n        \"specifications\": {\"rating\": 0, \"sold\": 1000, \"stock\": 0, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"Unknown Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 0, \"images\": [\"https://example.com/prod7.jpg\"], \"url\": \"https://shopee.co.id/prod7\"\n    },\n    {   # prod8 - custom spec\n        \"id\": \"prod8\", \"name\": \"Custom Spec Product\", \"category\": \"Electronics\", \"brand\": \"\", \"price\": 750000, \"currency\": \"IDR\", \"description\": \"\",\n        \"specifications\": {\"rating\": 4.2, \"sold\": 1000, \"stock\": 70, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"Unknown Store\", \"custom_field\": \"custom_value\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 0, \"images\": [\"https://example.com/prod8.jpg\"], \"url\": \"https://shopee.co.id/prod8\"\n    }\n]\n\n\n@pytest.fixture\ndef mock_local_product_service_instance():\n    \"\"\"\n    Fixture to provide a LocalProductService instance with pre-defined mock products,\n    bypassing the file loading mechanism for most tests.\n    Also mocks random.randint for deterministic 'sold' values during transformation.\n    \"\"\"\n    with patch('random.randint', return_value=1000), \\\n         patch('app.services.local_product_service.LocalProductService._load_local_products',\n               return_value=TRANSFORMED_MOCK_PRODUCTS_DATA) as mock_load:\n        service = LocalProductService()\n        mock_load.assert_called_once() # Ensure init calls _load_local_products\n        yield service\n\n@pytest.fixture\ndef mock_logger():\n    \"\"\"Fixture to mock the logger to capture log messages.\"\"\"\n    with patch('app.services.local_product_service.logger') as mock_log:\n        yield mock_log\n\n# --- Tests for __init__ and _load_local_products ---\n\ndef test_init_success(mock_logger):\n    \"\"\"\n    Test that LocalProductService initializes successfully by loading products.\n    \"\"\"\n    # Mock _load_local_products to return a specific list\n    with patch('random.randint', return_value=1000), \\\n         patch('app.services.local_product_service.LocalProductService._load_local_products',\n               return_value=TRANSFORMED_MOCK_PRODUCTS_DATA) as mock_load:\n        service = LocalProductService()\n        mock_load.assert_called_once()\n        assert service.products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        mock_logger.info.assert_called_with(f\"Loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} local products from JSON file\")\n\ndef test_load_local_products_file_not_found(mock_logger):\n    \"\"\"\n    Test _load_local_products when the JSON file does not exist.\n    It should log an error and return fallback products.\n    \"\"\"\n    # Mock Path.exists to return False, and mock Path constructor to return a mock object\n    with patch('app.services.local_product_service.Path.exists', return_value=False), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback, \\\n         patch('app.services.local_product_service.Path') as MockPath:\n        \n        # Configure MockPath to simulate the file path construction\n        mock_file_path = MagicMock(spec=Path) # Use spec=Path to ensure Path methods exist\n        # This mocks the entire path construction: Path(__file__).parent.parent.parent / \"data\" / \"products.json\"\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n        \n        # Create an instance to call the internal method\n        # Note: We need a real instance to call _load_local_products, not a mock of the class.\n        service = LocalProductService() \n        result = service._load_local_products()\n        \n        mock_logger.error.assert_called_once()\n        assert \"Products JSON file not found at:\" in mock_logger.error.call_args[0][0]\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value # Ensure fallback products are returned\n\ndef test_load_local_products_valid_json_utf8(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid UTF-8 JSON file.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000): # Mock random.randint for predictable sold count\n        \n        # Simulate the Path resolution\n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        # Create an instance to call the internal method\n        service = LocalProductService() \n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        # Compare to the TRANSFORMED_MOCK_PRODUCTS_DATA\n        assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-8 encoding\")\n        \n        # Verify that open was called with utf-8 encoding (and potentially others if previous ones failed)\n        # It's important to check the *last* successful call's encoding.\n        assert builtins.open.call_args.kwargs['encoding'] == 'utf-8'\n\ndef test_load_local_products_valid_json_utf16le_with_bom(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid UTF-16-LE JSON file containing a BOM.\n    \"\"\"\n    mock_json_content_str = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n    \n    # Define a side_effect function for mock_open to control encoding attempts\n    # This simulates trying encodings in order and one succeeding.\n    def open_side_effect(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        if encoding == 'utf-16-le':\n            # This simulates reading a file that *was* UTF-16-LE with BOM,\n            # and `file.read()` returns the decoded string (which still has the BOM char at start).\n            m_file.read.return_value = '\\ufeff' + mock_json_content_str\n        elif encoding == 'utf-16': # Make it fail so utf-16-le is tested\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason for utf-16\")\n        else:\n            # For other encodings, return content that will cause JSONDecodeError\n            # (they shouldn't be reached if utf-16-le succeeds)\n            m_file.read.return_value = \"invalid json\"\n        return m_file\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect), \\\n         patch('random.randint', return_value=1000):\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        \n        # Verify open was called with 'utf-16-le' and succeeded, and it was the first attempt.\n        assert builtins.open.call_args_list[0].kwargs['encoding'] == 'utf-16-le'\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-16-le encoding\")\n        mock_logger.warning.assert_not_called() # No warnings if first attempt succeeds\n\ndef test_load_local_products_valid_json_utf8_sig_succeeds_after_utf8_fails(mock_logger):\n    \"\"\"\n    Test _load_local_products where utf-8 fails with UnicodeDecodeError, but utf-8-sig succeeds.\n    \"\"\"\n    mock_json_content_str = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    def open_side_effect(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        if encoding == 'utf-16-le':\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason for utf-16-le\")\n        elif encoding == 'utf-16':\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason for utf-16\")\n        elif encoding == 'utf-8':\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason for utf-8\")\n        elif encoding == 'utf-8-sig': # This one succeeds\n            m_file.read.return_value = '\\ufeff' + mock_json_content_str # Simulate BOM for utf-8-sig\n            return m_file\n        else:\n            pytest.fail(f\"Open called with unexpected encoding: {encoding}\")\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect), \\\n         patch('random.randint', return_value=1000):\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService() \n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        \n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-8-sig encoding\")\n        # Verify warnings for previous failed attempts\n        mock_logger.warning.assert_any_call(f\"Failed to load with utf-16-le encoding: mockcodec: mock reason for utf-16-le\")\n        mock_logger.warning.assert_any_call(f\"Failed to load with utf-16 encoding: mockcodec: mock reason for utf-16\")\n        mock_logger.warning.assert_any_call(f\"Failed to load with utf-8 encoding: mockcodec: mock reason for utf-8\")\n        \n        # Verify `open` calls order and count\n        assert builtins.open.call_count == 4\n        assert builtins.open.call_args_list[0].kwargs['encoding'] == 'utf-16-le'\n        assert builtins.open.call_args_list[1].kwargs['encoding'] == 'utf-16'\n        assert builtins.open.call_args_list[2].kwargs['encoding'] == 'utf-8'\n        assert builtins.open.call_args_list[3].kwargs['encoding'] == 'utf-8-sig'\n\ndef test_load_local_products_valid_json_latin1_succeeds_after_others_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products where earlier encodings fail, but latin-1 succeeds.\n    \"\"\"\n    mock_json_content_str = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    def open_side_effect(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        if encoding in ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig']:\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, f\"mock reason for {encoding}\")\n        elif encoding == 'latin-1': # This one succeeds\n            m_file.read.return_value = mock_json_content_str\n            return m_file\n        else:\n            pytest.fail(f\"Open called with unexpected encoding: {encoding}\")\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect), \\\n         patch('random.randint', return_value=1000):\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService() \n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        \n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using latin-1 encoding\")\n        # Verify warnings for previous failed attempts\n        assert mock_logger.warning.call_count == 4\n        assert any(f\"Failed to load with {e} encoding\" in call_args[0][0] for e in ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig'] for call_args in mock_logger.warning.call_args_list)\n        \n        # Verify `open` calls order and count\n        assert builtins.open.call_count == 5\n        assert builtins.open.call_args_list[4].kwargs['encoding'] == 'latin-1'\n\n\ndef test_load_local_products_invalid_json_all_encodings_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products when the JSON content is invalid for all encoding attempts.\n    It should log warnings and return fallback products.\n    \"\"\"\n    invalid_json_content = \"this is not json {\"\n    \n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Configure mock_open to always return invalid content, causing JSONDecodeError\n    def open_side_effect_invalid_json(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        m_file.read.return_value = invalid_json_content\n        return m_file\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect_invalid_json), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        # Check that warnings were logged for each encoding attempt\n        encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n        for encoding in encodings:\n            mock_logger.warning.assert_any_call(f\"Failed to load with {encoding} encoding: json.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\")\n        \n        mock_logger.error.assert_called_with(\"All encoding attempts failed, using fallback products\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n        assert builtins.open.call_count == len(encodings)\n\n\ndef test_load_local_products_unicode_decode_error_all_encodings_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products when all encoding attempts result in UnicodeDecodeError.\n    It should log warnings and return fallback products.\n    \"\"\"\n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Create a mock for builtins.open that always raises UnicodeDecodeError\n    def mock_open_side_effect(file_path_arg, mode, encoding):\n        raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason\")\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=mock_open_side_effect), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        # Check that warnings were logged for each encoding attempt\n        encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n        for encoding in encodings:\n            mock_logger.warning.assert_any_call(f\"Failed to load with {encoding} encoding: mockcodec: mock reason\")\n        \n        mock_logger.error.assert_called_with(\"All encoding attempts failed, using fallback products\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n        assert builtins.open.call_count == len(encodings)\n\ndef test_load_local_products_generic_exception(mock_logger):\n    \"\"\"\n    Test _load_local_products when a generic exception occurs (e.g., during file reading or JSON parsing).\n    It should log an error and return fallback products.\n    \"\"\"\n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=IOError(\"Mock IO Error\")), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        mock_logger.error.assert_called_with(\"Error loading products from JSON file: Mock IO Error\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n        assert builtins.open.call_count == 1 # Only one call before IOError\n\ndef test_load_local_products_empty_products_list_in_json(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file but an empty 'products' list.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": []}) # Empty products list\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_json_missing_products_key(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file but missing the 'products' key.\n    \"\"\"\n    mock_json_content = json.dumps({\"some_other_key\": \"value\"}) # Missing 'products' key\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0 # Should fallback to empty list due to .get('products', [])\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_json_products_key_not_list(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file where 'products' key is not a list.\n    Should result in an empty list after .get('products', []).\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": \"not_a_list\"}) # 'products' key exists but is not a list\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0 # Should fallback to empty list due to .get('products', [])\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_transformation_minimal_fields(mock_logger):\n    \"\"\"\n    Test _load_local_products transformation with a product having only minimal fields.\n    Ensures default values are correctly applied.\n    \"\"\"\n    minimal_product_raw = {\n        \"id\": \"minimal_prod\",\n        \"name\": \"Minimal Product\",\n        \"description\": \"This product has minimal details.\"\n    }\n    expected_transformed = {\n        \"id\": \"minimal_prod\",\n        \"name\": \"Minimal Product\",\n        \"category\": \"\",\n        \"brand\": \"\",\n        \"price\": 0,\n        \"currency\": \"IDR\",\n        \"description\": \"This product has minimal details.\",\n        \"specifications\": {\n            \"rating\": 0,\n            \"sold\": 1000, # Mocked random.randint value\n            \"stock\": 0,\n            \"condition\": \"Baru\",\n            \"shop_location\": \"Indonesia\",\n            \"shop_name\": \"Unknown Store\",\n        },\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 0,\n        \"images\": [\"https://example.com/minimal_prod.jpg\"],\n        \"url\": \"https://shopee.co.id/minimal_prod\"\n    }\n    mock_json_content = json.dumps({\"products\": [minimal_product_raw]})\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 1\n        assert products[0] == expected_transformed\n\ndef test_load_local_products_transformation_with_extra_spec_fields(mock_logger):\n    \"\"\"\n    Test _load_local_products transformation ensures extra fields in 'specifications' are preserved.\n    \"\"\"\n    product_with_custom_specs_raw = {\n        \"id\": \"custom_spec_prod\",\n        \"name\": \"Product with Custom Specs\",\n        \"specifications\": {\n            \"rating\": 4.2,\n            \"stock_count\": 70,\n            \"custom_field\": \"custom_value\",\n            \"another_custom\": True,\n        },\n        \"brand\": \"CustomBrand\"\n    }\n    expected_transformed_spec = {\n        \"rating\": 4.2,\n        \"sold\": 1000,\n        \"stock\": 70,\n        \"condition\": \"Baru\",\n        \"shop_location\": \"Indonesia\",\n        \"shop_name\": \"CustomBrand Store\",\n        \"custom_field\": \"custom_value\",\n        \"another_custom\": True,\n    }\n    mock_json_content = json.dumps({\"products\": [product_with_custom_specs_raw]})\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 1\n        assert products[0]['id'] == 'custom_spec_prod'\n        assert products[0]['specifications'] == expected_transformed_spec\n\ndef test_load_local_products_transformation_product_not_dict_causes_error(mock_logger):\n    \"\"\"\n    Test _load_local_products when a product entry in the JSON list is not a dictionary.\n    This should cause an AttributeError during transformation and be caught by the general exception handler.\n    \"\"\"\n    malformed_products_raw = [\n        MOCK_PRODUCTS_RAW_FOR_JSON[0],\n        \"this is not a product dict\", # Malformed entry\n        MOCK_PRODUCTS_RAW_FOR_JSON[1]\n    ]\n    mock_json_content = json.dumps({\"products\": malformed_products_raw})\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        # The transformation loop will try to call .get() on a string, which raises AttributeError.\n        # This will be caught by the outer 'except Exception as e:'.\n        mock_logger.error.assert_called_once()\n        assert \"Error loading products from JSON file: 'str' object has no attribute 'get'\" in mock_logger.error.call_args[0][0]\n        mock_fallback.assert_called_once()\n        assert products == mock_fallback.return_value\n\ndef test_load_local_products_first_encoding_succeeds_others_not_tried(mock_logger):\n    \"\"\"\n    Test that once an encoding succeeds, no further encoding attempts are made.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": MOCK_PRODUCTS_RAW_FOR_JSON})\n    \n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Simulate utf-8 succeeding immediately\n    def open_side_effect(file_path_arg, mode, encoding):\n        if encoding == 'utf-16-le': # First attempt, fail\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason\")\n        elif encoding == 'utf-16': # Second attempt, fail\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason\")\n        elif encoding == 'utf-8': # Third attempt, succeed\n            m_file = MagicMock()\n            m_file.read.return_value = mock_json_content\n            return m_file\n        else: # Should not be called\n            pytest.fail(f\"Open called with unexpected encoding: {encoding}\")\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect), \\\n         patch('random.randint', return_value=1000):\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService() \n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_any_call(\"Failed to load with utf-16-le encoding: mockcodec: mock reason\")\n        mock_logger.warning.assert_any_call(\"Failed to load with utf-16 encoding: mockcodec: mock reason\")\n        assert mock_logger.warning.call_count == 2\n        \n        # Verify open was called exactly 3 times (utf-16-le, utf-16, utf-8)\n        assert builtins.open.call_count == 3\n        assert builtins.open.call_args_list[0].kwargs['encoding'] == 'utf-16-le'\n        assert builtins.open.call_args_list[1].kwargs['encoding'] == 'utf-16'\n        assert builtins.open.call_args_list[2].kwargs['encoding'] == 'utf-8'\n\n\ndef test_get_fallback_products(mock_logger):\n    \"\"\"\n    Test the _get_fallback_products method directly.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service._get_fallback_products()\n        \n        assert isinstance(products, list)\n        assert len(products) == 8 # Fallback products list should contain 8 items\n        assert \"iPhone 15 Pro Max\" in [p['name'] for p in products]\n        mock_logger.warning.assert_called_once_with(\"Using fallback products due to JSON file loading error\")\n\n# --- Tests for search_products and _extract_price_from_keyword ---\n\ndef test_search_products_basic_keyword_match(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a basic keyword matching product names/descriptions.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product a\")\n    assert len(results) == 2 # Product A and Product B (due to 'Product A related.')\n    assert results[0]['id'] == 'prod1' # Should be ranked higher due to exact name match\n\ndef test_search_products_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with case-insensitive keyword.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product b\")\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod2'\n\ndef test_search_products_no_match(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a keyword that doesn't match any product.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"nonexistent product\")\n    assert len(results) == 0\n\ndef test_search_products_with_limit(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a limit parameter.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product\", limit=1)\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod1' # First ranked product (Product A)\n\ndef test_search_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product\", limit=0)\n    assert len(results) == 0\n\ndef test_search_products_keyword_in_category_brand_specs(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products finding keywords in category, brand, and specifications.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"BrandY\") # Product B, Product F\n    assert len(results) == 2\n    assert 'prod2' in [p['id'] for p in results]\n    assert 'prod6' in [p['id'] for p in results]\n    \n    results = service.search_products(\"Category3\") # Product D\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod4'\n\n    results = service.search_products(\"value1\") # Product A (extra_spec: value1)\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod1'\n\ndef test_search_products_price_extraction_juta(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"juta\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 1 juta\") # Should include products <= 1,000,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5', 'prod8', 'prod7'} # Product D, F are > 1 juta\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 1000000 for p in results)\n    \n    # Check sorting for relevance with price filter\n    # Prod1, prod2, prod3, prod5 contain \"product\" in name/desc. prod7, prod8 don't.\n    # Among prod1,prod2,prod3,prod5, prod1 has highest score due to \"Product A\" exact match\n    assert results[0]['id'] == 'prod1' # \"Product A\" match\n    \n    # After Prod1, Prod2, Prod3, Prod5.prod7 (price 0) and prod3 (price 50k) would be high due to budget score.\n    # The order of products with same score is stable but not guaranteed based on attributes.\n\ndef test_search_products_price_extraction_ribu(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"ribu\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 200 ribu\") # Should include products <= 200,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5', 'prod7'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 200000 for p in results)\n\ndef test_search_products_price_extraction_rp(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"Rp X\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product Rp 150000\")\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod3', 'prod5', 'prod7'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 150000 for p in results)\n\ndef test_search_products_price_extraction_k_m(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"Xk\", \"Xm\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 300k\") # Should include products <= 300,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5', 'prod7'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 300000 for p in results)\n\n    results = service.search_products(\"gadget 5M\") # Should include products <= 5,000,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod4', 'prod5', 'prod6', 'prod7', 'prod8'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 5000000 for p in results)\n\ndef test_search_products_price_extraction_budget_keyword(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a budget keyword (e.g., \"murah\").\n    The 'murah' keyword itself affects the relevance score by adding a price preference.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"gadget murah\") \n    # 'murah' corresponds to 5_000_000 max_price.\n    # Prod4 contains 'gadget' in description.\n    # All products have price <= 5M.\n    # Sorting by relevance: score based on keyword match + price preference.\n    \n    # We expect 'prod4' (gadget match) and 'prod7', 'prod3' (cheapest) to be among top results.\n    # Exact ordering can depend on tie-breaking in sort, so we check for presence among top.\n    \n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod4', 'prod5', 'prod6', 'prod7', 'prod8'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 5000000 for p in results)\n\n    # Specific check for top elements to reflect sorting by relevance\n    # Prod4 has keyword \"gadget\" and is within budget.\n    # Prod7 and Prod3 are very cheap, giving them high budget score.\n    top_ids = {p['id'] for p in results[:3]}\n    assert 'prod4' in top_ids\n    assert 'prod7' in top_ids\n    assert 'prod3' in top_ids\n\ndef test_search_products_price_and_keyword_combined_without_budget_keyword(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a numerical price limit and a keyword,\n    ensuring price filtering applies and sorting is by relevance (keyword first).\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"Product A 100 ribu\") # Max price 100,000\n    \n    assert len(results) == 2 # Only prod1 (price 100k) and prod7 (price 0) should match price\n    \n    # Both 'prod1' (100k) and 'prod7' (0k) are <= 100k.\n    # 'prod1' has \"Product A\" in name (score 10). 'prod7' has no relevant keyword match.\n    assert results[0]['id'] == 'prod1' # Higher relevance score due to keyword\n    assert results[1]['id'] == 'prod7' # Lower relevance score, only price match\n\n\ndef test_search_products_relevance_sorting_exact_match(mock_local_product_service_instance):\n    \"\"\"\n    Verify that exact name matches give higher relevance scores.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"good\") # Prod1 ('good product'), Prod3 ('Very good')\n\n    assert len(results) == 2\n    # The order depends on how 'good' exactly matches. 'Very good' and 'A very good product'\n    # Prod1 description: \"Description A. A very good product.\"\n    # Prod3 description: \"Cheapest product, high quality. Very good.\"\n    # Both should get score from description match. Prod3 also has rating 4.9.\n    # The default tie-breaking is stable. Let's just check both are present.\n    assert {p['id'] for p in results} == {'prod1', 'prod3'}\n    # The order might not be strictly predictable without more refined scoring or tie-breaking logic.\n    # For now, asserting presence is sufficient.\n\ndef test_search_products_relevance_sorting_budget_preference(mock_local_product_service_instance):\n    \"\"\"\n    Verify that for budget searches, lower priced items get a higher relevance score.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product murah\") # \"murah\" implies max_price 5M, and activates budget scoring\n    \n    # All products have \"Product\" in name/description.\n    # They all get +10 or so for 'product' keyword match.\n    # Then budget score is added: (10M - price) / 1M.\n    # Prod7 (price 0) should get a huge boost: (10M - 0) / 1M = 10.\n    # Prod3 (price 50k) should get a high boost: (10M - 50k) / 1M = 9.95.\n    # Prod1 (price 100k) should get: (10M - 100k) / 1M = 9.9.\n    \n    assert len(results) == len(TRANSFORMED_MOCK_PRODUCTS_DATA) # All products match \"product\" and are <= 5M\n    assert results[0]['id'] == 'prod7' # Cheapest, highest budget score\n    assert results[1]['id'] == 'prod3' # Second cheapest\n    assert results[2]['id'] == 'prod1' # Third cheapest (among those matching 'product')\n\ndef test_search_products_empty_keyword(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with an empty keyword. Should return products up to limit, in default order (which is based on the internal list order).\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"\", limit=3)\n    assert len(results) == 3\n    # When keyword is empty, the `if keyword_lower in searchable_text` condition is essentially always true.\n    # All products get added to `filtered_products`.\n    # The relevance_score function for empty keyword_lower will just be based on price if budget keyword is present,\n    # otherwise it will be 0 for all, and the order will be original list order due to stable sort.\n    # In this case, no budget keyword, so order should be original.\n    assert results[0]['id'] == 'prod1'\n    assert results[1]['id'] == 'prod2'\n    assert results[2]['id'] == 'prod3'\n\n\ndef test_search_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in search_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Simulate an error by modifying products list to cause an exception during iteration or access\n    with patch.object(service, 'products', new=[{'id': 'bad_data', 'price': 'invalid'}]):\n        results = service.search_products(\"test\")\n        assert results == []\n        mock_logger.error.assert_called_once()\n        assert \"Error searching products:\" in mock_logger.error.call_args[0][0]\n\ndef test_extract_price_from_keyword_juta():\n    service = LocalProductService() # No need for mocked products for this method\n    assert service._extract_price_from_keyword(\"harga 2 juta\") == 2000000\n    assert service._extract_price_from_keyword(\"10 juta\") == 10000000\n    assert service._extract_price_from_keyword(\"5.5 juta\") is None # Only integer part extracted by regex\n    assert service._extract_price_from_keyword(\"2Juta\") == 2000000 # Case insensitive\n\ndef test_extract_price_from_keyword_ribu():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"maksimal 500 ribu\") == 500000\n    assert service._extract_price_from_keyword(\"Rp 100 ribu\") == 100000\n    assert service._extract_price_from_keyword(\"250Ribu\") == 250000 # Case insensitive\n\ndef test_extract_price_from_keyword_rp():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"rp 250000\") == 250000\n    assert service._extract_price_from_keyword(\"150000 rp\") == 150000\n    assert service._extract_price_from_keyword(\"RP. 500000\") == 500000 # Test with dot and different casing\n\ndef test_extract_price_from_keyword_k_m():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"300k\") == 300000\n    assert service._extract_price_from_keyword(\"5m\") == 5000000\n    assert service._extract_price_from_keyword(\"2.5m\") is None # Only integer part extracted by regex\n    assert service._extract_price_from_keyword(\"10K\") == 10000 # Case insensitive\n\ndef test_extract_price_from_keyword_budget_keywords():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"hp murah\") == 5000000\n    assert service._extract_price_from_keyword(\"laptop budget\") == 5000000\n    assert service._extract_price_from_keyword(\"headset hemat\") == 3000000\n    assert service._extract_price_from_keyword(\"monitor terjangkau\") == 4000000\n    assert service._extract_price_from_keyword(\"mouse ekonomis\") == 2000000\n    assert service._extract_price_from_keyword(\"Harga Murah Banget\") == 5000000 # Multiple words\n\ndef test_extract_price_from_keyword_no_match():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"no price here\") is None\n    assert service._extract_price_from_keyword(\"just a keyword\") is None\n    assert service._extract_price_from_keyword(\"10 dolar\") is None # Unrecognized currency\n\ndef test_extract_price_from_keyword_multiple_patterns_first_match_wins():\n    service = LocalProductService()\n    # \"1 juta\" comes first in regex patterns than \"murah\" keyword.\n    assert service._extract_price_from_keyword(\"laptop 1 juta murah\") == 1000000\n    # \"500 ribu\" is parsed by regex before \"hemat\" keyword.\n    assert service._extract_price_from_keyword(\"mouse 500 ribu hemat\") == 500000\n    # \"rp 20000\" should match before \"murah\"\n    assert service._extract_price_from_keyword(\"hp rp 20000 murah\") == 20000\n\ndef test_extract_price_from_keyword_error_handling(mock_logger):\n    service = LocalProductService()\n    with patch('re.search', side_effect=Exception(\"Regex error\")):\n        assert service._extract_price_from_keyword(\"1 juta\") is None\n        mock_logger.error.assert_called_once()\n        assert \"Error extracting price from keyword:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for get_product_details, get_categories, get_brands ---\n\ndef test_get_product_details_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving details for an existing product ID.\n    \"\"\"\n    service = mock_local_product_service_instance\n    product = service.get_product_details(\"prod1\")\n    assert product is not None\n    assert product['id'] == 'prod1'\n    assert product['name'] == 'Product A'\n\ndef test_get_product_details_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving details for a non-existent product ID.\n    \"\"\"\n    service = mock_local_product_service_instance\n    product = service.get_product_details(\"nonexistent_id\")\n    assert product is None\n\ndef test_get_product_details_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_product_details when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        product = service.get_product_details(\"prod1\")\n        assert product is None\n        mock_logger.error.assert_not_called() # No error should be logged\n\ndef test_get_product_details_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_product_details.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Simulate an error by making products attribute raise an exception on access\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        product = service.get_product_details(\"prod1\")\n        assert product is None\n        mock_logger.error.assert_called_once()\n        assert \"Error getting product details:\" in mock_logger.error.call_args[0][0]\n\n\ndef test_get_categories(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving unique product categories.\n    \"\"\"\n    service = mock_local_product_service_instance\n    categories = service.get_categories()\n    assert sorted(categories) == sorted(['Category1', 'Category2', 'Category3', 'Electronics', '']) # '' for prod7, prod8 missing category\n\ndef test_get_categories_empty_products_list():\n    \"\"\"\n    Test get_categories when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        categories = service.get_categories()\n        assert categories == []\n\ndef test_get_categories_with_missing_category_key():\n    \"\"\"\n    Test get_categories when some products are missing the 'category' key.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    products_with_missing_cat = [\n        {\"id\": \"1\", \"name\": \"ProdA\", \"category\": \"Cat1\"},\n        {\"id\": \"2\", \"name\": \"ProdB\"}, # Missing category\n        {\"id\": \"3\", \"name\": \"ProdC\", \"category\": \"Cat2\"},\n    ]\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_cat):\n        service = LocalProductService()\n        categories = service.get_categories()\n        # An empty string is added if 'category' is missing, then sorted\n        assert sorted(categories) == ['', 'Cat1', 'Cat2']\n\ndef test_get_brands(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving unique product brands.\n    \"\"\"\n    service = mock_local_product_service_instance\n    brands = service.get_brands()\n    assert sorted(brands) == sorted(['BrandX', 'BrandY', 'BrandZ', 'CustomBrand', '']) # '' for prod7, prod8 missing brand\n\ndef test_get_brands_empty_products_list():\n    \"\"\"\n    Test get_brands when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        brands = service.get_brands()\n        assert brands == []\n\ndef test_get_brands_with_missing_brand_key():\n    \"\"\"\n    Test get_brands when some products are missing the 'brand' key.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    products_with_missing_brand = [\n        {\"id\": \"1\", \"name\": \"ProdA\", \"brand\": \"Brand1\"},\n        {\"id\": \"2\", \"name\": \"ProdB\"}, # Missing brand\n        {\"id\": \"3\", \"name\": \"ProdC\", \"brand\": \"Brand2\"},\n    ]\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_brand):\n        service = LocalProductService()\n        brands = service.get_brands()\n        # An empty string is added if 'brand' is missing, then sorted\n        assert sorted(brands) == ['', 'Brand1', 'Brand2']\n\n# --- Tests for get_products_by_category/brand ---\n\ndef test_get_products_by_category_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by an existing category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"Category1\")\n    assert len(products) == 3\n    assert all(p['category'] == 'Category1' for p in products)\n    assert {'prod1', 'prod3', 'prod5'} == {p['id'] for p in products}\n\ndef test_get_products_by_category_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by category with case-insensitivity.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"category1\")\n    assert len(products) == 3\n    assert all(p['category'] == 'Category1' for p in products)\n\ndef test_get_products_by_category_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by a non-existent category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"NonExistentCategory\")\n    assert products == []\n\ndef test_get_products_by_category_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products_by_category when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products_by_category(\"Category1\")\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_by_category_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products_by_category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        products = service.get_products_by_category(\"Category1\")\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products by category:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_products_by_brand_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by an existing brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"BrandX\")\n    assert len(products) == 3\n    assert all(p['brand'] == 'BrandX' for p in products)\n    assert {'prod1', 'prod3', 'prod5'} == {p['id'] for p in products}\n\ndef test_get_products_by_brand_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by brand with case-insensitivity.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"brandx\")\n    assert len(products) == 3\n    assert all(p['brand'] == 'BrandX' for p in products)\n\ndef test_get_products_by_brand_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by a non-existent brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"NonExistentBrand\")\n    assert products == []\n\ndef test_get_products_by_brand_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products_by_brand when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products_by_brand(\"BrandX\")\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_by_brand_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products_by_brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        products = service.get_products_by_brand(\"BrandX\")\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products by brand:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for get_top_rated_products, get_best_selling_products, get_products ---\n\ndef test_get_top_rated_products(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving top-rated products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=3)\n    assert len(products) == 3\n    # Based on TRANSFORMED_MOCK_PRODUCTS_DATA ratings:\n    # prod3 (4.9), prod5 (4.6), prod1 (4.5), prod8 (4.2), prod4 (4.0), prod2 (3.8), prod6 (3.0), prod7 (0)\n    assert products[0]['id'] == 'prod3'\n    assert products[1]['id'] == 'prod5'\n    assert products[2]['id'] == 'prod1'\n\ndef test_get_top_rated_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_top_rated_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    # Still sorted by rating\n    assert products[0]['id'] == 'prod3'\n\ndef test_get_top_rated_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test get_top_rated_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=0)\n    assert len(products) == 0\n\ndef test_get_top_rated_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_top_rated_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_top_rated_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_top_rated_products_with_missing_rating_key():\n    \"\"\"\n    Test get_top_rated_products when some products are missing the 'rating' key.\n    \"\"\"\n    products_with_missing_rating = [\n        {\"id\": \"1\", \"specifications\": {\"rating\": 5.0}},\n        {\"id\": \"2\", \"specifications\": {}}, # Missing rating (defaults to 0)\n        {\"id\": \"3\", \"specifications\": {\"rating\": 4.0}},\n        {\"id\": \"4\"}, # Missing 'specifications' dict entirely (defaults to 0 rating)\n    ]\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_rating):\n        service = LocalProductService()\n        products = service.get_top_rated_products(limit=3)\n        assert len(products) == 3\n        # Products with missing rating should default to 0 and be at the bottom\n        assert products[0]['id'] == '1' # Rating 5.0\n        assert products[1]['id'] == '3' # Rating 4.0\n        # The third product should be either '2' or '4' (both have 0 rating). Order depends on stable sort.\n        assert products[2]['id'] in {'2', '4'}\n\ndef test_get_top_rated_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_top_rated_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"Sorting error\"))):\n        products = service.get_top_rated_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting top rated products:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_best_selling_products(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test retrieving best-selling products.\n    Since `random.randint` is mocked in the fixture, all products in `service.products`\n    will have a 'sold' count of 1000. To properly test sorting by 'sold' for\n    `get_best_selling_products`, we temporarily override `service.products` with\n    a list where 'sold' values are varied.\n    \"\"\"\n    products_for_sold_test = [\n        dict(p, specifications=dict(p['specifications'], sold=p['specifications'].get('sold', 0)))\n        for p in TRANSFORMED_MOCK_PRODUCTS_DATA # Start with base transformed data\n    ]\n    # Manually adjust 'sold' values for deterministic testing of sorting by 'sold'\n    for p in products_for_sold_test:\n        if p['id'] == 'prod5': p['specifications']['sold'] = 15000 # Highest\n        elif p['id'] == 'prod3': p['specifications']['sold'] = 1200 # Second highest\n        elif p['id'] == 'prod1': p['specifications']['sold'] = 500 # Third highest\n        elif p['id'] == 'prod2': p['specifications']['sold'] = 300\n        elif p['id'] == 'prod4': p['specifications']['sold'] = 100\n        elif p['id'] == 'prod6': p['specifications']['sold'] = 50\n        elif p['id'] == 'prod7': p['specifications']['sold'] = 10 # Lowest\n        elif p['id'] == 'prod8': p['specifications']['sold'] = 200 # In between\n\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', products_for_sold_test):\n        products = service.get_best_selling_products(limit=3)\n        assert len(products) == 3\n        # Expected order based on adjusted sold counts\n        assert products[0]['id'] == 'prod5' # sold=15000\n        assert products[1]['id'] == 'prod3' # sold=1200\n        assert products[2]['id'] == 'prod1' # sold=500\n        mock_logger.info.assert_any_call(\"Getting best selling products, limit: 3\")\n        mock_logger.info.assert_any_call(\"Returning 3 best selling products\")\n\ndef test_get_best_selling_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_best_selling_products when limit is greater than available products.\n    \"\"\"\n    products_for_sold_test = [\n        dict(p, specifications=dict(p['specifications'], sold=p['specifications'].get('sold', 0)))\n        for p in TRANSFORMED_MOCK_PRODUCTS_DATA\n    ]\n    for p in products_for_sold_test:\n        if p['id'] == 'prod5': p['specifications']['sold'] = 15000\n        elif p['id'] == 'prod3': p['specifications']['sold'] = 1200\n        elif p['id'] == 'prod1': p['specifications']['sold'] = 500\n        elif p['id'] == 'prod2': p['specifications']['sold'] = 300\n        elif p['id'] == 'prod4': p['specifications']['sold'] = 100\n        elif p['id'] == 'prod6': p['specifications']['sold'] = 50\n        elif p['id'] == 'prod7': p['specifications']['sold'] = 10\n        elif p['id'] == 'prod8': p['specifications']['sold'] = 200\n\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', products_for_sold_test):\n        products = service.get_best_selling_products(limit=100)\n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        # Still sorted by sold count\n        assert products[0]['id'] == 'prod5'\n\ndef test_get_best_selling_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test get_best_selling_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_best_selling_products(limit=0)\n    assert len(products) == 0\n\ndef test_get_best_selling_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_best_selling_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_best_selling_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_best_selling_products_with_missing_sold_key():\n    \"\"\"\n    Test get_best_selling_products when some products are missing the 'sold' key.\n    \"\"\"\n    products_with_missing_sold = [\n        {\"id\": \"1\", \"specifications\": {\"sold\": 1000}},\n        {\"id\": \"2\", \"specifications\": {}}, # Missing sold (defaults to 0)\n        {\"id\": \"3\", \"specifications\": {\"sold\": 500}},\n        {\"id\": \"4\"}, # Missing 'specifications' dict entirely (defaults to 0 sold)\n    ]\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_sold):\n        service = LocalProductService()\n        products = service.get_best_selling_products(limit=3)\n        assert len(products) == 3\n        # Products with missing sold should default to 0 and be at the bottom\n        assert products[0]['id'] == '1' # Sold 1000\n        assert products[1]['id'] == '3' # Sold 500\n        # The third product should be either '2' or '4' (both have 0 sold). Order depends on stable sort.\n        assert products[2]['id'] in {'2', '4'}\n\ndef test_get_best_selling_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_best_selling_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"Sorting error\"))):\n        products = service.get_best_selling_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting best selling products:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_products(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test retrieving all products with a limit.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=3)\n    assert len(products) == 3\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA[:3]\n    mock_logger.info.assert_any_call(\"Getting all products, limit: 3\")\n\ndef test_get_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n\ndef test_get_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test get_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=0)\n    assert len(products) == 0\n\ndef test_get_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List slicing error\"))):\n        products = service.get_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for smart_search_products ---\n\ndef test_smart_search_products_best_request_general(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for general \"terbaik\" request.\n    Should return top-rated products overall.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik\", limit=2)\n    assert len(products) == 2\n    # Based on TRANSFORMED_MOCK_PRODUCTS_DATA ratings: prod3 (4.9), prod5 (4.6)\n    assert products[0]['id'] == 'prod3' \n    assert products[1]['id'] == 'prod5' \n    assert message == \"Berikut produk terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_best_request_english_keyword(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for general \"best\" request (English keyword).\n    Should return top-rated products overall.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"best\", limit=2)\n    assert len(products) == 2\n    assert products[0]['id'] == 'prod3' \n    assert products[1]['id'] == 'prod5' \n    assert message == \"Berikut produk terbaik berdasarkan rating:\"\n\n\ndef test_smart_search_products_best_request_specific_category_found(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for \"terbaik\" request within a specific category that exists.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik Category1\", category=\"Category1\", limit=2)\n    assert len(products) == 2\n    # Products in Category1: prod1 (4.5), prod3 (4.9), prod5 (4.6)\n    assert products[0]['id'] == 'prod3' \n    assert products[1]['id'] == 'prod5' \n    assert message == \"Berikut Category1 terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_best_request_specific_category_not_found_fallback(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for \"terbaik\" request within a non-existent category.\n    Should fallback to general top-rated products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik NonExistent\", category=\"NonExistent\", limit=2)\n    assert len(products) == 2\n    assert products[0]['id'] == 'prod3' # Rating 4.9 (general best)\n    assert products[1]['id'] == 'prod5' # Rating 4.6 (general best)\n    assert message == \"Tidak ada produk kategori NonExistent, berikut produk terbaik secara umum:\"\n\ndef test_smart_search_products_all_criteria_match(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products where keyword, category, and max_price all match.\n    The primary search path should be taken.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"Product A\", category=\"Category1\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Products matching: prod1 (100k, Category1), prod5 (150k, Category1)\n    # The internal search algorithm will filter first, then sort by relevance.\n    # Keyword \"Product A\" matches prod1.\n    expected_ids = {'prod1', 'prod5'}\n    actual_ids = {p['id'] for p in products}\n    assert actual_ids == expected_ids\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_no_exact_match_fallback_to_category(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when initial search has no results, but category match is found.\n    Should sort by price within category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # \"NonExistingKeyword\" will not match, but \"Category2\" will. Max_price too low for initial match.\n    products, message = service.smart_search_products(keyword=\"NonExistingKeyword\", category=\"Category2\", max_price=50000, limit=2)\n    assert len(products) == 2\n    # Products in Category2: prod2 (200k), prod6 (4M). Sorted by price: prod2, prod6\n    assert products[0]['id'] == 'prod2' # Cheapest in Category2\n    assert products[1]['id'] == 'prod6' # Next cheapest in Category2\n    assert message == \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\ndef test_smart_search_products_no_category_match_fallback_to_budget(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when no exact match and no category match, but budget match is found.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # \"NonExistingKeyword\" and \"NonExistingCategory\" won't match. max_price will.\n    products, message = service.smart_search_products(keyword=\"NonExistingKeyword\", category=\"NonExistingCategory\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Products within 150k: prod1 (100k), prod3 (50k), prod5 (150k), prod7 (0k)\n    expected_ids_candidates = {'prod1', 'prod3', 'prod5', 'prod7'}\n    actual_ids = {p['id'] for p in products}\n    assert actual_ids.issubset(expected_ids_candidates) and len(actual_ids) == 2\n    assert message == \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\ndef test_smart_search_products_no_match_all_fallbacks_popular(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when no criteria match and all fallbacks lead to no results,\n    should return popular products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Max price 10 will ensure no products match price criteria, and no keywords/categories match.\n    # To test best-selling correctly, we need to inject products with varied 'sold' counts.\n    products_for_sold_test = [\n        dict(p, specifications=dict(p['specifications'], sold=p['specifications'].get('sold', 0)))\n        for p in TRANSFORMED_MOCK_PRODUCTS_DATA\n    ]\n    for p in products_for_sold_test:\n        if p['id'] == 'prod5': p['specifications']['sold'] = 15000\n        elif p['id'] == 'prod3': p['specifications']['sold'] = 1200\n        elif p['id'] == 'prod1': p['specifications']['sold'] = 500\n        elif p['id'] == 'prod2': p['specifications']['sold'] = 300\n        elif p['id'] == 'prod4': p['specifications']['sold'] = 100\n        elif p['id'] == 'prod6': p['specifications']['sold'] = 50\n        elif p['id'] == 'prod7': p['specifications']['sold'] = 10\n        elif p['id'] == 'prod8': p['specifications']['sold'] = 200\n\n    with patch.object(service, 'products', products_for_sold_test):\n        products, message = service.smart_search_products(keyword=\"CompletelyUniqueKeyword\", category=\"UnknownCategory\", max_price=10, limit=2)\n        assert len(products) == 2\n        assert products[0]['id'] == 'prod5' # sold=15000\n        assert products[1]['id'] == 'prod3' # sold=1200\n        assert message == \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\"\n\ndef test_smart_search_products_empty_keyword_only_category(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with empty keyword, only category specified.\n    Should go to the primary search path and filter by category, then return message.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", category=\"Category1\", limit=2)\n    assert len(products) == 2\n    # Should find all products in Category1, limit 2. These are prod1, prod3, prod5.\n    # The actual order might vary based on default sorting if keyword isn't active.\n    # When keyword is empty, and no max_price, score is 0. So original list order applies due to stable sort.\n    # prod1, prod3, prod5 are in Category1. Original order is prod1, then prod3, then prod5.\n    assert products[0]['id'] == 'prod1'\n    assert products[1]['id'] == 'prod3'\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_empty_keyword_only_max_price(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with empty keyword, only max_price specified.\n    Should go to primary search path and filter by price.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Should find products <= 150k: prod1, prod3, prod5, prod7\n    # With empty keyword and max_price, price relevance is active.\n    # prod7 (0k) -> prod3 (50k) -> prod1 (100k) -> prod5 (150k)\n    assert products[0]['id'] == 'prod7'\n    assert products[1]['id'] == 'prod3'\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_empty_all_filters(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with no filters (empty keyword, no category, no max_price).\n    Should default to returning the first `limit` products from the loaded list (primary path).\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", category=None, max_price=None, limit=2)\n    assert len(products) == 2\n    # Should return first `limit` products as all products match empty criteria.\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA[:2]\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_limit_zero(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with a limit of 0.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"Product\", limit=0)\n    assert len(products) == 0\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n    products, message = service.smart_search_products(keyword=\"terbaik\", limit=0)\n    assert len(products) == 0\n    assert message == \"Berikut produk terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_negative_limit(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with a negative limit. Python slicing handles this by returning an empty list.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"Product\", limit=-1)\n    assert len(products) == 0\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\" # Message should still be primary success one\n\ndef test_smart_search_products_no_products_loaded(mock_logger):\n    \"\"\"\n    Test smart_search_products when the internal products list is empty.\n    Should return an empty list and a message indicating no products found.\n    \"\"\"\n    # Create a LocalProductService instance with an empty products list\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products, message = service.smart_search_products(keyword=\"any\", category=\"any\", max_price=100000)\n        assert products == []\n        assert message == \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\"\n        # No error logged, as empty list is a valid state\n        mock_logger.error.assert_not_called()"
    },
    {
      "filepath": "app/services/product_data_service.py",
      "coverage": 20.73,
      "content": "import logging\nfrom typing import List, Dict, Optional\nfrom app.services.local_product_service import LocalProductService\n\nlogger = logging.getLogger(__name__)\n\nclass ProductDataService:\n    \"\"\"\n    Service untuk mengambil data produk dari sumber lokal yang reliable\n    \"\"\"\n    \n    def __init__(self):\n        # Use LocalProductService as primary data source\n        self.local_service = LocalProductService()\n        logger.info(\"ProductDataService initialized with LocalProductService\")\n    \n    async def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Search products using local data\"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            # Use awaitable wrapper for sync method\n            import asyncio\n            loop = asyncio.get_event_loop()\n            products = await loop.run_in_executor(None, self.local_service.search_products, keyword, limit)\n            logger.info(f\"Found {len(products)} products for keyword: {keyword}\")\n            return products\n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    async def get_products(self, limit: int = 20, category: Optional[str] = None, search: Optional[str] = None) -> List[Dict]:\n        \"\"\"Get products with optional filtering\"\"\"\n        try:\n            if search:\n                return await self.search_products(search, limit)\n            elif category:\n                return self.get_products_by_category(category, limit)\n            else:\n                return self.get_all_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return self.local_service.get_products(limit)\n    \n    async def get_categories(self) -> List[str]:\n        \"\"\"Get available categories\"\"\"\n        try:\n            return self.local_service.get_categories()\n        except Exception as e:\n            logger.error(f\"Error getting categories: {str(e)}\")\n            return []\n    \n    async def get_top_rated_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get top rated products\"\"\"\n        try:\n            return self.local_service.get_top_rated_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    async def get_best_selling_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get best selling products\"\"\"\n        try:\n            return self.local_service.get_best_selling_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products_by_category(self, category: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by category\"\"\"\n        try:\n            return self.local_service.get_products_by_category(category)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_all_products(self, limit: int = 20) -> List[Dict]:\n        \"\"\"Get all products\"\"\"\n        try:\n            return self.local_service.get_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting all products: {str(e)}\")\n            return []\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"Get product details by ID\"\"\"\n        try:\n            return self.local_service.get_product_details(product_id)\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"Get available brands\"\"\"\n        try:\n            return self.local_service.get_brands()\n        except Exception as e:\n            logger.error(f\"Error getting brands: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by brand\"\"\"\n        try:\n            return self.local_service.get_products_by_brand(brand)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    async def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: gunakan LocalProductService.smart_search_products secara async.\n        Return: (list produk, pesan)\n        \"\"\"\n        import asyncio\n        loop = asyncio.get_event_loop()\n        products, message = await loop.run_in_executor(\n            None, self.local_service.smart_search_products, keyword, category, max_price, limit\n        )\n        return products, message ",
      "existing_test": "import logging\nimport pytest\nimport asyncio\nfrom unittest.mock import MagicMock, AsyncMock, patch\n\n# Define the path to the module under test for patching purposes\nPRODUCT_DATA_SERVICE_MODULE = 'app.services.product_data_service'\n\n# Define a mock specification for LocalProductService methods\n# This helps ensure that methods called on the mock exist on the real object,\n# preventing silent errors from typos in method names.\nclass MockLocalProductServiceSpec:\n    \"\"\"Specification for mocking LocalProductService methods.\"\"\"\n    def search_products(self, keyword: str, limit: int = 10): pass\n    def get_products(self, limit: int = 20): pass\n    def get_categories(self) -> list: pass\n    def get_top_rated_products(self, limit: int = 10) -> list: pass\n    def get_best_selling_products(self, limit: int = 10) -> list: pass\n    def get_products_by_category(self, category: str) -> list: pass # ProductDataService applies limit by slicing\n    def get_product_details(self, product_id: str): pass\n    def get_brands(self) -> list: pass\n    def get_products_by_brand(self, brand: str) -> list: pass # ProductDataService applies limit by slicing\n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5): pass\n\n\n@pytest.fixture\ndef mock_local_service(mocker):\n    \"\"\"\n    Mocks the LocalProductService that ProductDataService uses.\n    This fixture patches the imported LocalProductService within the target module.\n    \"\"\"\n    # Patch `LocalProductService` as it's imported within `product_data_service.py`\n    mock_lps = mocker.patch(\n        f'{PRODUCT_DATA_SERVICE_MODULE}.LocalProductService',\n        autospec=MockLocalProductServiceSpec # Use autospec to validate method calls\n    ).return_value\n\n    # Set default return values for the mock methods to prevent NoneType errors\n    # for methods that are not specifically configured in a test.\n    mock_lps.get_products_by_category.return_value = []\n    mock_lps.get_products.return_value = []\n    mock_lps.get_product_details.return_value = None\n    mock_lps.get_brands.return_value = []\n    mock_lps.get_products_by_brand.return_value = []\n    mock_lps.get_categories.return_value = []\n    mock_lps.get_top_rated_products.return_value = []\n    mock_lps.get_best_selling_products.return_value = []\n    mock_lps.search_products.return_value = []\n    mock_lps.smart_search_products.return_value = ([], \"\")\n\n    return mock_lps\n\n\n@pytest.fixture\ndef product_data_service(mock_local_service):\n    \"\"\"\n    Provides an instance of ProductDataService with its dependencies mocked.\n    Import is done inside the fixture to ensure the patch is active when the class is defined.\n    \"\"\"\n    # Import ProductDataService after LocalProductService has been patched\n    from app.services.product_data_service import ProductDataService\n    service = ProductDataService()\n    # Assert that the service uses our mock\n    assert service.local_service is mock_local_service\n    return service\n\n\n@pytest.fixture\ndef mock_run_in_executor(mocker):\n    \"\"\"\n    Mocks asyncio.get_event_loop().run_in_executor to return an awaitable.\n    This allows controlling the return value or side effect of the executor.\n    \"\"\"\n    # Patch `asyncio.get_event_loop`\n    mock_loop = mocker.patch(f'{PRODUCT_DATA_SERVICE_MODULE}.asyncio.get_event_loop').return_value\n    \n    # Create an AsyncMock for the return value of run_in_executor.\n    # When `await mock_loop.run_in_executor(...)` is called, it will resolve to this mock's value.\n    mock_executor_awaitable = AsyncMock()\n    mock_loop.run_in_executor.return_value = mock_executor_awaitable\n    \n    # The fixture returns the AsyncMock itself, so tests can set its return_value or side_effect.\n    return mock_executor_awaitable\n\n\n# --- Test Cases for ProductDataService ---\n\nclass TestProductDataService:\n    \"\"\"Comprehensive test suite for ProductDataService.\"\"\"\n\n    @pytest.mark.asyncio\n    async def test_init(self, mock_local_service, caplog):\n        \"\"\"Test ProductDataService initialization.\"\"\"\n        from app.services.product_data_service import ProductDataService\n        with caplog.at_level(logging.INFO):\n            service = ProductDataService()\n            assert service.local_service is mock_local_service\n            assert \"ProductDataService initialized with LocalProductService\" in caplog.text\n\n    @pytest.mark.asyncio\n    async def test_search_products_success(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"1\", \"name\": \"Laptop\", \"price\": 1200}]\n        mock_run_in_executor.return_value = expected_products\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"laptop\", limit=5)\n            assert products == expected_products\n            assert \"Searching products with keyword: laptop\" in caplog.text\n            assert \"Found 1 products for keyword: laptop\" in caplog.text\n        \n        # Verify run_in_executor was called with the correct local_service method and arguments\n        product_data_service.local_service.search_products.assert_called_once_with(\"laptop\", 5)\n\n    @pytest.mark.asyncio\n    async def test_search_products_no_results(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products returns an empty list when no products are found.\"\"\"\n        mock_run_in_executor.return_value = []\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"nonexistent\", limit=10)\n            assert products == []\n            assert \"Found 0 products for keyword: nonexistent\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"nonexistent\", 10)\n\n    @pytest.mark.asyncio\n    async def test_search_products_exception(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products handles exceptions gracefully and logs an error.\"\"\"\n        mock_run_in_executor.side_effect = Exception(\"Local service error during search\")\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.search_products(\"error_case\")\n            assert products == []\n            assert \"Error searching products: Local service error during search\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"error_case\", 10)\n\n    @pytest.mark.asyncio\n    async def test_search_products_zero_limit(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products with limit=0 returns an empty list.\"\"\"\n        mock_run_in_executor.return_value = [] # The underlying service should return 0 items for limit 0\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"any\", limit=0)\n            assert products == []\n            assert \"Found 0 products for keyword: any\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"any\", 0)\n\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_search(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test get_products dispatches to search_products when 'search' keyword is present.\"\"\"\n        expected_products = [{\"id\": \"s1\", \"name\": \"Search Result\"}]\n        # Mock the underlying call that search_products uses\n        product_data_service.local_service.search_products.return_value = expected_products\n        mock_run_in_executor.return_value = expected_products # Ensures the await in search_products gets the value\n        \n        products = await product_data_service.get_products(search=\"query\", limit=5)\n        assert products == expected_products\n        # Verify that local_service.search_products was called via run_in_executor\n        product_data_service.local_service.search_products.assert_called_once_with(\"query\", 5)\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_category(self, product_data_service):\n        \"\"\"Test get_products dispatches to get_products_by_category when 'category' is present.\"\"\"\n        expected_products = [{\"id\": \"c1\", \"name\": \"Category Item\"}]\n        # This will be called by ProductDataService's get_products_by_category method, not directly by get_products\n        product_data_service.local_service.get_products_by_category.return_value = expected_products\n        \n        products = await product_data_service.get_products(category=\"electronics\", limit=10)\n        assert products == expected_products\n        # local_service's method is called by the ProductDataService's internal method\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    @pytest.mark.asyncio\n    async def test_get_products_no_filters(self, product_data_service):\n        \"\"\"Test get_products dispatches to get_all_products when no filters are present.\"\"\"\n        expected_products = [{\"id\": \"a1\", \"name\": \"All Item\"}]\n        # This will be called by ProductDataService's get_all_products method\n        product_data_service.local_service.get_products.return_value = expected_products\n        \n        products = await product_data_service.get_products(limit=15)\n        assert products == expected_products\n        # local_service's method is called by the ProductDataService's internal method\n        product_data_service.local_service.get_products.assert_called_once_with(15)\n\n    @pytest.mark.asyncio\n    async def test_get_products_search_precedence(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test get_products prioritizes 'search' over 'category' if both are provided.\"\"\"\n        expected_products = [{\"id\": \"s_prec\", \"name\": \"Search Precedence\"}]\n        product_data_service.local_service.search_products.return_value = expected_products\n        mock_run_in_executor.return_value = expected_products\n\n        products = await product_data_service.get_products(search=\"query\", category=\"ignored\", limit=5)\n        assert products == expected_products\n        product_data_service.local_service.search_products.assert_called_once_with(\"query\", 5)\n        product_data_service.local_service.get_products_by_category.assert_not_called() # Ensure category path was not taken\n\n    @pytest.mark.asyncio\n    async def test_get_products_exception_fallback(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test get_products falls back to local_service.get_products on error in 'search' dispatch.\"\"\"\n        # Simulate an error in the search path to trigger the fallback\n        mock_run_in_executor.side_effect = Exception(\"Search path failed\")\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback\", \"name\": \"Fallback Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(search=\"err\", limit=5)\n            assert products == fallback_products\n            assert \"Error getting products: Search path failed\" in caplog.text\n        \n        # Verify fallback call\n        product_data_service.local_service.get_products.assert_called_once_with(5)\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_category_exception_fallback(self, product_data_service, mocker, caplog):\n        \"\"\"\n        Test get_products falls back to local_service.get_products when\n        get_products_by_category (called internally) raises an exception.\n        \"\"\"\n        # Patch the internal method get_products_by_category to raise an exception\n        mocker.patch.object(product_data_service, 'get_products_by_category', side_effect=Exception(\"Category processing failed\"))\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback_cat\", \"name\": \"Fallback Category Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(category=\"error_cat\", limit=7)\n            assert products == fallback_products\n            assert \"Error getting products: Category processing failed\" in caplog.text\n        \n        # Verify that get_products_by_category was attempted and then fallback occurred\n        product_data_service.get_products_by_category.assert_called_once_with(\"error_cat\", 7)\n        product_data_service.local_service.get_products.assert_called_once_with(7)\n\n\n    @pytest.mark.asyncio\n    async def test_get_products_no_filters_exception_fallback(self, product_data_service, mocker, caplog):\n        \"\"\"\n        Test get_products falls back to local_service.get_products when\n        get_all_products (called internally) raises an exception.\n        \"\"\"\n        # Patch the internal method get_all_products to raise an exception\n        mocker.patch.object(product_data_service, 'get_all_products', side_effect=Exception(\"All products processing failed\"))\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback_all\", \"name\": \"Fallback All Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(limit=12)\n            assert products == fallback_products\n            assert \"Error getting products: All products processing failed\" in caplog.text\n        \n        # Verify that get_all_products was attempted and then fallback occurred\n        product_data_service.get_all_products.assert_called_once_with(12)\n        product_data_service.local_service.get_products.assert_called_once_with(12)\n\n    @pytest.mark.asyncio\n    async def test_get_products_default_limit(self, product_data_service):\n        \"\"\"Test get_products uses default limit when no filters are specified.\"\"\"\n        expected_products = [{\"id\": \"default\", \"name\": \"Default Limit Product\"}]\n        product_data_service.local_service.get_products.return_value = expected_products\n        \n        products = await product_data_service.get_products() # No limit specified\n        assert products == expected_products\n        product_data_service.local_service.get_products.assert_called_once_with(20) # Default limit is 20\n    \n    @pytest.mark.asyncio\n    async def test_get_products_exception_in_fallback(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"\n        Test get_products when the initial call fails, and the fallback local_service.get_products also fails,\n        leading to the exception propagating.\n        \"\"\"\n        # Simulate the initial path (e.g., search_products) raising an exception\n        mock_run_in_executor.side_effect = Exception(\"Initial search path failed\")\n\n        # Simulate the fallback call (local_service.get_products) also raising an exception\n        product_data_service.local_service.get_products.side_effect = Exception(\"Fallback local service failed\")\n\n        with caplog.at_level(logging.ERROR):\n            with pytest.raises(Exception, match=\"Fallback local service failed\"):\n                await product_data_service.get_products(search=\"double_fail\", limit=5)\n            \n            # Verify the first error was logged. The second exception propagates out.\n            assert \"Error getting products: Initial search path failed\" in caplog.text\n        \n        # Verify both underlying calls were made\n        product_data_service.local_service.search_products.assert_called_once_with(\"double_fail\", 5) # Triggered by the search path\n        product_data_service.local_service.get_products.assert_called_once_with(5) # The fallback call\n\n\n    @pytest.mark.asyncio\n    async def test_get_categories_success(self, product_data_service):\n        \"\"\"Test get_categories returns categories successfully.\"\"\"\n        expected_categories = [\"Electronics\", \"Books\", \"Clothing\"]\n        product_data_service.local_service.get_categories.return_value = expected_categories\n        \n        categories = await product_data_service.get_categories()\n        assert categories == expected_categories\n        product_data_service.local_service.get_categories.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_get_categories_empty(self, product_data_service):\n        \"\"\"Test get_categories returns an empty list when no categories are available.\"\"\"\n        product_data_service.local_service.get_categories.return_value = []\n        \n        categories = await product_data_service.get_categories()\n        assert categories == []\n        product_data_service.local_service.get_categories.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_get_categories_exception(self, product_data_service, caplog):\n        \"\"\"Test get_categories handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_categories.side_effect = Exception(\"Category service down\")\n        \n        with caplog.at_level(logging.ERROR):\n            categories = await product_data_service.get_categories()\n            assert categories == []\n            assert \"Error getting categories: Category service down\" in caplog.text\n        \n        product_data_service.local_service.get_categories.assert_called_once()\n\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_success(self, product_data_service):\n        \"\"\"Test get_top_rated_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"t1\", \"name\": \"Top Product\", \"rating\": 5.0}]\n        product_data_service.local_service.get_top_rated_products.return_value = expected_products\n        \n        products = await product_data_service.get_top_rated_products(limit=2)\n        assert products == expected_products\n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(2)\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_empty(self, product_data_service):\n        \"\"\"Test get_top_rated_products returns empty list when no products are found.\"\"\"\n        product_data_service.local_service.get_top_rated_products.return_value = []\n        products = await product_data_service.get_top_rated_products(limit=5)\n        assert products == []\n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(5)\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_zero_limit(self, product_data_service):\n        \"\"\"Test get_top_rated_products with limit=0 returns empty list.\"\"\"\n        product_data_service.local_service.get_top_rated_products.return_value = [] # The underlying service should return 0 for limit 0\n        products = await product_data_service.get_top_rated_products(limit=0)\n        assert products == []\n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(0)\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_top_rated_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_top_rated_products.side_effect = Exception(\"Top rated service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_top_rated_products()\n            assert products == []\n            assert \"Error getting top rated products: Top rated service error\" in caplog.text\n        \n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(10)\n\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_success(self, product_data_service):\n        \"\"\"Test get_best_selling_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"b1\", \"name\": \"Best Seller\", \"sales\": 1000}]\n        product_data_service.local_service.get_best_selling_products.return_value = expected_products\n        \n        products = await product_data_service.get_best_selling_products(limit=3)\n        assert products == expected_products\n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(3)\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_empty(self, product_data_service):\n        \"\"\"Test get_best_selling_products returns empty list when no products are found.\"\"\"\n        product_data_service.local_service.get_best_selling_products.return_value = []\n        products = await product_data_service.get_best_selling_products(limit=5)\n        assert products == []\n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(5)\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_zero_limit(self, product_data_service):\n        \"\"\"Test get_best_selling_products with limit=0 returns empty list.\"\"\"\n        product_data_service.local_service.get_best_selling_products.return_value = [] # The underlying service should return 0 for limit 0\n        products = await product_data_service.get_best_selling_products(limit=0)\n        assert products == []\n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(0)\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_best_selling_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_best_selling_products.side_effect = Exception(\"Best selling service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_best_selling_products()\n            assert products == []\n            assert \"Error getting best selling products: Best selling service error\" in caplog.text\n        \n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(10)\n\n\n    def test_get_products_by_category_success(self, product_data_service):\n        \"\"\"Test get_products_by_category returns products and applies limit.\"\"\"\n        # Simulate more products than limit to test slicing\n        all_cat_products = [{\"id\": \"c1\"}, {\"id\": \"c2\"}, {\"id\": \"c3\"}, {\"id\": \"c4\"}]\n        product_data_service.local_service.get_products_by_category.return_value = all_cat_products\n        \n        products = product_data_service.get_products_by_category(\"electronics\", limit=2)\n        assert products == [{\"id\": \"c1\"}, {\"id\": \"c2\"}]\n        # local_service.get_products_by_category does not take limit directly\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    def test_get_products_by_category_limit_exceeds_available(self, product_data_service):\n        \"\"\"Test get_products_by_category returns all available products if limit exceeds them.\"\"\"\n        all_cat_products = [{\"id\": \"c1\"}, {\"id\": \"c2\"}]\n        product_data_service.local_service.get_products_by_category.return_value = all_cat_products\n        \n        products = product_data_service.get_products_by_category(\"electronics\", limit=10) # Limit is 10, but only 2 available\n        assert products == all_cat_products\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    def test_get_products_by_category_zero_limit(self, product_data_service):\n        \"\"\"Test get_products_by_category with limit=0 returns an empty list.\"\"\"\n        product_data_service.local_service.get_products_by_category.return_value = [{\"id\": \"c1\"}] # Even if products exist\n        \n        products = product_data_service.get_products_by_category(\"electronics\", limit=0)\n        assert products == []\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n\n    def test_get_products_by_category_no_results(self, product_data_service):\n        \"\"\"Test get_products_by_category returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products_by_category.return_value = []\n        \n        products = product_data_service.get_products_by_category(\"unknown_category\")\n        assert products == []\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"unknown_category\")\n\n    def test_get_products_by_category_exception(self, product_data_service, caplog):\n        \"\"\"Test get_products_by_category handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products_by_category.side_effect = Exception(\"Category DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_products_by_category(\"failed_cat\")\n            assert products == []\n            assert \"Error getting products by category: Category DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"failed_cat\")\n\n\n    def test_get_all_products_success(self, product_data_service):\n        \"\"\"Test get_all_products returns products and passes limit to local service.\"\"\"\n        # local_service.get_products takes limit directly\n        expected_products_for_limit = [{\"id\": \"a1\"}, {\"id\": \"a2\"}]\n        product_data_service.local_service.get_products.return_value = expected_products_for_limit\n        \n        products = product_data_service.get_all_products(limit=2)\n        assert products == expected_products_for_limit\n        product_data_service.local_service.get_products.assert_called_once_with(2)\n\n    def test_get_all_products_default_limit(self, product_data_service):\n        \"\"\"Test get_all_products uses default limit.\"\"\"\n        expected_products = [{\"id\": \"a1\", \"name\": \"Default All Product\"}]\n        product_data_service.local_service.get_products.return_value = expected_products\n        \n        products = product_data_service.get_all_products() # No limit specified\n        assert products == expected_products\n        product_data_service.local_service.get_products.assert_called_once_with(20) # Default limit is 20\n\n    def test_get_all_products_no_results(self, product_data_service):\n        \"\"\"Test get_all_products returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products.return_value = []\n        \n        products = product_data_service.get_all_products()\n        assert products == []\n        product_data_service.local_service.get_products.assert_called_once_with(20)\n\n    def test_get_all_products_zero_limit(self, product_data_service):\n        \"\"\"Test get_all_products with limit=0 returns empty list.\"\"\"\n        product_data_service.local_service.get_products.return_value = [] # Underlying service would return 0 for limit 0\n        products = product_data_service.get_all_products(limit=0)\n        assert products == []\n        product_data_service.local_service.get_products.assert_called_once_with(0)\n\n\n    def test_get_all_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_all_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products.side_effect = Exception(\"All products DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_all_products()\n            assert products == []\n            assert \"Error getting all products: All products DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products.assert_called_once_with(20)\n\n\n    def test_get_product_details_success(self, product_data_service):\n        \"\"\"Test get_product_details returns product details.\"\"\"\n        expected_details = {\"id\": \"p123\", \"name\": \"Widget X\", \"description\": \"A fine widget.\"}\n        product_data_service.local_service.get_product_details.return_value = expected_details\n        \n        details = product_data_service.get_product_details(\"p123\")\n        assert details == expected_details\n        product_data_service.local_service.get_product_details.assert_called_once_with(\"p123\")\n\n    def test_get_product_details_not_found(self, product_data_service):\n        \"\"\"Test get_product_details returns None if product not found.\"\"\"\n        product_data_service.local_service.get_product_details.return_value = None\n        \n        details = product_data_service.get_product_details(\"nonexistent\")\n        assert details is None\n        product_data_service.local_service.get_product_details.assert_called_once_with(\"nonexistent\")\n\n    def test_get_product_details_exception(self, product_data_service, caplog):\n        \"\"\"Test get_product_details handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_product_details.side_effect = Exception(\"Details service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            details = product_data_service.get_product_details(\"error_id\")\n            assert details is None\n            assert \"Error getting product details: Details service error\" in caplog.text\n        \n        product_data_service.local_service.get_product_details.assert_called_once_with(\"error_id\")\n\n\n    def test_get_brands_success(self, product_data_service):\n        \"\"\"Test get_brands returns list of brands.\"\"\"\n        expected_brands = [\"Brand A\", \"Brand B\", \"Brand C\"]\n        product_data_service.local_service.get_brands.return_value = expected_brands\n        \n        brands = product_data_service.get_brands()\n        assert brands == expected_brands\n        product_data_service.local_service.get_brands.assert_called_once()\n\n    def test_get_brands_empty(self, product_data_service):\n        \"\"\"Test get_brands returns empty list when no brands are available.\"\"\"\n        product_data_service.local_service.get_brands.return_value = []\n        \n        brands = product_data_service.get_brands()\n        assert brands == []\n        product_data_service.local_service.get_brands.assert_called_once()\n\n    def test_get_brands_exception(self, product_data_service, caplog):\n        \"\"\"Test get_brands handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_brands.side_effect = Exception(\"Brand service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            brands = product_data_service.get_brands()\n            assert brands == []\n            assert \"Error getting brands: Brand service error\" in caplog.text\n        \n        product_data_service.local_service.get_brands.assert_called_once()\n\n\n    def test_get_products_by_brand_success(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns products and applies limit.\"\"\"\n        all_brand_products = [{\"id\": \"br1\"}, {\"id\": \"br2\"}, {\"id\": \"br3\"}, {\"id\": \"br4\"}]\n        product_data_service.local_service.get_products_by_brand.return_value = all_brand_products\n        \n        products = product_data_service.get_products_by_brand(\"brandx\", limit=2)\n        assert products == [{\"id\": \"br1\"}, {\"id\": \"br2\"}]\n        # local_service.get_products_by_brand does not take limit directly\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"brandx\")\n\n    def test_get_products_by_brand_limit_exceeds_available(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns all available products if limit exceeds them.\"\"\"\n        all_brand_products = [{\"id\": \"br1\"}, {\"id\": \"br2\"}]\n        product_data_service.local_service.get_products_by_brand.return_value = all_brand_products\n        \n        products = product_data_service.get_products_by_brand(\"brandx\", limit=10)\n        assert products == all_brand_products\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"brandx\")\n\n    def test_get_products_by_brand_zero_limit(self, product_data_service):\n        \"\"\"Test get_products_by_brand with limit=0 returns an empty list.\"\"\"\n        product_data_service.local_service.get_products_by_brand.return_value = [{\"id\": \"br1\"}] # Even if products exist\n        \n        products = product_data_service.get_products_by_brand(\"brandx\", limit=0)\n        assert products == []\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"brandx\")\n\n    def test_get_products_by_brand_no_results(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products_by_brand.return_value = []\n        \n        products = product_data_service.get_products_by_brand(\"unknown_brand\")\n        assert products == []\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"unknown_brand\")\n\n    def test_get_products_by_brand_exception(self, product_data_service, caplog):\n        \"\"\"Test get_products_by_brand handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products_by_brand.side_effect = Exception(\"Brand DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_products_by_brand(\"failed_brand\")\n            assert products == []\n            assert \"Error getting products by brand: Brand DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"failed_brand\")\n\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_success(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products returns products and message successfully.\"\"\"\n        expected_products = [{\"id\": \"s_s1\", \"name\": \"Smart Item\"}]\n        expected_message = \"Smart search completed.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result # What the await resolves to\n\n        products, message = await product_data_service.smart_search_products(\n            keyword=\"smart\", category=\"books\", max_price=50, limit=3\n        )\n        assert products == expected_products\n        assert message == expected_message\n        \n        product_data_service.local_service.smart_search_products.assert_called_once_with(\n            \"smart\", \"books\", 50, 3\n        )\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_default_args(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products uses default arguments correctly.\"\"\"\n        expected_products = [{\"id\": \"s_s_def\", \"name\": \"Default Search\"}]\n        expected_message = \"Default search.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result\n\n        products, message = await product_data_service.smart_search_products() # No args\n        assert products == expected_products\n        assert message == expected_message\n        \n        # Verify that the local service method was called with default values\n        product_data_service.local_service.smart_search_products.assert_called_once_with(\n            '', None, None, 5\n        )\n    \n    @pytest.mark.asyncio\n    async def test_smart_search_products_zero_limit(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products with limit=0.\"\"\"\n        expected_products = []\n        expected_message = \"No results due to limit 0.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result\n\n        products, message = await product_data_service.smart_search_products(limit=0)\n        assert products == expected_products\n        assert message == expected_message\n        product_data_service.local_service.smart_search_products.assert_called_once_with('', None, None, 0)\n\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_exception(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products propagates exceptions as it has no try-except.\"\"\"\n        mock_run_in_executor.side_effect = Exception(\"Smart search internal error\")\n\n        with pytest.raises(Exception, match=\"Smart search internal error\"):\n            await product_data_service.smart_search_products(\"fail_keyword\")\n\n        # Verify that the local service method was still attempted to be called\n        product_data_service.local_service.smart_search_products.assert_called_once_with(\"fail_keyword\", None, None, 5)"
    },
    {
      "filepath": "app/utils/config.py",
      "coverage": 86.36,
      "content": "from pydantic_settings import BaseSettings\nfrom functools import lru_cache\nimport logging\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass Settings(BaseSettings):\n    # API Configuration\n    GOOGLE_API_KEY: str\n    API_HOST: str = \"localhost\"\n    API_PORT: int = 8000\n    FRONTEND_HOST: str = \"localhost\"\n    FRONTEND_PORT: int = 8501\n    DEBUG: bool = True\n\n    class Config:\n        env_file = \".env\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        if not self.GOOGLE_API_KEY or self.GOOGLE_API_KEY == \"your-google-api-key-here\":\n            logger.error(\"GOOGLE_API_KEY is not set or is using default value\")\n            raise ValueError(\"GOOGLE_API_KEY must be set in .env file\")\n\n@lru_cache()\ndef get_settings():\n    return Settings()\n\nsettings = get_settings() ",
      "existing_test": "import pytest\nimport sys\nimport os\nfrom functools import lru_cache\nfrom unittest.mock import patch\nfrom pydantic import ValidationError\n\n# Define a comprehensive fixture to ensure a clean state for testing module-level imports\n# and cached functions.\n@pytest.fixture\ndef clean_config_module():\n    \"\"\"\n    Cleans the app.utils.config module state by:\n    1. Clearing the lru_cache for get_settings if the module is already loaded.\n    2. Removing the module from sys.modules to force a fresh import in subsequent tests.\n    \"\"\"\n    # Store initial sys.path for restoration\n    initial_sys_path = list(sys.path)\n\n    # Ensure the module is not already loaded or clear its state if it is.\n    if 'app.utils.config' in sys.modules:\n        _config_module = sys.modules['app.utils.config']\n        if hasattr(_config_module, 'get_settings') and callable(getattr(_config_module.get_settings, 'cache_clear', None)):\n            _config_module.get_settings.cache_clear()\n        del sys.modules['app.utils.config']\n    \n    yield # Allow the test to run\n\n    # Clean up again after the test, in case it re-imported the module\n    # or for subsequent tests in the same test run. This ensures isolation.\n    if 'app.utils.config' in sys.modules:\n        _config_module = sys.modules['app.utils.config']\n        if hasattr(_config_module, 'get_settings') and callable(getattr(_config_module.get_settings, 'cache_clear', None)):\n            _config_module.get_settings.cache_clear()\n        del sys.modules['app.utils.config']\n    \n    # Restore sys.path to its initial state to prevent test interference\n    sys.path = initial_sys_path\n\n\n# Test cases for the Settings class itself\nclass TestSettings:\n    \"\"\"\n    Tests for the Settings Pydantic model's instantiation and validation.\n    \"\"\"\n\n    # Use the clean_config_module fixture for all tests in this class\n    # to ensure isolated environment variable handling.\n    @pytest.fixture(autouse=True)\n    def setup(self, clean_config_module):\n        pass\n\n    def test_settings_init_success_with_all_variables(self, monkeypatch):\n        \"\"\"\n        Tests successful initialization of Settings when all environment variables are provided.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"test-api-key-123\")\n        monkeypatch.setenv(\"API_HOST\", \"custom_host\")\n        monkeypatch.setenv(\"API_PORT\", \"9000\")\n        monkeypatch.setenv(\"FRONTEND_HOST\", \"custom_frontend\")\n        monkeypatch.setenv(\"FRONTEND_PORT\", \"9500\")\n        monkeypatch.setenv(\"DEBUG\", \"False\")\n\n        from app.utils.config import Settings\n        settings = Settings()\n\n        assert settings.GOOGLE_API_KEY == \"test-api-key-123\"\n        assert settings.API_HOST == \"custom_host\"\n        assert settings.API_PORT == 9000\n        assert settings.FRONTEND_HOST == \"custom_frontend\"\n        assert settings.FRONTEND_PORT == 9500\n        assert settings.DEBUG is False\n\n    def test_settings_init_success_with_defaults(self, monkeypatch):\n        \"\"\"\n        Tests successful initialization when only GOOGLE_API_KEY is provided,\n        and other fields fall back to their default values.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-api-key-default\")\n        # Ensure other variables are NOT set to check defaults\n        monkeypatch.delenv(\"API_HOST\", raising=False)\n        monkeypatch.delenv(\"API_PORT\", raising=False)\n        monkeypatch.delenv(\"FRONTEND_HOST\", raising=False)\n        monkeypatch.delenv(\"FRONTEND_PORT\", raising=False)\n        monkeypatch.delenv(\"DEBUG\", raising=False)\n\n        from app.utils.config import Settings\n        settings = Settings()\n\n        assert settings.GOOGLE_API_KEY == \"valid-api-key-default\"\n        assert settings.API_HOST == \"localhost\"\n        assert settings.API_PORT == 8000\n        assert settings.FRONTEND_HOST == \"localhost\"\n        assert settings.FRONTEND_PORT == 8501\n        assert settings.DEBUG is True\n\n    def test_settings_init_with_direct_kwargs(self, monkeypatch):\n        \"\"\"\n        Tests that Settings can be initialized by passing arguments directly,\n        which should override environment variables.\n        \"\"\"\n        # Set some environment variables that should be overridden by kwargs\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"env-key-should-be-overridden\")\n        monkeypatch.setenv(\"API_PORT\", \"1234\") # This should be overridden\n\n        from app.utils.config import Settings\n        \n        # Initialize with direct kwargs\n        settings = Settings(GOOGLE_API_KEY=\"direct-kwarg-key\", API_PORT=9999)\n\n        assert settings.GOOGLE_API_KEY == \"direct-kwarg-key\"\n        assert settings.API_PORT == 9999\n        assert settings.API_HOST == \"localhost\" # Should fall back to default as not in env or kwargs\n        assert settings.FRONTEND_PORT == 8501 # Should fall back to default\n        assert settings.DEBUG is True # Should fall back to default\n\n    def test_settings_init_raises_error_on_missing_google_api_key(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that Settings raises ValueError and logs an error when GOOGLE_API_KEY is missing.\n        This covers the 'not self.GOOGLE_API_KEY' part when the variable is entirely absent.\n        \"\"\"\n        monkeypatch.delenv(\"GOOGLE_API_KEY\", raising=False) # Ensure it's unset\n\n        with caplog.at_level('ERROR'):\n            with pytest.raises(ValueError) as excinfo:\n                from app.utils.config import Settings\n                Settings()\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_settings_init_raises_error_on_placeholder_google_api_key(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that Settings raises ValueError and logs an error when GOOGLE_API_KEY is the default placeholder.\n        This covers the 'self.GOOGLE_API_KEY == \"your-google-api-key-here\"' part.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"your-google-api-key-here\")\n\n        with caplog.at_level('ERROR'):\n            with pytest.raises(ValueError) as excinfo:\n                from app.utils.config import Settings\n                Settings()\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_settings_init_raises_error_on_empty_string_google_api_key_kwarg(self, caplog):\n        \"\"\"\n        Tests that Settings raises ValueError and logs an error when GOOGLE_API_KEY\n        is provided as an empty string directly via kwargs.\n        Pydantic allows empty strings for `str` type, but our custom __init__ checks this\n        via the 'not self.GOOGLE_API_KEY' condition.\n        \"\"\"\n        with caplog.at_level('ERROR'):\n            with pytest.raises(ValueError) as excinfo:\n                from app.utils.config import Settings\n                Settings(GOOGLE_API_KEY=\"\")\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_settings_init_raises_error_on_empty_string_google_api_key_env_var(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that Settings raises ValueError and logs an error when GOOGLE_API_KEY\n        is provided as an empty string via an environment variable.\n        This covers the 'not self.GOOGLE_API_KEY' condition for env var input.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"\")\n\n        with caplog.at_level('ERROR'):\n            with pytest.raises(ValueError) as excinfo:\n                from app.utils.config import Settings\n                Settings()\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_settings_init_raises_validation_error_on_none_google_api_key_kwarg(self):\n        \"\"\"\n        Tests that Settings raises Pydantic ValidationError when GOOGLE_API_KEY\n        is provided as None directly via kwargs, as it's a non-optional string field.\n        This validates Pydantic's behavior *before* our custom __init__ check.\n        \"\"\"\n        with pytest.raises(ValidationError) as excinfo:\n            from app.utils.config import Settings\n            # Mypy will complain about `None` for `str` type, but we're testing Pydantic's behavior.\n            Settings(GOOGLE_API_KEY=None) # type: ignore \n\n        assert \"GOOGLE_API_KEY\" in str(excinfo.value)\n        # Check for typical Pydantic v1 or v2 error messages\n        assert any(msg in str(excinfo.value) for msg in [\"value is not a valid string\", \"Input should be a valid string\"])\n\n\n    def test_settings_init_fails_on_invalid_port_type(self, monkeypatch):\n        \"\"\"\n        Tests that Settings raises a Pydantic ValidationError when API_PORT is not a valid integer.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-key\")\n        monkeypatch.setenv(\"API_PORT\", \"not_an_integer\")\n\n        from app.utils.config import Settings\n\n        with pytest.raises(ValidationError) as excinfo:\n            Settings()\n        \n        assert \"API_PORT\" in str(excinfo.value)\n        assert \"value is not a valid integer\" in str(excinfo.value)\n\n    def test_settings_init_fails_on_invalid_debug_type(self, monkeypatch):\n        \"\"\"\n        Tests that Settings raises a Pydantic ValidationError when DEBUG is not a valid boolean.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-key\")\n        monkeypatch.setenv(\"DEBUG\", \"not_a_boolean\")\n\n        from app.utils.config import Settings\n\n        with pytest.raises(ValidationError) as excinfo:\n            Settings()\n        \n        assert \"DEBUG\" in str(excinfo.value)\n        assert \"value could not be parsed to a boolean\" in str(excinfo.value)\n\n    def test_settings_init_success_debug_from_string_true(self, monkeypatch):\n        \"\"\"\n        Tests that DEBUG field correctly parses string \"true\" (case-insensitive) to boolean True.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-key\")\n        monkeypatch.setenv(\"DEBUG\", \"true\")\n\n        from app.utils.config import Settings\n        settings = Settings()\n        assert settings.DEBUG is True\n\n    def test_settings_init_success_debug_from_string_false(self, monkeypatch):\n        \"\"\"\n        Tests that DEBUG field correctly parses string \"false\" (case-insensitive) to boolean False.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-key\")\n        monkeypatch.setenv(\"DEBUG\", \"false\")\n\n        from app.utils.config import Settings\n        settings = Settings()\n        assert settings.DEBUG is False\n\n    def test_settings_init_success_debug_from_string_one(self, monkeypatch):\n        \"\"\"\n        Tests that DEBUG field correctly parses string \"1\" to boolean True.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-key\")\n        monkeypatch.setenv(\"DEBUG\", \"1\")\n\n        from app.utils.config import Settings\n        settings = Settings()\n        assert settings.DEBUG is True\n\n    def test_settings_init_success_debug_from_string_zero(self, monkeypatch):\n        \"\"\"\n        Tests that DEBUG field correctly parses string \"0\" to boolean False.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-key\")\n        monkeypatch.setenv(\"DEBUG\", \"0\")\n\n        from app.utils.config import Settings\n        settings = Settings()\n        assert settings.DEBUG is False\n\n\n# Test cases for the get_settings function and the global settings object\nclass TestGetSettingsAndGlobal:\n    \"\"\"\n    Tests for the get_settings function (including lru_cache behavior)\n    and the global 'settings' instance created on module import.\n    \"\"\"\n\n    # This fixture must be autoused for this class to ensure a fresh module import for each test\n    @pytest.fixture(autouse=True)\n    def setup(self, clean_config_module):\n        pass\n\n    def test_get_settings_returns_settings_instance(self, monkeypatch):\n        \"\"\"\n        Verifies that get_settings successfully returns an instance of Settings.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"key-for-get-settings\")\n        \n        from app.utils.config import get_settings, Settings\n        settings_instance = get_settings()\n\n        assert isinstance(settings_instance, Settings)\n        assert settings_instance.GOOGLE_API_KEY == \"key-for-get-settings\"\n\n    def test_get_settings_uses_lru_cache(self, monkeypatch):\n        \"\"\"\n        Tests that get_settings utilizes lru_cache by returning the same instance on subsequent calls.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"cache-test-key\")\n        \n        from app.utils.config import get_settings\n        \n        first_call_settings = get_settings()\n        second_call_settings = get_settings()\n        \n        # Verify that both calls return the exact same object instance\n        assert first_call_settings is second_call_settings\n        assert first_call_settings.GOOGLE_API_KEY == \"cache-test-key\"\n        # Ensure the cache prevented re-reading environment variables, even if they change.\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"changed-key-after-cache\") # Change env var *after* first call\n        assert second_call_settings.GOOGLE_API_KEY == \"cache-test-key\" # Still the original key, proving caching\n\n    def test_global_settings_is_initialized_correctly(self, monkeypatch):\n        \"\"\"\n        Tests that the global 'settings' variable is correctly initialized on module import.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"global-key-on-import\")\n        monkeypatch.setenv(\"API_HOST\", \"global-host-on-import\")\n        \n        # Importing the module triggers the global 'settings = get_settings()' line\n        from app.utils.config import settings, Settings\n\n        assert isinstance(settings, Settings)\n        assert settings.GOOGLE_API_KEY == \"global-key-on-import\"\n        assert settings.API_HOST == \"global-host-on-import\"\n        assert settings.API_PORT == 8000 # Should be default\n\n    def test_global_settings_is_immutable_after_initial_import(self, monkeypatch):\n        \"\"\"\n        Tests that the global 'settings' object, once initialized on module import,\n        remains the same instance and does not reflect subsequent environment variable changes,\n        due to the lru_cache on get_settings.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"initial-global-key\")\n        \n        # First import, sets global settings\n        from app.utils.config import settings as initial_settings_instance\n        \n        assert initial_settings_instance.GOOGLE_API_KEY == \"initial-global-key\"\n\n        # Change environment variable *after* initial import\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"changed-global-key\")\n        \n        # Re-import (or access again) - the cached instance should still be used.\n        # The clean_config_module fixture ensures a fresh import for each test,\n        # but within a single test, accessing `app.utils.config.settings`\n        # after it's been imported will return the same cached instance due to `lru_cache`.\n        from app.utils.config import settings as current_settings_instance\n\n        # It should be the *same* instance and reflect the *original* value\n        assert current_settings_instance is initial_settings_instance\n        assert current_settings_instance.GOOGLE_API_KEY == \"initial-global-key\"\n\n\n    def test_global_settings_fails_on_missing_key_at_import(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that importing the config module fails if GOOGLE_API_KEY is missing,\n        due to the global 'settings' initialization, and logs an error.\n        \"\"\"\n        monkeypatch.delenv(\"GOOGLE_API_KEY\", raising=False) # Ensure it's unset\n\n        with caplog.at_level('ERROR'):\n            with pytest.raises(ValueError) as excinfo:\n                # This import statement will trigger the global settings initialization and thus the error\n                from app.utils import config \n                _ = config # Avoid \"unused import\" warning if not explicitly used\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_global_settings_fails_on_placeholder_key_at_import(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that importing the config module fails if GOOGLE_API_KEY is the placeholder,\n        due to the global 'settings' initialization, and logs an error.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"your-google-api-key-here\")\n\n        with caplog.at_level('ERROR'):\n            with pytest.raises(ValueError) as excinfo:\n                from app.utils import config\n                _ = config\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_get_settings_cache_clear_functionality(self, monkeypatch):\n        \"\"\"\n        Tests that get_settings.cache_clear() correctly clears the cached instance,\n        allowing a new instance to be created on the next call, reflecting updated env vars.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"first-key\")\n        \n        from app.utils.config import get_settings\n        \n        first_settings = get_settings()\n        assert first_settings.GOOGLE_API_KEY == \"first-key\"\n\n        # Clear the cache\n        get_settings.cache_clear()\n\n        # Change the environment variable\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"second-key\")\n        \n        # Get settings again - should now pick up the new env var as cache was cleared\n        second_settings = get_settings()\n\n        # Verify that it's a new instance and has the new API key\n        assert second_settings is not first_settings\n        assert second_settings.GOOGLE_API_KEY == \"second-key\""
    }
  ]
}