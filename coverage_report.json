{
  "timestamp": "/home/runner/work/ai-product-qa/ai-product-qa",
  "total_files": 16,
  "coverage_data": {
    "app/main.py": 100.0,
    "app/api": 81.87,
    "app/api/__init__.py": 100.0,
    "app/api/products.py": 61.63999999999999,
    "app/api/queries.py": 94.17,
    "app/models": 100.0,
    "app/models/__init__.py": 100.0,
    "app/models/product.py": 100.0,
    "app/services": 82.52000000000001,
    "app/services/__init__.py": 100.0,
    "app/services/ai_service.py": 98.39,
    "app/services/local_product_service.py": 82.42,
    "app/services/product_data_service.py": 70.73,
    "app/utils": 100.0,
    "app/utils/__init__.py": 100.0,
    "app/utils/config.py": 100.0
  },
  "lowest_coverage_files": [
    {
      "filepath": "app/api/products.py",
      "coverage": 61.63999999999999,
      "content": "from fastapi import APIRouter, HTTPException\nfrom app.services.product_data_service import ProductDataService\nfrom app.models.product import ProductResponse\nfrom typing import List, Optional\n\nrouter = APIRouter()\nproduct_service = ProductDataService()\n\n@router.get(\"/\", response_model=List[ProductResponse])\nasync def get_products(\n    limit: Optional[int] = 20,\n    category: Optional[str] = None,\n    search: Optional[str] = None\n):\n    \"\"\"Get products from local data source\"\"\"\n    try:\n        products = await product_service.get_products(\n            limit=limit,\n            category=category,\n            search=search\n        )\n        return products\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/categories\")\nasync def get_categories():\n    \"\"\"Get available product categories\"\"\"\n    try:\n        categories = await product_service.get_categories()\n        return {\"categories\": categories}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/search\")\nasync def search_products(query: str, limit: Optional[int] = 10):\n    \"\"\"Search products by query\"\"\"\n    try:\n        products = await product_service.search_products(query, limit)\n        return {\"products\": products, \"query\": query, \"source\": \"local\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/top-rated\")\nasync def get_top_rated_products(limit: Optional[int] = 10):\n    \"\"\"Get top rated products\"\"\"\n    try:\n        products = await product_service.get_top_rated_products(limit)\n        return {\"products\": products, \"source\": \"local\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/best-selling\")\nasync def get_best_selling_products(limit: Optional[int] = 10):\n    \"\"\"Get best selling products\"\"\"\n    try:\n        products = await product_service.get_best_selling_products(limit)\n        return {\"products\": products, \"source\": \"local\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/brands\")\nasync def get_brands():\n    \"\"\"Get available product brands\"\"\"\n    try:\n        brands = product_service.get_brands()\n        return {\"brands\": brands, \"source\": \"local\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/category/{category}\")\nasync def get_products_by_category(category: str, limit: Optional[int] = 20):\n    \"\"\"Get products by category\"\"\"\n    try:\n        products = product_service.get_products_by_category(category, limit)\n        return {\"products\": products, \"category\": category, \"source\": \"local\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/brand/{brand}\")\nasync def get_products_by_brand(brand: str, limit: Optional[int] = 20):\n    \"\"\"Get products by brand\"\"\"\n    try:\n        products = product_service.get_products_by_brand(brand, limit)\n        return {\"products\": products, \"brand\": brand, \"source\": \"local\"}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/{product_id}\")\nasync def get_product_details(product_id: str):\n    \"\"\"Get product details by ID\"\"\"\n    try:\n        product = product_service.get_product_details(product_id)\n        if product:\n            return {\"product\": product, \"source\": \"local\"}\n        else:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n    except HTTPException:\n        raise\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e)) ",
      "existing_test": null
    },
    {
      "filepath": "app/services/product_data_service.py",
      "coverage": 70.73,
      "content": "import logging\nfrom typing import List, Dict, Optional\nfrom app.services.local_product_service import LocalProductService\n\nlogger = logging.getLogger(__name__)\n\nclass ProductDataService:\n    \"\"\"\n    Service untuk mengambil data produk dari sumber lokal yang reliable\n    \"\"\"\n    \n    def __init__(self):\n        # Use LocalProductService as primary data source\n        self.local_service = LocalProductService()\n        logger.info(\"ProductDataService initialized with LocalProductService\")\n    \n    async def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Search products using local data\"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            # Use awaitable wrapper for sync method\n            import asyncio\n            loop = asyncio.get_event_loop()\n            products = await loop.run_in_executor(None, self.local_service.search_products, keyword, limit)\n            logger.info(f\"Found {len(products)} products for keyword: {keyword}\")\n            return products\n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    async def get_products(self, limit: int = 20, category: Optional[str] = None, search: Optional[str] = None) -> List[Dict]:\n        \"\"\"Get products with optional filtering\"\"\"\n        try:\n            if search:\n                return await self.search_products(search, limit)\n            elif category:\n                return self.get_products_by_category(category, limit)\n            else:\n                return self.get_all_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return self.local_service.get_products(limit)\n    \n    async def get_categories(self) -> List[str]:\n        \"\"\"Get available categories\"\"\"\n        try:\n            return self.local_service.get_categories()\n        except Exception as e:\n            logger.error(f\"Error getting categories: {str(e)}\")\n            return []\n    \n    async def get_top_rated_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get top rated products\"\"\"\n        try:\n            return self.local_service.get_top_rated_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    async def get_best_selling_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get best selling products\"\"\"\n        try:\n            return self.local_service.get_best_selling_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products_by_category(self, category: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by category\"\"\"\n        try:\n            return self.local_service.get_products_by_category(category)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_all_products(self, limit: int = 20) -> List[Dict]:\n        \"\"\"Get all products\"\"\"\n        try:\n            return self.local_service.get_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting all products: {str(e)}\")\n            return []\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"Get product details by ID\"\"\"\n        try:\n            return self.local_service.get_product_details(product_id)\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"Get available brands\"\"\"\n        try:\n            return self.local_service.get_brands()\n        except Exception as e:\n            logger.error(f\"Error getting brands: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by brand\"\"\"\n        try:\n            return self.local_service.get_products_by_brand(brand)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    async def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: gunakan LocalProductService.smart_search_products secara async.\n        Return: (list produk, pesan)\n        \"\"\"\n        import asyncio\n        loop = asyncio.get_event_loop()\n        products, message = await loop.run_in_executor(\n            None, self.local_service.smart_search_products, keyword, category, max_price, limit\n        )\n        return products, message ",
      "existing_test": null
    },
    {
      "filepath": "app/services/local_product_service.py",
      "coverage": 82.42,
      "content": "import logging\nimport json\nimport random\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass LocalProductService:\n    \"\"\"\n    Service untuk data produk lokal yang reliable dan tidak bergantung pada API eksternal\n    \"\"\"\n    \n    def __init__(self):\n        self.products = self._load_local_products()\n        logger.info(f\"Loaded {len(self.products)} local products from JSON file\")\n    \n    def _load_local_products(self) -> List[Dict]:\n        \"\"\"Load produk dari file JSON lokal\"\"\"\n        try:\n            # Get the path to the data/products.json file\n            current_dir = Path(__file__).parent.parent.parent\n            json_file_path = current_dir / \"data\" / \"products.json\"\n            \n            if not json_file_path.exists():\n                logger.error(f\"Products JSON file not found at: {json_file_path}\")\n                return self._get_fallback_products()\n            \n            # Try different encodings\n            encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n            \n            for encoding in encodings:\n                try:\n                    with open(json_file_path, 'r', encoding=encoding) as file:\n                        content = file.read()\n                        # Remove BOM if present\n                        if content.startswith('\\ufeff'):\n                            content = content[1:]\n                        \n                        data = json.loads(content)\n                        products = data.get('products', [])\n                        \n                        # Transform products to match expected format\n                        transformed_products = []\n                        for product in products:\n                            transformed_product = {\n                                \"id\": product.get('id', ''),\n                                \"name\": product.get('name', ''),\n                                \"category\": product.get('category', ''),\n                                \"brand\": product.get('brand', ''),\n                                \"price\": product.get('price', 0),\n                                \"currency\": product.get('currency', 'IDR'),\n                                \"description\": product.get('description', ''),\n                                \"specifications\": {\n                                    \"rating\": product.get('rating', 0),\n                                    \"sold\": random.randint(100, 2000),  # Add random sold count\n                                    \"stock\": product.get('stock_count', 0),\n                                    \"condition\": \"Baru\",\n                                    \"shop_location\": \"Indonesia\",\n                                    \"shop_name\": f\"{product.get('brand', 'Unknown')} Store\",\n                                    **product.get('specifications', {})\n                                },\n                                \"availability\": product.get('availability', 'in_stock'),\n                                \"reviews_count\": product.get('reviews_count', 0),\n                                \"images\": [f\"https://example.com/{product.get('id', 'product')}.jpg\"],\n                                \"url\": f\"https://shopee.co.id/{product.get('id', 'product')}\"\n                            }\n                            transformed_products.append(transformed_product)\n                        \n                        logger.info(f\"Successfully loaded {len(transformed_products)} products from JSON file using {encoding} encoding\")\n                        return transformed_products\n                        \n                except (UnicodeDecodeError, json.JSONDecodeError) as e:\n                    logger.warning(f\"Failed to load with {encoding} encoding: {str(e)}\")\n                    continue\n            \n            # If all encodings fail, use fallback\n            logger.error(\"All encoding attempts failed, using fallback products\")\n            return self._get_fallback_products()\n                \n        except Exception as e:\n            logger.error(f\"Error loading products from JSON file: {str(e)}\")\n            return self._get_fallback_products()\n    \n    def _get_fallback_products(self) -> List[Dict]:\n        \"\"\"Fallback products if JSON file cannot be loaded\"\"\"\n        logger.warning(\"Using fallback products due to JSON file loading error\")\n        return [\n            {\n                \"id\": \"1\",\n                \"name\": \"iPhone 15 Pro Max\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Apple\",\n                \"price\": 25000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPhone 15 Pro Max dengan chip A17 Pro, kamera 48MP, dan layar 6.7 inch Super Retina XDR. Dilengkapi dengan titanium design dan performa gaming yang luar biasa.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 1250,\n                    \"stock\": 50,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Titanium Natural\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"A17 Pro\",\n                    \"camera\": \"48MP Main + 12MP Ultra Wide + 12MP Telephoto\",\n                    \"display\": \"6.7 inch Super Retina XDR\"\n                },\n                \"images\": [\"https://example.com/iphone15.jpg\"],\n                \"url\": \"https://shopee.co.id/iphone-15-pro-max\"\n            },\n            {\n                \"id\": \"2\", \n                \"name\": \"Samsung Galaxy S24 Ultra\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Samsung\",\n                \"price\": 22000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy S24 Ultra dengan S Pen, kamera 200MP, dan AI features canggih. Dilengkapi dengan Snapdragon 8 Gen 3 dan layar AMOLED 6.8 inch.\",\n                \"specifications\": {\n                    \"rating\": 4.7,\n                    \"sold\": 980,\n                    \"stock\": 35,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"512GB\",\n                    \"color\": \"Titanium Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 3\",\n                    \"camera\": \"200MP Main + 12MP Ultra Wide + 50MP Telephoto + 10MP Telephoto\",\n                    \"display\": \"6.8 inch Dynamic AMOLED 2X\"\n                },\n                \"images\": [\"https://example.com/s24-ultra.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-s24-ultra\"\n            },\n            {\n                \"id\": \"3\",\n                \"name\": \"MacBook Pro 14 inch M3\",\n                \"category\": \"Laptop\",\n                \"brand\": \"Apple\",\n                \"price\": 35000000,\n                \"currency\": \"IDR\",\n                \"description\": \"MacBook Pro dengan chip M3, layar 14 inch Liquid Retina XDR, dan performa tinggi untuk profesional. Cocok untuk video editing, programming, dan gaming.\",\n                \"specifications\": {\n                    \"rating\": 4.9,\n                    \"sold\": 450,\n                    \"stock\": 25,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"1TB\",\n                    \"color\": \"Space Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M3\",\n                    \"ram\": \"16GB Unified Memory\",\n                    \"display\": \"14 inch Liquid Retina XDR\"\n                },\n                \"images\": [\"https://example.com/macbook-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/macbook-pro-m3\"\n            },\n            {\n                \"id\": \"4\",\n                \"name\": \"AirPods Pro 2nd Gen\",\n                \"category\": \"Audio\",\n                \"brand\": \"Apple\",\n                \"price\": 4500000,\n                \"currency\": \"IDR\",\n                \"description\": \"AirPods Pro dengan Active Noise Cancellation dan Spatial Audio. Dilengkapi dengan chip H2 untuk performa audio yang lebih baik dan fitur Find My.\",\n                \"specifications\": {\n                    \"rating\": 4.6,\n                    \"sold\": 2100,\n                    \"stock\": 100,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"color\": \"White\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"6 jam dengan ANC, 30 jam dengan case\",\n                    \"features\": \"Active Noise Cancellation, Spatial Audio, Find My\"\n                },\n                \"images\": [\"https://example.com/airpods-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/airpods-pro-2\"\n            },\n            {\n                \"id\": \"5\",\n                \"name\": \"iPad Air 5th Gen\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Apple\",\n                \"price\": 12000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPad Air dengan chip M1, layar 10.9 inch Liquid Retina, dan Apple Pencil support. Cocok untuk kreativitas, note-taking, dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.5,\n                    \"sold\": 750,\n                    \"stock\": 40,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Medan\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Blue\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M1\",\n                    \"display\": \"10.9 inch Liquid Retina\",\n                    \"features\": \"Apple Pencil support, Magic Keyboard support\"\n                },\n                \"images\": [\"https://example.com/ipad-air.jpg\"],\n                \"url\": \"https://shopee.co.id/ipad-air-5\"\n            },\n            {\n                \"id\": \"6\",\n                \"name\": \"ASUS ROG Strix G15\",\n                \"category\": \"Laptop\",\n                \"brand\": \"ASUS\",\n                \"price\": 18000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Laptop gaming ASUS ROG Strix G15 dengan RTX 4060, AMD Ryzen 7, dan layar 15.6 inch 144Hz. Dilengkapi dengan RGB keyboard dan cooling system yang powerful.\",\n                \"specifications\": {\n                    \"rating\": 4.4,\n                    \"sold\": 320,\n                    \"stock\": 15,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"ASUS Store\",\n                    \"storage\": \"512GB SSD\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"2 Tahun\",\n                    \"processor\": \"AMD Ryzen 7 7735HS\",\n                    \"gpu\": \"NVIDIA RTX 4060 8GB\",\n                    \"ram\": \"16GB DDR5\",\n                    \"display\": \"15.6 inch FHD 144Hz\"\n                },\n                \"images\": [\"https://example.com/rog-strix.jpg\"],\n                \"url\": \"https://shopee.co.id/asus-rog-strix-g15\"\n            },\n            {\n                \"id\": \"7\",\n                \"name\": \"Sony WH-1000XM5\",\n                \"category\": \"Audio\",\n                \"brand\": \"Sony\",\n                \"price\": 5500000,\n                \"currency\": \"IDR\",\n                \"description\": \"Headphone wireless Sony WH-1000XM5 dengan noise cancellation terbaik di kelasnya. Dilengkapi dengan 30 jam battery life dan quick charge.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 890,\n                    \"stock\": 30,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Sony Store\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"30 jam dengan ANC\",\n                    \"features\": \"Industry-leading noise cancellation, Quick Charge, Multipoint connection\"\n                },\n                \"images\": [\"https://example.com/sony-wh1000xm5.jpg\"],\n                \"url\": \"https://shopee.co.id/sony-wh1000xm5\"\n            },\n            {\n                \"id\": \"8\",\n                \"name\": \"Samsung Galaxy Tab S9\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Samsung\",\n                \"price\": 15000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy Tab S9 dengan S Pen, layar AMOLED 11 inch, dan Snapdragon 8 Gen 2. Cocok untuk productivity dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.3,\n                    \"sold\": 280,\n                    \"stock\": 20,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Graphite\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 2\",\n                    \"display\": \"11 inch Dynamic AMOLED 2X\",\n                    \"features\": \"S Pen included, DeX mode, Multi-window\"\n                },\n                \"images\": [\"https://example.com/galaxy-tab-s9.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-galaxy-tab-s9\"\n            }\n        ]\n    \n    def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"\n        Search products berdasarkan keyword\n        \"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            \n            keyword_lower = keyword.lower()\n            filtered_products = []\n            \n            # Extract price range from keyword\n            max_price = self._extract_price_from_keyword(keyword)\n            \n            for product in self.products:\n                product_price = product.get('price', 0)\n                \n                # Check if product matches price range\n                if max_price and product_price <= max_price:\n                    filtered_products.append(product)\n                    continue\n                \n                # Search in name, description, category, brand, and specifications\n                searchable_text = (\n                    product.get('name', '') + ' ' +\n                    product.get('description', '') + ' ' +\n                    product.get('category', '') + ' ' +\n                    product.get('brand', '') + ' ' +\n                    str(product.get('specifications', {}))\n                ).lower()\n                \n                if keyword_lower in searchable_text:\n                    filtered_products.append(product)\n            \n            # Sort by relevance (exact matches first, then by price if budget search)\n            def relevance_score(product):\n                score = 0\n                if keyword_lower in product.get('name', '').lower():\n                    score += 10\n                if keyword_lower in product.get('brand', '').lower():\n                    score += 5\n                if keyword_lower in product.get('category', '').lower():\n                    score += 3\n                \n                # For budget searches, prefer lower prices\n                if max_price or any(word in keyword_lower for word in ['murah', 'budget', 'hemat', 'terjangkau']):\n                    score += (10000000 - product.get('price', 0)) / 1000000  # Higher score for lower prices\n                \n                return score\n            \n            filtered_products.sort(key=relevance_score, reverse=True)\n            \n            logger.info(f\"Found {len(filtered_products)} products\")\n            return filtered_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    def _extract_price_from_keyword(self, keyword: str) -> Optional[int]:\n        \"\"\"\n        Extract maximum price from keyword\n        \"\"\"\n        try:\n            keyword_lower = keyword.lower()\n            \n            # Common price patterns\n            price_patterns = [\n                (r'(\\d+)\\s*juta', lambda x: int(x) * 1000000),\n                (r'(\\d+)\\s*ribu', lambda x: int(x) * 1000),\n                (r'rp\\s*(\\d+)', lambda x: int(x)),\n                (r'(\\d+)\\s*rp', lambda x: int(x)),\n                (r'(\\d+)\\s*k', lambda x: int(x) * 1000),\n                (r'(\\d+)\\s*m', lambda x: int(x) * 1000000),\n            ]\n            \n            import re\n            for pattern, converter in price_patterns:\n                match = re.search(pattern, keyword_lower)\n                if match:\n                    return converter(match.group(1))\n            \n            # Budget keywords\n            budget_keywords = {\n                'murah': 5000000,  # 5 juta\n                'budget': 5000000,\n                'hemat': 3000000,  # 3 juta\n                'terjangkau': 4000000,  # 4 juta\n                'ekonomis': 2000000,  # 2 juta\n            }\n            \n            for word, max_price in budget_keywords.items():\n                if word in keyword_lower:\n                    return max_price\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error extracting price from keyword: {str(e)}\")\n            return None\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"\n        Get detail produk berdasarkan ID\n        \"\"\"\n        try:\n            for product in self.products:\n                if product.get('id') == product_id:\n                    return product\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_categories(self) -> List[str]:\n        \"\"\"\n        Get daftar kategori produk\n        \"\"\"\n        categories = set()\n        for product in self.products:\n            categories.add(product.get('category', ''))\n        return sorted(list(categories))\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"\n        Get daftar brand produk\n        \"\"\"\n        brands = set()\n        for product in self.products:\n            brands.add(product.get('brand', ''))\n        return sorted(list(brands))\n    \n    def get_products_by_category(self, category: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan kategori\n        \"\"\"\n        try:\n            category_lower = category.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if category_lower in product.get('category', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan brand\n        \"\"\"\n        try:\n            brand_lower = brand.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if brand_lower in product.get('brand', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    def get_top_rated_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"\n        Get produk dengan rating tertinggi\n        \"\"\"\n        try:\n            sorted_products = sorted(\n                self.products, \n                key=lambda x: x.get('specifications', {}).get('rating', 0), \n                reverse=True\n            )\n            return sorted_products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    def get_best_selling_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"Get produk dengan penjualan tertinggi\"\"\"\n        try:\n            logger.info(f\"Getting best selling products, limit: {limit}\")\n            \n            # Sort berdasarkan sold count\n            sorted_products = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n            \n            logger.info(f\"Returning {min(limit, len(sorted_products))} best selling products\")\n            return sorted_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get semua produk\"\"\"\n        try:\n            logger.info(f\"Getting all products, limit: {limit}\")\n            return self.products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return []\n    \n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: cari produk sesuai kriteria, lalu fallback bertingkat dengan notifikasi.\n        Return: (list produk, pesan)\n        \"\"\"\n        keyword_lower = (keyword or '').lower()\n        \n        # Deteksi permintaan \"terbaik\"\n        is_best_request = 'terbaik' in keyword_lower or 'best' in keyword_lower\n        \n        # 1. Jika user minta \"terbaik\" tanpa kategori spesifik\n        if is_best_request and not category:\n            # Tampilkan produk terbaik secara umum (top 5 berdasarkan rating)\n            best_products = sorted(self.products, \n                                 key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                 reverse=True)\n            return best_products[:limit], \"Berikut produk terbaik berdasarkan rating:\"\n        \n        # 2. Jika user minta \"terbaik\" dengan kategori spesifik\n        if is_best_request and category:\n            category_products = [p for p in self.products \n                               if category.lower() in p.get('category', '').lower()]\n            if category_products:\n                category_products.sort(key=lambda x: x.get('specifications', {}).get('rating', 0), reverse=True)\n                return category_products[:limit], f\"Berikut {category} terbaik berdasarkan rating:\"\n            else:\n                # Fallback ke produk terbaik secara umum jika kategori tidak ditemukan\n                best_products = sorted(self.products, \n                                     key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                     reverse=True)\n                return best_products[:limit], f\"Tidak ada produk kategori {category}, berikut produk terbaik secara umum:\"\n        \n        # 3. Cari produk yang memenuhi semua kriteria (non-terbaik)\n        results = [\n            p for p in self.products\n            if (not category or category.lower() in p.get('category', '').lower())\n            and (not max_price or p.get('price', 0) <= max_price)\n            and (not keyword or keyword_lower in (p.get('name', '') + ' ' + p.get('description', '') + ' ' + p.get('category', '') + ' ' + p.get('brand', '') + str(p.get('specifications', {}))).lower())\n        ]\n        if results:\n            return results[:limit], \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n        # 4. Jika tidak ada, cari produk di kategori yang sama (tanpa filter harga)\n        if category:\n            category_results = [\n                p for p in self.products\n                if category.lower() in p.get('category', '').lower()\n            ]\n            if category_results:\n                category_results.sort(key=lambda x: x.get('price', 0))\n                return category_results[:limit], \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\n        # 5. Jika tetap tidak ada, tampilkan produk lain yang sesuai budget\n        if max_price:\n            budget_results = [\n                p for p in self.products\n                if p.get('price', 0) <= max_price\n            ]\n            if budget_results:\n                return budget_results[:limit], \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\n        # 6. Jika tetap tidak ada, tampilkan produk terpopuler/terlaris\n        popular_results = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n        return popular_results[:limit], \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\" ",
      "existing_test": null
    },
    {
      "filepath": "app/api/queries.py",
      "coverage": 94.17,
      "content": "import logging\nfrom typing import List, Dict\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\nfrom app.services.product_data_service import ProductDataService\nfrom app.services.ai_service import AIService\nimport re\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nproduct_service = ProductDataService()\nai_service = AIService()\n\nclass QueryRequest(BaseModel):\n    question: str\n\nclass QueryResponse(BaseModel):\n    answer: str\n    products: List[dict]\n    question: str\n    note: str\n\n@router.post(\"/ask\", response_model=QueryResponse)\nasync def ask_question(request: QueryRequest):\n    \"\"\"Ask a question about products and get recommendations\"\"\"\n    try:\n        # Get AI response\n        ai_response = await ai_service.get_response(request.question)\n        \n        # Get relevant products and fallback message\n        # Ekstrak kategori dan max_price dari pertanyaan (sederhana)\n        category = None\n        max_price = None\n        \n        # Deteksi kategori dengan lebih lengkap\n        question_lower = request.question.lower()\n        category_mapping = {\n            'laptop': ['laptop', 'notebook', 'komputer'],\n            'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],\n            'tablet': ['tablet', 'ipad'],\n            'headphone': ['headphone', 'earphone', 'headset', 'audio'],\n            'kamera': ['kamera', 'camera', 'fotografi'],\n            'audio': ['audio', 'speaker', 'sound'],\n            'tv': ['tv', 'televisi'],\n            'drone': ['drone', 'quadcopter'],\n            'jam': ['jam', 'watch', 'smartwatch']\n        }\n        \n        for cat, keywords in category_mapping.items():\n            if any(keyword in question_lower for keyword in keywords):\n                category = cat\n                break\n        \n        # Deteksi budget\n        price_match = re.search(r'(\\d+)\\s*juta', question_lower)\n        if price_match:\n            max_price = int(price_match.group(1)) * 1000000\n        elif 'budget' in question_lower or 'murah' in question_lower:\n            max_price = 5000000\n            \n        products, fallback_message = await product_service.smart_search_products(\n            keyword=request.question, category=category, max_price=max_price, limit=5\n        )\n        \n        return QueryResponse(\n            answer=ai_response,\n            products=products,\n            question=request.question,\n            note=fallback_message\n        )\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n@router.get(\"/suggestions\")\nasync def get_suggestions():\n    \"\"\"Get suggested questions\"\"\"\n    suggestions = [\n        \"Apa produk terbaik untuk gaming?\",\n        \"Rekomendasi laptop untuk kerja\",\n        \"Smartphone dengan kamera terbaik\",\n        \"Headphone wireless dengan kualitas bagus\",\n        \"Produk untuk rumah tangga\",\n        \"Gadget untuk produktivitas\",\n        \"Tablet untuk kreativitas\",\n        \"Smartwatch untuk olahraga\"\n    ]\n    return {\"suggestions\": suggestions}\n\n@router.get(\"/categories\")\nasync def get_categories():\n    \"\"\"Get available product categories\"\"\"\n    try:\n        categories = await product_service.get_categories()\n        return {\"categories\": categories}\n    except Exception as e:\n        logger.error(f\"Error getting categories: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting categories\")\n\n@router.get(\"/brands\")\nasync def get_brands():\n    \"\"\"Get available product brands\"\"\"\n    try:\n        brands = product_service.get_brands()\n        return {\"brands\": brands}\n    except Exception as e:\n        logger.error(f\"Error getting brands: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting brands\")\n\n@router.get(\"/products/search\")\nasync def search_products(keyword: str, limit: int = 10):\n    \"\"\"Search products directly\"\"\"\n    try:\n        products = await product_service.search_products(keyword, limit)\n        return {\n            \"products\": products,\n            \"count\": len(products),\n            \"keyword\": keyword,\n            \"source\": \"local\"\n        }\n    except Exception as e:\n        logger.error(f\"Error searching products: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error searching products\")\n\n@router.get(\"/products/category/{category}\")\nasync def get_products_by_category(category: str):\n    \"\"\"Get products by category\"\"\"\n    try:\n        products = product_service.get_products_by_category(category, limit=20)\n        return {\n            \"products\": products,\n            \"count\": len(products),\n            \"category\": category,\n            \"source\": \"local\"\n        }\n    except Exception as e:\n        logger.error(f\"Error getting products by category: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting products by category\")\n\n@router.get(\"/products/brand/{brand}\")\nasync def get_products_by_brand(brand: str):\n    \"\"\"Get products by brand\"\"\"\n    try:\n        products = product_service.get_products_by_brand(brand, limit=20)\n        return {\n            \"products\": products,\n            \"count\": len(products),\n            \"brand\": brand,\n            \"source\": \"local\"\n        }\n    except Exception as e:\n        logger.error(f\"Error getting products by brand: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting products by brand\")\n\n@router.get(\"/products/top-rated\")\nasync def get_top_rated_products(limit: int = 5):\n    \"\"\"Get top rated products\"\"\"\n    try:\n        products = await product_service.get_top_rated_products(limit)\n        return {\n            \"products\": products,\n            \"count\": len(products),\n            \"source\": \"local\"\n        }\n    except Exception as e:\n        logger.error(f\"Error getting top rated products: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting top rated products\")\n\n@router.get(\"/products/best-selling\")\nasync def get_best_selling_products(limit: int = 5):\n    \"\"\"Get best selling products\"\"\"\n    try:\n        products = await product_service.get_best_selling_products(limit)\n        return {\n            \"products\": products,\n            \"count\": len(products),\n            \"source\": \"local\"\n        }\n    except Exception as e:\n        logger.error(f\"Error getting best selling products: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting best selling products\")\n\n@router.get(\"/products/{product_id}\")\nasync def get_product_details(product_id: str):\n    \"\"\"Get detailed information about a specific product\"\"\"\n    try:\n        product = product_service.get_product_details(product_id)\n        if product:\n            return {\"product\": product, \"source\": \"local\"}\n        else:\n            raise HTTPException(status_code=404, detail=\"Product not found\")\n    except HTTPException:\n        raise\n    except Exception as e:\n        logger.error(f\"Error getting product details: {str(e)}\")\n        raise HTTPException(status_code=500, detail=\"Error getting product details\")\n\n@router.get(\"/test-connection\")\nasync def test_connection():\n    \"\"\"Test connection to local data source\"\"\"\n    try:\n        products = product_service.get_all_products(limit=1)\n        success = len(products) > 0\n        return {\n            \"success\": success,\n            \"message\": \"Local data source test completed\",\n            \"source\": \"local\",\n            \"products_count\": len(product_service.local_service.products)\n        }\n    except Exception as e:\n        logger.error(f\"Error testing connection: {str(e)}\")\n        return {\n            \"success\": False,\n            \"message\": f\"Local data source test failed: {str(e)}\",\n            \"source\": \"local\"\n        } ",
      "existing_test": null
    },
    {
      "filepath": "app/services/ai_service.py",
      "coverage": 98.39,
      "content": "import logging\nfrom google import genai\nfrom app.utils.config import get_settings\nfrom app.services.product_data_service import ProductDataService\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass AIService:\n    def __init__(self):\n        \"\"\"Initialize AI service with Google AI API\"\"\"\n        try:\n            settings = get_settings()\n            # Use the new Google AI client\n            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)\n            self.product_service = ProductDataService()\n            logger.info(\"Successfully initialized AI service with Google AI client\")\n        except Exception as e:\n            logger.error(f\"Error initializing AI service: {str(e)}\")\n            raise\n\n    async def get_response(self, question: str) -> str:\n        \"\"\"Get AI response with product context and fallback message\"\"\"\n        try:\n            logger.info(f\"Getting AI response for question: {question}\")\n\n            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)\n            import re\n            category = None\n            max_price = None\n            \n            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)\n            question_lower = question.lower()\n            category_mapping = {\n                'laptop': ['laptop', 'notebook', 'komputer'],\n                'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],\n                'tablet': ['tablet', 'ipad'],\n                'headphone': ['headphone', 'earphone', 'headset', 'audio'],\n                'kamera': ['kamera', 'camera', 'fotografi'],\n                'audio': ['audio', 'speaker', 'sound'],\n                'tv': ['tv', 'televisi'],\n                'drone': ['drone', 'quadcopter'],\n                'jam': ['jam', 'watch', 'smartwatch']\n            }\n            \n            for cat, keywords in category_mapping.items():\n                if any(keyword in question_lower for keyword in keywords):\n                    category = cat\n                    break\n            \n            # Deteksi budget\n            price_match = re.search(r'(\\d+)\\s*juta', question_lower)\n            if price_match:\n                max_price = int(price_match.group(1)) * 1000000\n            elif 'budget' in question_lower or 'murah' in question_lower:\n                max_price = 5000000\n\n            # Gunakan smart_search_products\n            products, fallback_message = await self.product_service.smart_search_products(\n                keyword=question, category=category, max_price=max_price, limit=5\n            )\n\n            # Build context\n            context = f\"Question: {question}\\n\\n\"\n            context += f\"{fallback_message}\\n\\n\"\n            if products:\n                context += \"Relevant Products:\\n\"\n                for i, product in enumerate(products, 1):\n                    context += f\"{i}. {product.get('name', 'Unknown')}\\n\"\n                    context += f\"   Price: Rp {product.get('price', 0):,.0f}\\n\"\n                    context += f\"   Brand: {product.get('brand', 'Unknown')}\\n\"\n                    context += f\"   Category: {product.get('category', 'Unknown')}\\n\"\n                    context += f\"   Rating: {product.get('specifications', {}).get('rating', 0)}/5\\n\"\n                    context += f\"   Description: {product.get('description', 'No description')[:200]}...\\n\\n\"\n            else:\n                context += \"No specific products found, but I can provide general recommendations.\\n\\n\"\n\n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\\n\\n{context}\\n\\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision. Focus on being helpful and natural in your response.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n        \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            return \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n\n    def generate_response(self, context: str) -> str:\n        \"\"\"Generate response using Google AI (legacy method)\"\"\"\n        try:\n            logger.info(\"Generating AI response\")\n            \n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.0-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n            \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            raise ",
      "existing_test": null
    }
  ]
}