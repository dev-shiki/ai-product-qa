{
  "timestamp": "/home/runner/work/ai-product-qa/ai-product-qa",
  "total_files": 17,
  "coverage_data": {
    ".": 0.0,
    "main.py": 0.0,
    "api": 0.0,
    "api/__init__.py": 100.0,
    "api/products.py": 0.0,
    "api/queries.py": 0.0,
    "models": 100.0,
    "models/__init__.py": 100.0,
    "models/product.py": 100.0,
    "services": 12.58,
    "services/__init__.py": 100.0,
    "services/ai_service.py": 4.839,
    "services/local_product_service.py": 11.540000000000001,
    "services/product_data_service.py": 20.73,
    "utils": 86.36,
    "utils/__init__.py": 100.0,
    "utils/config.py": 86.36
  },
  "lowest_coverage_files": [
    {
      "filepath": "app/services/ai_service.py",
      "coverage": 4.839,
      "content": "import logging\nfrom google import genai\nfrom app.utils.config import get_settings\nfrom app.services.product_data_service import ProductDataService\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass AIService:\n    def __init__(self):\n        \"\"\"Initialize AI service with Google AI API\"\"\"\n        try:\n            settings = get_settings()\n            # Use the new Google AI client\n            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)\n            self.product_service = ProductDataService()\n            logger.info(\"Successfully initialized AI service with Google AI client\")\n        except Exception as e:\n            logger.error(f\"Error initializing AI service: {str(e)}\")\n            raise\n\n    async def get_response(self, question: str) -> str:\n        \"\"\"Get AI response with product context and fallback message\"\"\"\n        try:\n            logger.info(f\"Getting AI response for question: {question}\")\n\n            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)\n            import re\n            category = None\n            max_price = None\n            \n            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)\n            question_lower = question.lower()\n            category_mapping = {\n                'laptop': ['laptop', 'notebook', 'komputer'],\n                'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],\n                'tablet': ['tablet', 'ipad'],\n                'headphone': ['headphone', 'earphone', 'headset', 'audio'],\n                'kamera': ['kamera', 'camera', 'fotografi'],\n                'audio': ['audio', 'speaker', 'sound'],\n                'tv': ['tv', 'televisi'],\n                'drone': ['drone', 'quadcopter'],\n                'jam': ['jam', 'watch', 'smartwatch']\n            }\n            \n            for cat, keywords in category_mapping.items():\n                if any(keyword in question_lower for keyword in keywords):\n                    category = cat\n                    break\n            \n            # Deteksi budget\n            price_match = re.search(r'(\\d+)\\s*juta', question_lower)\n            if price_match:\n                max_price = int(price_match.group(1)) * 1000000\n            elif 'budget' in question_lower or 'murah' in question_lower:\n                max_price = 5000000\n\n            # Gunakan smart_search_products\n            products, fallback_message = await self.product_service.smart_search_products(\n                keyword=question, category=category, max_price=max_price, limit=5\n            )\n\n            # Build context\n            context = f\"Question: {question}\\n\\n\"\n            context += f\"{fallback_message}\\n\\n\"\n            if products:\n                context += \"Relevant Products:\\n\"\n                for i, product in enumerate(products, 1):\n                    context += f\"{i}. {product.get('name', 'Unknown')}\\n\"\n                    context += f\"   Price: Rp {product.get('price', 0):,.0f}\\n\"\n                    context += f\"   Brand: {product.get('brand', 'Unknown')}\\n\"\n                    context += f\"   Category: {product.get('category', 'Unknown')}\\n\"\n                    context += f\"   Rating: {product.get('specifications', {}).get('rating', 0)}/5\\n\"\n                    context += f\"   Description: {product.get('description', 'No description')[:200]}...\\n\\n\"\n            else:\n                context += \"No specific products found, but I can provide general recommendations.\\n\\n\"\n\n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\\n\\n{context}\\n\\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision. Focus on being helpful and natural in your response.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n        \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            return \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n\n    def generate_response(self, context: str) -> str:\n        \"\"\"Generate response using Google AI (legacy method)\"\"\"\n        try:\n            logger.info(\"Generating AI response\")\n            \n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.0-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n            \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            raise ",
      "existing_test": null
    },
    {
      "filepath": "app/services/local_product_service.py",
      "coverage": 11.540000000000001,
      "content": "import logging\nimport json\nimport random\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass LocalProductService:\n    \"\"\"\n    Service untuk data produk lokal yang reliable dan tidak bergantung pada API eksternal\n    \"\"\"\n    \n    def __init__(self):\n        self.products = self._load_local_products()\n        logger.info(f\"Loaded {len(self.products)} local products from JSON file\")\n    \n    def _load_local_products(self) -> List[Dict]:\n        \"\"\"Load produk dari file JSON lokal\"\"\"\n        try:\n            # Get the path to the data/products.json file\n            current_dir = Path(__file__).parent.parent.parent\n            json_file_path = current_dir / \"data\" / \"products.json\"\n            \n            if not json_file_path.exists():\n                logger.error(f\"Products JSON file not found at: {json_file_path}\")\n                return self._get_fallback_products()\n            \n            # Try different encodings\n            encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n            \n            for encoding in encodings:\n                try:\n                    with open(json_file_path, 'r', encoding=encoding) as file:\n                        content = file.read()\n                        # Remove BOM if present\n                        if content.startswith('\\ufeff'):\n                            content = content[1:]\n                        \n                        data = json.loads(content)\n                        products = data.get('products', [])\n                        \n                        # Transform products to match expected format\n                        transformed_products = []\n                        for product in products:\n                            transformed_product = {\n                                \"id\": product.get('id', ''),\n                                \"name\": product.get('name', ''),\n                                \"category\": product.get('category', ''),\n                                \"brand\": product.get('brand', ''),\n                                \"price\": product.get('price', 0),\n                                \"currency\": product.get('currency', 'IDR'),\n                                \"description\": product.get('description', ''),\n                                \"specifications\": {\n                                    \"rating\": product.get('rating', 0),\n                                    \"sold\": random.randint(100, 2000),  # Add random sold count\n                                    \"stock\": product.get('stock_count', 0),\n                                    \"condition\": \"Baru\",\n                                    \"shop_location\": \"Indonesia\",\n                                    \"shop_name\": f\"{product.get('brand', 'Unknown')} Store\",\n                                    **product.get('specifications', {})\n                                },\n                                \"availability\": product.get('availability', 'in_stock'),\n                                \"reviews_count\": product.get('reviews_count', 0),\n                                \"images\": [f\"https://example.com/{product.get('id', 'product')}.jpg\"],\n                                \"url\": f\"https://shopee.co.id/{product.get('id', 'product')}\"\n                            }\n                            transformed_products.append(transformed_product)\n                        \n                        logger.info(f\"Successfully loaded {len(transformed_products)} products from JSON file using {encoding} encoding\")\n                        return transformed_products\n                        \n                except (UnicodeDecodeError, json.JSONDecodeError) as e:\n                    logger.warning(f\"Failed to load with {encoding} encoding: {str(e)}\")\n                    continue\n            \n            # If all encodings fail, use fallback\n            logger.error(\"All encoding attempts failed, using fallback products\")\n            return self._get_fallback_products()\n                \n        except Exception as e:\n            logger.error(f\"Error loading products from JSON file: {str(e)}\")\n            return self._get_fallback_products()\n    \n    def _get_fallback_products(self) -> List[Dict]:\n        \"\"\"Fallback products if JSON file cannot be loaded\"\"\"\n        logger.warning(\"Using fallback products due to JSON file loading error\")\n        return [\n            {\n                \"id\": \"1\",\n                \"name\": \"iPhone 15 Pro Max\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Apple\",\n                \"price\": 25000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPhone 15 Pro Max dengan chip A17 Pro, kamera 48MP, dan layar 6.7 inch Super Retina XDR. Dilengkapi dengan titanium design dan performa gaming yang luar biasa.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 1250,\n                    \"stock\": 50,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Titanium Natural\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"A17 Pro\",\n                    \"camera\": \"48MP Main + 12MP Ultra Wide + 12MP Telephoto\",\n                    \"display\": \"6.7 inch Super Retina XDR\"\n                },\n                \"images\": [\"https://example.com/iphone15.jpg\"],\n                \"url\": \"https://shopee.co.id/iphone-15-pro-max\"\n            },\n            {\n                \"id\": \"2\", \n                \"name\": \"Samsung Galaxy S24 Ultra\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Samsung\",\n                \"price\": 22000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy S24 Ultra dengan S Pen, kamera 200MP, dan AI features canggih. Dilengkapi dengan Snapdragon 8 Gen 3 dan layar AMOLED 6.8 inch.\",\n                \"specifications\": {\n                    \"rating\": 4.7,\n                    \"sold\": 980,\n                    \"stock\": 35,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"512GB\",\n                    \"color\": \"Titanium Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 3\",\n                    \"camera\": \"200MP Main + 12MP Ultra Wide + 50MP Telephoto + 10MP Telephoto\",\n                    \"display\": \"6.8 inch Dynamic AMOLED 2X\"\n                },\n                \"images\": [\"https://example.com/s24-ultra.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-s24-ultra\"\n            },\n            {\n                \"id\": \"3\",\n                \"name\": \"MacBook Pro 14 inch M3\",\n                \"category\": \"Laptop\",\n                \"brand\": \"Apple\",\n                \"price\": 35000000,\n                \"currency\": \"IDR\",\n                \"description\": \"MacBook Pro dengan chip M3, layar 14 inch Liquid Retina XDR, dan performa tinggi untuk profesional. Cocok untuk video editing, programming, dan gaming.\",\n                \"specifications\": {\n                    \"rating\": 4.9,\n                    \"sold\": 450,\n                    \"stock\": 25,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"1TB\",\n                    \"color\": \"Space Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M3\",\n                    \"ram\": \"16GB Unified Memory\",\n                    \"display\": \"14 inch Liquid Retina XDR\"\n                },\n                \"images\": [\"https://example.com/macbook-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/macbook-pro-m3\"\n            },\n            {\n                \"id\": \"4\",\n                \"name\": \"AirPods Pro 2nd Gen\",\n                \"category\": \"Audio\",\n                \"brand\": \"Apple\",\n                \"price\": 4500000,\n                \"currency\": \"IDR\",\n                \"description\": \"AirPods Pro dengan Active Noise Cancellation dan Spatial Audio. Dilengkapi dengan chip H2 untuk performa audio yang lebih baik dan fitur Find My.\",\n                \"specifications\": {\n                    \"rating\": 4.6,\n                    \"sold\": 2100,\n                    \"stock\": 100,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"color\": \"White\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"6 jam dengan ANC, 30 jam dengan case\",\n                    \"features\": \"Active Noise Cancellation, Spatial Audio, Find My\"\n                },\n                \"images\": [\"https://example.com/airpods-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/airpods-pro-2\"\n            },\n            {\n                \"id\": \"5\",\n                \"name\": \"iPad Air 5th Gen\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Apple\",\n                \"price\": 12000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPad Air dengan chip M1, layar 10.9 inch Liquid Retina, dan Apple Pencil support. Cocok untuk kreativitas, note-taking, dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.5,\n                    \"sold\": 750,\n                    \"stock\": 40,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Medan\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Blue\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M1\",\n                    \"display\": \"10.9 inch Liquid Retina\",\n                    \"features\": \"Apple Pencil support, Magic Keyboard support\"\n                },\n                \"images\": [\"https://example.com/ipad-air.jpg\"],\n                \"url\": \"https://shopee.co.id/ipad-air-5\"\n            },\n            {\n                \"id\": \"6\",\n                \"name\": \"ASUS ROG Strix G15\",\n                \"category\": \"Laptop\",\n                \"brand\": \"ASUS\",\n                \"price\": 18000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Laptop gaming ASUS ROG Strix G15 dengan RTX 4060, AMD Ryzen 7, dan layar 15.6 inch 144Hz. Dilengkapi dengan RGB keyboard dan cooling system yang powerful.\",\n                \"specifications\": {\n                    \"rating\": 4.4,\n                    \"sold\": 320,\n                    \"stock\": 15,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"ASUS Store\",\n                    \"storage\": \"512GB SSD\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"2 Tahun\",\n                    \"processor\": \"AMD Ryzen 7 7735HS\",\n                    \"gpu\": \"NVIDIA RTX 4060 8GB\",\n                    \"ram\": \"16GB DDR5\",\n                    \"display\": \"15.6 inch FHD 144Hz\"\n                },\n                \"images\": [\"https://example.com/rog-strix.jpg\"],\n                \"url\": \"https://shopee.co.id/asus-rog-strix-g15\"\n            },\n            {\n                \"id\": \"7\",\n                \"name\": \"Sony WH-1000XM5\",\n                \"category\": \"Audio\",\n                \"brand\": \"Sony\",\n                \"price\": 5500000,\n                \"currency\": \"IDR\",\n                \"description\": \"Headphone wireless Sony WH-1000XM5 dengan noise cancellation terbaik di kelasnya. Dilengkapi dengan 30 jam battery life dan quick charge.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 890,\n                    \"stock\": 30,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Sony Store\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"30 jam dengan ANC\",\n                    \"features\": \"Industry-leading noise cancellation, Quick Charge, Multipoint connection\"\n                },\n                \"images\": [\"https://example.com/sony-wh1000xm5.jpg\"],\n                \"url\": \"https://shopee.co.id/sony-wh1000xm5\"\n            },\n            {\n                \"id\": \"8\",\n                \"name\": \"Samsung Galaxy Tab S9\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Samsung\",\n                \"price\": 15000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy Tab S9 dengan S Pen, layar AMOLED 11 inch, dan Snapdragon 8 Gen 2. Cocok untuk productivity dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.3,\n                    \"sold\": 280,\n                    \"stock\": 20,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Graphite\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 2\",\n                    \"display\": \"11 inch Dynamic AMOLED 2X\",\n                    \"features\": \"S Pen included, DeX mode, Multi-window\"\n                },\n                \"images\": [\"https://example.com/galaxy-tab-s9.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-galaxy-tab-s9\"\n            }\n        ]\n    \n    def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"\n        Search products berdasarkan keyword\n        \"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            \n            keyword_lower = keyword.lower()\n            filtered_products = []\n            \n            # Extract price range from keyword\n            max_price = self._extract_price_from_keyword(keyword)\n            \n            for product in self.products:\n                product_price = product.get('price', 0)\n                \n                # Check if product matches price range\n                if max_price and product_price <= max_price:\n                    filtered_products.append(product)\n                    continue\n                \n                # Search in name, description, category, brand, and specifications\n                searchable_text = (\n                    product.get('name', '') + ' ' +\n                    product.get('description', '') + ' ' +\n                    product.get('category', '') + ' ' +\n                    product.get('brand', '') + ' ' +\n                    str(product.get('specifications', {}))\n                ).lower()\n                \n                if keyword_lower in searchable_text:\n                    filtered_products.append(product)\n            \n            # Sort by relevance (exact matches first, then by price if budget search)\n            def relevance_score(product):\n                score = 0\n                if keyword_lower in product.get('name', '').lower():\n                    score += 10\n                if keyword_lower in product.get('brand', '').lower():\n                    score += 5\n                if keyword_lower in product.get('category', '').lower():\n                    score += 3\n                \n                # For budget searches, prefer lower prices\n                if max_price or any(word in keyword_lower for word in ['murah', 'budget', 'hemat', 'terjangkau']):\n                    score += (10000000 - product.get('price', 0)) / 1000000  # Higher score for lower prices\n                \n                return score\n            \n            filtered_products.sort(key=relevance_score, reverse=True)\n            \n            logger.info(f\"Found {len(filtered_products)} products\")\n            return filtered_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    def _extract_price_from_keyword(self, keyword: str) -> Optional[int]:\n        \"\"\"\n        Extract maximum price from keyword\n        \"\"\"\n        try:\n            keyword_lower = keyword.lower()\n            \n            # Common price patterns\n            price_patterns = [\n                (r'(\\d+)\\s*juta', lambda x: int(x) * 1000000),\n                (r'(\\d+)\\s*ribu', lambda x: int(x) * 1000),\n                (r'rp\\s*(\\d+)', lambda x: int(x)),\n                (r'(\\d+)\\s*rp', lambda x: int(x)),\n                (r'(\\d+)\\s*k', lambda x: int(x) * 1000),\n                (r'(\\d+)\\s*m', lambda x: int(x) * 1000000),\n            ]\n            \n            import re\n            for pattern, converter in price_patterns:\n                match = re.search(pattern, keyword_lower)\n                if match:\n                    return converter(match.group(1))\n            \n            # Budget keywords\n            budget_keywords = {\n                'murah': 5000000,  # 5 juta\n                'budget': 5000000,\n                'hemat': 3000000,  # 3 juta\n                'terjangkau': 4000000,  # 4 juta\n                'ekonomis': 2000000,  # 2 juta\n            }\n            \n            for word, max_price in budget_keywords.items():\n                if word in keyword_lower:\n                    return max_price\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error extracting price from keyword: {str(e)}\")\n            return None\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"\n        Get detail produk berdasarkan ID\n        \"\"\"\n        try:\n            for product in self.products:\n                if product.get('id') == product_id:\n                    return product\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_categories(self) -> List[str]:\n        \"\"\"\n        Get daftar kategori produk\n        \"\"\"\n        categories = set()\n        for product in self.products:\n            categories.add(product.get('category', ''))\n        return sorted(list(categories))\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"\n        Get daftar brand produk\n        \"\"\"\n        brands = set()\n        for product in self.products:\n            brands.add(product.get('brand', ''))\n        return sorted(list(brands))\n    \n    def get_products_by_category(self, category: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan kategori\n        \"\"\"\n        try:\n            category_lower = category.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if category_lower in product.get('category', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan brand\n        \"\"\"\n        try:\n            brand_lower = brand.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if brand_lower in product.get('brand', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    def get_top_rated_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"\n        Get produk dengan rating tertinggi\n        \"\"\"\n        try:\n            sorted_products = sorted(\n                self.products, \n                key=lambda x: x.get('specifications', {}).get('rating', 0), \n                reverse=True\n            )\n            return sorted_products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    def get_best_selling_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"Get produk dengan penjualan tertinggi\"\"\"\n        try:\n            logger.info(f\"Getting best selling products, limit: {limit}\")\n            \n            # Sort berdasarkan sold count\n            sorted_products = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n            \n            logger.info(f\"Returning {min(limit, len(sorted_products))} best selling products\")\n            return sorted_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get semua produk\"\"\"\n        try:\n            logger.info(f\"Getting all products, limit: {limit}\")\n            return self.products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return []\n    \n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: cari produk sesuai kriteria, lalu fallback bertingkat dengan notifikasi.\n        Return: (list produk, pesan)\n        \"\"\"\n        keyword_lower = (keyword or '').lower()\n        \n        # Deteksi permintaan \"terbaik\"\n        is_best_request = 'terbaik' in keyword_lower or 'best' in keyword_lower\n        \n        # 1. Jika user minta \"terbaik\" tanpa kategori spesifik\n        if is_best_request and not category:\n            # Tampilkan produk terbaik secara umum (top 5 berdasarkan rating)\n            best_products = sorted(self.products, \n                                 key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                 reverse=True)\n            return best_products[:limit], \"Berikut produk terbaik berdasarkan rating:\"\n        \n        # 2. Jika user minta \"terbaik\" dengan kategori spesifik\n        if is_best_request and category:\n            category_products = [p for p in self.products \n                               if category.lower() in p.get('category', '').lower()]\n            if category_products:\n                category_products.sort(key=lambda x: x.get('specifications', {}).get('rating', 0), reverse=True)\n                return category_products[:limit], f\"Berikut {category} terbaik berdasarkan rating:\"\n            else:\n                # Fallback ke produk terbaik secara umum jika kategori tidak ditemukan\n                best_products = sorted(self.products, \n                                     key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                     reverse=True)\n                return best_products[:limit], f\"Tidak ada produk kategori {category}, berikut produk terbaik secara umum:\"\n        \n        # 3. Cari produk yang memenuhi semua kriteria (non-terbaik)\n        results = [\n            p for p in self.products\n            if (not category or category.lower() in p.get('category', '').lower())\n            and (not max_price or p.get('price', 0) <= max_price)\n            and (not keyword or keyword_lower in (p.get('name', '') + ' ' + p.get('description', '') + ' ' + p.get('category', '') + ' ' + p.get('brand', '') + str(p.get('specifications', {}))).lower())\n        ]\n        if results:\n            return results[:limit], \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n        # 4. Jika tidak ada, cari produk di kategori yang sama (tanpa filter harga)\n        if category:\n            category_results = [\n                p for p in self.products\n                if category.lower() in p.get('category', '').lower()\n            ]\n            if category_results:\n                category_results.sort(key=lambda x: x.get('price', 0))\n                return category_results[:limit], \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\n        # 5. Jika tetap tidak ada, tampilkan produk lain yang sesuai budget\n        if max_price:\n            budget_results = [\n                p for p in self.products\n                if p.get('price', 0) <= max_price\n            ]\n            if budget_results:\n                return budget_results[:limit], \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\n        # 6. Jika tetap tidak ada, tampilkan produk terpopuler/terlaris\n        popular_results = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n        return popular_results[:limit], \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\" ",
      "existing_test": null
    },
    {
      "filepath": "app/services/product_data_service.py",
      "coverage": 20.73,
      "content": "import logging\nfrom typing import List, Dict, Optional\nfrom app.services.local_product_service import LocalProductService\n\nlogger = logging.getLogger(__name__)\n\nclass ProductDataService:\n    \"\"\"\n    Service untuk mengambil data produk dari sumber lokal yang reliable\n    \"\"\"\n    \n    def __init__(self):\n        # Use LocalProductService as primary data source\n        self.local_service = LocalProductService()\n        logger.info(\"ProductDataService initialized with LocalProductService\")\n    \n    async def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Search products using local data\"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            # Use awaitable wrapper for sync method\n            import asyncio\n            loop = asyncio.get_event_loop()\n            products = await loop.run_in_executor(None, self.local_service.search_products, keyword, limit)\n            logger.info(f\"Found {len(products)} products for keyword: {keyword}\")\n            return products\n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    async def get_products(self, limit: int = 20, category: Optional[str] = None, search: Optional[str] = None) -> List[Dict]:\n        \"\"\"Get products with optional filtering\"\"\"\n        try:\n            if search:\n                return await self.search_products(search, limit)\n            elif category:\n                return self.get_products_by_category(category, limit)\n            else:\n                return self.get_all_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return self.local_service.get_products(limit)\n    \n    async def get_categories(self) -> List[str]:\n        \"\"\"Get available categories\"\"\"\n        try:\n            return self.local_service.get_categories()\n        except Exception as e:\n            logger.error(f\"Error getting categories: {str(e)}\")\n            return []\n    \n    async def get_top_rated_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get top rated products\"\"\"\n        try:\n            return self.local_service.get_top_rated_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    async def get_best_selling_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get best selling products\"\"\"\n        try:\n            return self.local_service.get_best_selling_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products_by_category(self, category: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by category\"\"\"\n        try:\n            return self.local_service.get_products_by_category(category)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_all_products(self, limit: int = 20) -> List[Dict]:\n        \"\"\"Get all products\"\"\"\n        try:\n            return self.local_service.get_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting all products: {str(e)}\")\n            return []\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"Get product details by ID\"\"\"\n        try:\n            return self.local_service.get_product_details(product_id)\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"Get available brands\"\"\"\n        try:\n            return self.local_service.get_brands()\n        except Exception as e:\n            logger.error(f\"Error getting brands: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by brand\"\"\"\n        try:\n            return self.local_service.get_products_by_brand(brand)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    async def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: gunakan LocalProductService.smart_search_products secara async.\n        Return: (list produk, pesan)\n        \"\"\"\n        import asyncio\n        loop = asyncio.get_event_loop()\n        products, message = await loop.run_in_executor(\n            None, self.local_service.smart_search_products, keyword, category, max_price, limit\n        )\n        return products, message ",
      "existing_test": null
    },
    {
      "filepath": "app/utils/config.py",
      "coverage": 86.36,
      "content": "from pydantic_settings import BaseSettings\nfrom functools import lru_cache\nimport logging\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass Settings(BaseSettings):\n    # API Configuration\n    GOOGLE_API_KEY: str\n    API_HOST: str = \"localhost\"\n    API_PORT: int = 8000\n    FRONTEND_HOST: str = \"localhost\"\n    FRONTEND_PORT: int = 8501\n    DEBUG: bool = True\n\n    class Config:\n        env_file = \".env\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        if not self.GOOGLE_API_KEY or self.GOOGLE_API_KEY == \"your-google-api-key-here\":\n            logger.error(\"GOOGLE_API_KEY is not set or is using default value\")\n            raise ValueError(\"GOOGLE_API_KEY must be set in .env file\")\n\n@lru_cache()\ndef get_settings():\n    return Settings()\n\nsettings = get_settings() ",
      "existing_test": null
    }
  ]
}