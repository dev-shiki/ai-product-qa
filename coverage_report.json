{
  "timestamp": "/home/runner/work/ai-product-qa/ai-product-qa",
  "total_files": 17,
  "coverage_data": {
    ".": 0.0,
    "main.py": 0.0,
    "api": 0.0,
    "api/__init__.py": 100.0,
    "api/products.py": 0.0,
    "api/queries.py": 0.0,
    "models": 100.0,
    "models/__init__.py": 100.0,
    "models/product.py": 100.0,
    "services": 12.58,
    "services/__init__.py": 100.0,
    "services/ai_service.py": 4.839,
    "services/local_product_service.py": 11.540000000000001,
    "services/product_data_service.py": 20.73,
    "utils": 86.36,
    "utils/__init__.py": 100.0,
    "utils/config.py": 86.36
  },
  "lowest_coverage_files": [
    {
      "filepath": "app/services/ai_service.py",
      "coverage": 4.839,
      "content": "import logging\nfrom google import genai\nfrom app.utils.config import get_settings\nfrom app.services.product_data_service import ProductDataService\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass AIService:\n    def __init__(self):\n        \"\"\"Initialize AI service with Google AI API\"\"\"\n        try:\n            settings = get_settings()\n            # Use the new Google AI client\n            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)\n            self.product_service = ProductDataService()\n            logger.info(\"Successfully initialized AI service with Google AI client\")\n        except Exception as e:\n            logger.error(f\"Error initializing AI service: {str(e)}\")\n            raise\n\n    async def get_response(self, question: str) -> str:\n        \"\"\"Get AI response with product context and fallback message\"\"\"\n        try:\n            logger.info(f\"Getting AI response for question: {question}\")\n\n            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)\n            import re\n            category = None\n            max_price = None\n            \n            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)\n            question_lower = question.lower()\n            category_mapping = {\n                'laptop': ['laptop', 'notebook', 'komputer'],\n                'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],\n                'tablet': ['tablet', 'ipad'],\n                'headphone': ['headphone', 'earphone', 'headset', 'audio'],\n                'kamera': ['kamera', 'camera', 'fotografi'],\n                'audio': ['audio', 'speaker', 'sound'],\n                'tv': ['tv', 'televisi'],\n                'drone': ['drone', 'quadcopter'],\n                'jam': ['jam', 'watch', 'smartwatch']\n            }\n            \n            for cat, keywords in category_mapping.items():\n                if any(keyword in question_lower for keyword in keywords):\n                    category = cat\n                    break\n            \n            # Deteksi budget\n            price_match = re.search(r'(\\d+)\\s*juta', question_lower)\n            if price_match:\n                max_price = int(price_match.group(1)) * 1000000\n            elif 'budget' in question_lower or 'murah' in question_lower:\n                max_price = 5000000\n\n            # Gunakan smart_search_products\n            products, fallback_message = await self.product_service.smart_search_products(\n                keyword=question, category=category, max_price=max_price, limit=5\n            )\n\n            # Build context\n            context = f\"Question: {question}\\n\\n\"\n            context += f\"{fallback_message}\\n\\n\"\n            if products:\n                context += \"Relevant Products:\\n\"\n                for i, product in enumerate(products, 1):\n                    context += f\"{i}. {product.get('name', 'Unknown')}\\n\"\n                    context += f\"   Price: Rp {product.get('price', 0):,.0f}\\n\"\n                    context += f\"   Brand: {product.get('brand', 'Unknown')}\\n\"\n                    context += f\"   Category: {product.get('category', 'Unknown')}\\n\"\n                    context += f\"   Rating: {product.get('specifications', {}).get('rating', 0)}/5\\n\"\n                    context += f\"   Description: {product.get('description', 'No description')[:200]}...\\n\\n\"\n            else:\n                context += \"No specific products found, but I can provide general recommendations.\\n\\n\"\n\n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\\n\\n{context}\\n\\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision. Focus on being helpful and natural in your response.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.5-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n        \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            return \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n\n    def generate_response(self, context: str) -> str:\n        \"\"\"Generate response using Google AI (legacy method)\"\"\"\n        try:\n            logger.info(\"Generating AI response\")\n            \n            # Create prompt\n            prompt = f\"\"\"You are a helpful product assistant. Based on the following context, provide a helpful and informative response:\n\n{context}\n\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n\n            # Generate response using new API format\n            response = self.client.models.generate_content(\n                model=\"gemini-2.0-flash\",\n                contents=prompt\n            )\n            \n            logger.info(\"Successfully generated AI response\")\n            return response.text\n            \n        except Exception as e:\n            logger.error(f\"Error generating AI response: {str(e)}\")\n            raise ",
      "existing_test": "import pytest\nfrom unittest.mock import Mock, patch, AsyncMock\nimport logging\nimport sys\nimport os\n\n# Adjusting sys.path to allow imports from the 'app' directory\nsys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..')))\n\nfrom app.services.ai_service import AIService\nfrom app.utils.config import Settings # Assuming Settings class is defined in app.utils.config\n\n# --- Fixtures ---\n\n@pytest.fixture\ndef mock_settings():\n    \"\"\"Mocks the get_settings function to return a mock Settings object.\"\"\"\n    settings = Mock(spec=Settings)\n    settings.GOOGLE_API_KEY = \"test_api_key_123\"\n    return settings\n\n@pytest.fixture\ndef mock_genai_client():\n    \"\"\"\n    Mocks the google.genai.Client instance.\n    The `generate_content` method is an AsyncMock, and its return value is\n    configured to have a `.text` attribute, which is common for AI API responses.\n    This setup works for both awaited (in get_response) and non-awaited (in generate_response)\n    calls, assuming that for non-awaited calls, the mock object itself is returned\n    and then `.text` is accessed on it.\n    \"\"\"\n    mock_client = Mock()\n    mock_client.models = Mock() # Ensure models attribute exists\n    \n    # Configure the generate_content method to be an AsyncMock\n    # and its resolved return value (after await) or direct return value (if not awaited)\n    # to have a .text attribute.\n    mock_generate_content_result = Mock()\n    mock_generate_content_result.text = \"Mocked AI response text.\"\n    \n    # The AsyncMock itself will be returned if not awaited. We need to ensure that the\n    # AsyncMock instance (the coroutine object) also has a `.text` attribute for the\n    # `generate_response` method, which does not await.\n    mock_genai_method = AsyncMock(return_value=mock_generate_content_result)\n    mock_genai_method.text = \"Mocked AI response text for sync access\" # For the non-awaited call scenario\n\n    mock_client.models.generate_content = mock_genai_method\n    return mock_client\n\n@pytest.fixture\ndef mock_product_data_service():\n    \"\"\"Mocks the ProductDataService instance.\"\"\"\n    mock_service = Mock()\n    mock_service.smart_search_products = AsyncMock() # smart_search_products is an async method\n    # Default return for product search: no products\n    mock_service.smart_search_products.return_value = ([], \"No specific products found.\")\n    return mock_service\n\n@pytest.fixture\ndef ai_service_instance(mock_settings, mock_genai_client, mock_product_data_service):\n    \"\"\"\n    Provides an AIService instance with its dependencies (settings, genai client,\n    and product service) mocked.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', return_value=mock_genai_client), \\\n         patch('app.services.product_data_service.ProductDataService', return_value=mock_product_data_service):\n        service = AIService()\n        yield service # Use yield to allow for potential cleanup or specific patching in tests\n\n# --- Tests for AIService Initialization ---\n\ndef test_aiservice_init_success(ai_service_instance, mock_genai_client, mock_product_data_service, caplog):\n    \"\"\"\n    Tests successful initialization of AIService.\n    Verifies that client and product_service are set and a log message is emitted.\n    \"\"\"\n    with caplog.at_level(logging.INFO):\n        assert isinstance(ai_service_instance.client, Mock)\n        assert ai_service_instance.client == mock_genai_client\n        assert isinstance(ai_service_instance.product_service, Mock)\n        assert ai_service_instance.product_service == mock_product_data_service\n        assert \"Successfully initialized AI service with Google AI client\" in caplog.text\n    # Ensure client and product service are indeed the mocked objects\n    mock_genai_client.assert_called_once() # Client constructor should be called once\n    mock_product_data_service.assert_called_once() # ProductDataService constructor should be called once\n\n\ndef test_aiservice_init_get_settings_failure(caplog):\n    \"\"\"\n    Tests AIService initialization failure when get_settings raises an exception.\n    Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', side_effect=Exception(\"Config error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Config error\"):\n            AIService()\n        assert \"Error initializing AI service: Config error\" in caplog.text\n\ndef test_aiservice_init_genai_client_failure(mock_settings, caplog):\n    \"\"\"\n    Tests AIService initialization failure when google.genai.Client constructor\n    raises an exception. Ensures an exception is re-raised and an error log is created.\n    \"\"\"\n    with patch('app.utils.config.get_settings', return_value=mock_settings), \\\n         patch('google.genai.Client', side_effect=Exception(\"Client init error\")), \\\n         caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Client init error\"):\n            AIService()\n        assert \"Error initializing AI service: Client init error\" in caplog.text\n\n# --- Tests for get_response method ---\n\n@pytest.mark.asyncio\nasync def test_get_response_success_with_products(ai_service_instance, mock_product_data_service, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when product search returns relevant products.\n    Verifies correct context building and AI response.\n    \"\"\"\n    question = \"Cari laptop gaming di bawah 10 juta\"\n    mock_products = [\n        {\"name\": \"Awesome Laptop\", \"price\": 9500000, \"brand\": \"BrandX\", \"category\": \"laptop\", \"specifications\": {\"rating\": 4.5}, \"description\": \"High performance gaming laptop for pros.\"},\n        {\"name\": \"Budget Laptop\", \"price\": 7000000, \"brand\": \"BrandY\", \"category\": \"laptop\", \"specifications\": {\"rating\": 4.0}, \"description\": \"Affordable gaming laptop for casual gamers who want value.\"}\n    ]\n    mock_fallback_message = \"Found some great laptops for you!\"\n\n    mock_product_data_service.smart_search_products.return_value = (mock_products, mock_fallback_message)\n    mock_genai_client.models.generate_content.return_value.text = \"Based on your interest, Awesome Laptop and Budget Laptop are good options.\"\n\n    with caplog.at_level(logging.INFO):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Based on your interest, Awesome Laptop and Budget Laptop are good options.\"\n        mock_product_data_service.smart_search_products.assert_called_once_with(\n            keyword=question, category=\"laptop\", max_price=10000000, limit=5\n        )\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        prompt = call_args[0]['contents']\n\n        assert \"Question: Cari laptop gaming di bawah 10 juta\" in prompt\n        assert \"Found some great laptops for you!\" in prompt\n        assert \"Relevant Products:\" in prompt\n        assert \"1. Awesome Laptop\" in prompt\n        assert \"Price: Rp 9,500,000\" in prompt\n        assert \"Brand: BrandX\" in prompt\n        assert \"Category: laptop\" in prompt\n        assert \"Rating: 4.5/5\" in prompt\n        assert \"Description: High performance gaming laptop for pros...\" in prompt # Checks truncation\n        assert \"2. Budget Laptop\" in prompt\n        assert \"Successfully generated AI response\" in caplog.text\n        assert \"gemini-2.5-flash\" in call_args[0]['model']\n\n\n@pytest.mark.asyncio\nasync def test_get_response_success_no_products(ai_service_instance, mock_product_data_service, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when product search returns no relevant products.\n    Verifies correct context building (without products) and AI response.\n    \"\"\"\n    question = \"Can you recommend a very specific item I just made up?\"\n    mock_product_data_service.smart_search_products.return_value = ([], \"Could not find products matching your exact query.\")\n    mock_genai_client.models.generate_content.return_value.text = \"I'm sorry, I couldn't find specific products for that. Can I help with general info?\"\n\n    with caplog.at_level(logging.INFO):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"I'm sorry, I couldn't find specific products for that. Can I help with general info?\"\n        mock_product_data_service.smart_search_products.assert_called_once_with(\n            keyword=question, category=None, max_price=None, limit=5\n        )\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        prompt = call_args[0]['contents']\n\n        assert \"Question: Can you recommend a very specific item I just made up?\" in prompt\n        assert \"Could not find products matching your exact query.\" in prompt\n        assert \"No specific products found, but I can provide general recommendations.\" in prompt\n        assert \"Relevant Products:\" not in prompt # Ensure this is not present\n        assert \"Successfully generated AI response\" in caplog.text\n\n@pytest.mark.asyncio\nasync def test_get_response_ai_generation_failure(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests get_response when the AI client fails to generate a response.\n    Verifies that a friendly fallback message is returned and an error is logged.\n    \"\"\"\n    question = \"Tell me something.\"\n    mock_genai_client.models.generate_content.side_effect = Exception(\"AI API error\")\n\n    with caplog.at_level(logging.ERROR):\n        response = await ai_service_instance.get_response(question)\n\n        assert response == \"Maaf, saya sedang mengalami kesulitan untuk memberikan rekomendasi. Silakan coba lagi nanti.\"\n        mock_genai_client.models.generate_content.assert_called_once()\n        assert \"Error generating AI response: AI API error\" in caplog.text\n\n@pytest.mark.asyncio\n@pytest.mark.parametrize(\n    \"question, expected_category, expected_max_price\",\n    [\n        (\"Cari laptop gaming 10 juta\", \"laptop\", 10_000_000),\n        (\"Smartphone murah\", \"smartphone\", 5_000_000), # Detects 'smartphone' and 'murah' for price\n        (\"Tablet di bawah 5 juta\", \"tablet\", 5_000_000), # Detects 'tablet' and '5 juta' for price\n        (\"earphone bluetooth\", \"headphone\", None),\n        (\"Kamera DSLR bagus\", \"kamera\", None),\n        (\"TV Samsung 20 juta\", \"tv\", 20_000_000),\n        (\"Jam tangan pintar\", \"jam\", None),\n        (\"Ponsel dengan budget 7 juta\", \"smartphone\", 7_000_000),\n        (\"Headset gaming\", \"headphone\", None),\n        (\"Cari produk audio\", \"audio\", None),\n        (\"Apa rekomendasi terbaik?\", None, None), # No category, no price\n        (\"Saya mau beli HP dengan 3 juta\", \"smartphone\", 3_000_000),\n        (\"drone budget 10 juta\", \"drone\", 10_000_000),\n        (\"notebook 8 juta\", \"laptop\", 8_000_000),\n        (\"ipad pro\", \"tablet\", None),\n        (\"handphone 2 juta\", \"smartphone\", 2_000_000),\n        (\"TV yang murah\", \"tv\", 5_000_000), # Test 'murah' with category\n        (\"budget murah untuk audio\", \"audio\", 5_000_000), # Test 'budget' with category\n        (\"telepon seluler\", \"smartphone\", None), # Test synonym\n        (\"komputer baru\", \"laptop\", None), # Test synonym\n        (\"fotografi gear\", \"kamera\", None), # Test synonym\n        (\"speaker bluetooth\", \"audio\", None), # Test synonym\n        (\"ponsel android 4 juta\", \"smartphone\", 4_000_000), # Combined\n        (\"smartwatch 1 juta\", \"jam\", 1_000_000), # Combined\n    ]\n)\nasync def test_get_response_category_and_price_detection(\n    ai_service_instance, mock_product_data_service, mock_genai_client,\n    question, expected_category, expected_max_price\n):\n    \"\"\"\n    Tests that get_response correctly extracts category and max_price from various questions.\n    \"\"\"\n    await ai_service_instance.get_response(question)\n\n    mock_product_data_service.smart_search_products.assert_called_once()\n    call_args, _ = mock_product_data_service.smart_search_products.call_args\n\n    assert call_args[1]['category'] == expected_category\n    assert call_args[1]['max_price'] == expected_max_price\n    assert call_args[1]['keyword'] == question # Ensure keyword is always passed\n\n\n@pytest.mark.asyncio\nasync def test_get_response_empty_question(ai_service_instance, mock_product_data_service, mock_genai_client):\n    \"\"\"\n    Tests get_response with an empty question string.\n    Ensures smart_search_products is called with keyword=\"\", category=None, max_price=None.\n    \"\"\"\n    question = \"\"\n    await ai_service_instance.get_response(question)\n\n    mock_product_data_service.smart_search_products.assert_called_once_with(\n        keyword=\"\", category=None, max_price=None, limit=5\n    )\n    mock_genai_client.models.generate_content.assert_called_once()\n    call_args, _ = mock_genai_client.models.generate_content.call_args\n    prompt = call_args[0]['contents']\n    assert \"Question: \\n\\nNo specific products found, but I can provide general recommendations.\" in prompt\n    assert \"gemini-2.5-flash\" in call_args[0]['model']\n\n\n# --- Tests for generate_response method (legacy) ---\n\ndef test_generate_response_success(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests successful execution of the legacy generate_response method.\n    Verifies the correct AI model and content are used.\n    Note: This method does not 'await' the genai client call. The test accounts for this\n    by ensuring the mock returns an object with a '.text' attribute directly.\n    \"\"\"\n    context = \"This is a test context for legacy generation.\"\n    expected_response_text = \"Legacy AI response.\"\n\n    # Configure the mock_genai_client fixture's generate_content method for this specific test\n    # to return the expected text directly, as it's not awaited in generate_response.\n    # The fixture already sets `mock_genai_method.text = \"...\"` on the AwaitableMock.\n    mock_genai_client.models.generate_content.text = expected_response_text\n    \n    with caplog.at_level(logging.INFO):\n        response = ai_service_instance.generate_response(context)\n\n        assert response == expected_response_text\n        mock_genai_client.models.generate_content.assert_called_once()\n        call_args, _ = mock_genai_client.models.generate_content.call_args\n        assert call_args[0]['model'] == \"gemini-2.0-flash\"\n        expected_prompt_part = f\"\"\"You are a helpful product assistant. Based on the following context:\\n\\n{context}\\n\\nPlease provide a clear and concise answer that helps the user understand the products and make an informed decision.\"\"\"\n        assert expected_prompt_part in call_args[0]['contents']\n        assert \"Successfully generated AI response\" in caplog.text\n\ndef test_generate_response_ai_generation_failure(ai_service_instance, mock_genai_client, caplog):\n    \"\"\"\n    Tests generate_response when the AI client fails to generate a response.\n    Ensures an exception is re-raised and an error is logged.\n    \"\"\"\n    context = \"Failing context.\"\n    \n    # Configure the mock_genai_client fixture's generate_content method to raise an exception\n    # directly when called (as it's not awaited here).\n    mock_genai_client.models.generate_content.side_effect = Exception(\"Legacy AI API error\")\n\n    with caplog.at_level(logging.ERROR):\n        with pytest.raises(Exception, match=\"Legacy AI API error\"):\n            ai_service_instance.generate_response(context)\n        mock_genai_client.models.generate_content.assert_called_once()\n        assert \"Error generating AI response: Legacy AI API error\" in caplog.text"
    },
    {
      "filepath": "app/services/local_product_service.py",
      "coverage": 11.540000000000001,
      "content": "import logging\nimport json\nimport random\nfrom typing import List, Dict, Optional\nfrom pathlib import Path\n\nlogger = logging.getLogger(__name__)\n\nclass LocalProductService:\n    \"\"\"\n    Service untuk data produk lokal yang reliable dan tidak bergantung pada API eksternal\n    \"\"\"\n    \n    def __init__(self):\n        self.products = self._load_local_products()\n        logger.info(f\"Loaded {len(self.products)} local products from JSON file\")\n    \n    def _load_local_products(self) -> List[Dict]:\n        \"\"\"Load produk dari file JSON lokal\"\"\"\n        try:\n            # Get the path to the data/products.json file\n            current_dir = Path(__file__).parent.parent.parent\n            json_file_path = current_dir / \"data\" / \"products.json\"\n            \n            if not json_file_path.exists():\n                logger.error(f\"Products JSON file not found at: {json_file_path}\")\n                return self._get_fallback_products()\n            \n            # Try different encodings\n            encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n            \n            for encoding in encodings:\n                try:\n                    with open(json_file_path, 'r', encoding=encoding) as file:\n                        content = file.read()\n                        # Remove BOM if present\n                        if content.startswith('\\ufeff'):\n                            content = content[1:]\n                        \n                        data = json.loads(content)\n                        products = data.get('products', [])\n                        \n                        # Transform products to match expected format\n                        transformed_products = []\n                        for product in products:\n                            transformed_product = {\n                                \"id\": product.get('id', ''),\n                                \"name\": product.get('name', ''),\n                                \"category\": product.get('category', ''),\n                                \"brand\": product.get('brand', ''),\n                                \"price\": product.get('price', 0),\n                                \"currency\": product.get('currency', 'IDR'),\n                                \"description\": product.get('description', ''),\n                                \"specifications\": {\n                                    \"rating\": product.get('rating', 0),\n                                    \"sold\": random.randint(100, 2000),  # Add random sold count\n                                    \"stock\": product.get('stock_count', 0),\n                                    \"condition\": \"Baru\",\n                                    \"shop_location\": \"Indonesia\",\n                                    \"shop_name\": f\"{product.get('brand', 'Unknown')} Store\",\n                                    **product.get('specifications', {})\n                                },\n                                \"availability\": product.get('availability', 'in_stock'),\n                                \"reviews_count\": product.get('reviews_count', 0),\n                                \"images\": [f\"https://example.com/{product.get('id', 'product')}.jpg\"],\n                                \"url\": f\"https://shopee.co.id/{product.get('id', 'product')}\"\n                            }\n                            transformed_products.append(transformed_product)\n                        \n                        logger.info(f\"Successfully loaded {len(transformed_products)} products from JSON file using {encoding} encoding\")\n                        return transformed_products\n                        \n                except (UnicodeDecodeError, json.JSONDecodeError) as e:\n                    logger.warning(f\"Failed to load with {encoding} encoding: {str(e)}\")\n                    continue\n            \n            # If all encodings fail, use fallback\n            logger.error(\"All encoding attempts failed, using fallback products\")\n            return self._get_fallback_products()\n                \n        except Exception as e:\n            logger.error(f\"Error loading products from JSON file: {str(e)}\")\n            return self._get_fallback_products()\n    \n    def _get_fallback_products(self) -> List[Dict]:\n        \"\"\"Fallback products if JSON file cannot be loaded\"\"\"\n        logger.warning(\"Using fallback products due to JSON file loading error\")\n        return [\n            {\n                \"id\": \"1\",\n                \"name\": \"iPhone 15 Pro Max\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Apple\",\n                \"price\": 25000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPhone 15 Pro Max dengan chip A17 Pro, kamera 48MP, dan layar 6.7 inch Super Retina XDR. Dilengkapi dengan titanium design dan performa gaming yang luar biasa.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 1250,\n                    \"stock\": 50,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Titanium Natural\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"A17 Pro\",\n                    \"camera\": \"48MP Main + 12MP Ultra Wide + 12MP Telephoto\",\n                    \"display\": \"6.7 inch Super Retina XDR\"\n                },\n                \"images\": [\"https://example.com/iphone15.jpg\"],\n                \"url\": \"https://shopee.co.id/iphone-15-pro-max\"\n            },\n            {\n                \"id\": \"2\", \n                \"name\": \"Samsung Galaxy S24 Ultra\",\n                \"category\": \"Smartphone\",\n                \"brand\": \"Samsung\",\n                \"price\": 22000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy S24 Ultra dengan S Pen, kamera 200MP, dan AI features canggih. Dilengkapi dengan Snapdragon 8 Gen 3 dan layar AMOLED 6.8 inch.\",\n                \"specifications\": {\n                    \"rating\": 4.7,\n                    \"sold\": 980,\n                    \"stock\": 35,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"512GB\",\n                    \"color\": \"Titanium Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 3\",\n                    \"camera\": \"200MP Main + 12MP Ultra Wide + 50MP Telephoto + 10MP Telephoto\",\n                    \"display\": \"6.8 inch Dynamic AMOLED 2X\"\n                },\n                \"images\": [\"https://example.com/s24-ultra.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-s24-ultra\"\n            },\n            {\n                \"id\": \"3\",\n                \"name\": \"MacBook Pro 14 inch M3\",\n                \"category\": \"Laptop\",\n                \"brand\": \"Apple\",\n                \"price\": 35000000,\n                \"currency\": \"IDR\",\n                \"description\": \"MacBook Pro dengan chip M3, layar 14 inch Liquid Retina XDR, dan performa tinggi untuk profesional. Cocok untuk video editing, programming, dan gaming.\",\n                \"specifications\": {\n                    \"rating\": 4.9,\n                    \"sold\": 450,\n                    \"stock\": 25,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"1TB\",\n                    \"color\": \"Space Gray\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M3\",\n                    \"ram\": \"16GB Unified Memory\",\n                    \"display\": \"14 inch Liquid Retina XDR\"\n                },\n                \"images\": [\"https://example.com/macbook-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/macbook-pro-m3\"\n            },\n            {\n                \"id\": \"4\",\n                \"name\": \"AirPods Pro 2nd Gen\",\n                \"category\": \"Audio\",\n                \"brand\": \"Apple\",\n                \"price\": 4500000,\n                \"currency\": \"IDR\",\n                \"description\": \"AirPods Pro dengan Active Noise Cancellation dan Spatial Audio. Dilengkapi dengan chip H2 untuk performa audio yang lebih baik dan fitur Find My.\",\n                \"specifications\": {\n                    \"rating\": 4.6,\n                    \"sold\": 2100,\n                    \"stock\": 100,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"color\": \"White\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"6 jam dengan ANC, 30 jam dengan case\",\n                    \"features\": \"Active Noise Cancellation, Spatial Audio, Find My\"\n                },\n                \"images\": [\"https://example.com/airpods-pro.jpg\"],\n                \"url\": \"https://shopee.co.id/airpods-pro-2\"\n            },\n            {\n                \"id\": \"5\",\n                \"name\": \"iPad Air 5th Gen\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Apple\",\n                \"price\": 12000000,\n                \"currency\": \"IDR\",\n                \"description\": \"iPad Air dengan chip M1, layar 10.9 inch Liquid Retina, dan Apple Pencil support. Cocok untuk kreativitas, note-taking, dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.5,\n                    \"sold\": 750,\n                    \"stock\": 40,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Medan\",\n                    \"shop_name\": \"Apple Store Indonesia\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Blue\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Apple M1\",\n                    \"display\": \"10.9 inch Liquid Retina\",\n                    \"features\": \"Apple Pencil support, Magic Keyboard support\"\n                },\n                \"images\": [\"https://example.com/ipad-air.jpg\"],\n                \"url\": \"https://shopee.co.id/ipad-air-5\"\n            },\n            {\n                \"id\": \"6\",\n                \"name\": \"ASUS ROG Strix G15\",\n                \"category\": \"Laptop\",\n                \"brand\": \"ASUS\",\n                \"price\": 18000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Laptop gaming ASUS ROG Strix G15 dengan RTX 4060, AMD Ryzen 7, dan layar 15.6 inch 144Hz. Dilengkapi dengan RGB keyboard dan cooling system yang powerful.\",\n                \"specifications\": {\n                    \"rating\": 4.4,\n                    \"sold\": 320,\n                    \"stock\": 15,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Jakarta\",\n                    \"shop_name\": \"ASUS Store\",\n                    \"storage\": \"512GB SSD\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"2 Tahun\",\n                    \"processor\": \"AMD Ryzen 7 7735HS\",\n                    \"gpu\": \"NVIDIA RTX 4060 8GB\",\n                    \"ram\": \"16GB DDR5\",\n                    \"display\": \"15.6 inch FHD 144Hz\"\n                },\n                \"images\": [\"https://example.com/rog-strix.jpg\"],\n                \"url\": \"https://shopee.co.id/asus-rog-strix-g15\"\n            },\n            {\n                \"id\": \"7\",\n                \"name\": \"Sony WH-1000XM5\",\n                \"category\": \"Audio\",\n                \"brand\": \"Sony\",\n                \"price\": 5500000,\n                \"currency\": \"IDR\",\n                \"description\": \"Headphone wireless Sony WH-1000XM5 dengan noise cancellation terbaik di kelasnya. Dilengkapi dengan 30 jam battery life dan quick charge.\",\n                \"specifications\": {\n                    \"rating\": 4.8,\n                    \"sold\": 890,\n                    \"stock\": 30,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Surabaya\",\n                    \"shop_name\": \"Sony Store\",\n                    \"color\": \"Black\",\n                    \"warranty\": \"1 Tahun\",\n                    \"battery\": \"30 jam dengan ANC\",\n                    \"features\": \"Industry-leading noise cancellation, Quick Charge, Multipoint connection\"\n                },\n                \"images\": [\"https://example.com/sony-wh1000xm5.jpg\"],\n                \"url\": \"https://shopee.co.id/sony-wh1000xm5\"\n            },\n            {\n                \"id\": \"8\",\n                \"name\": \"Samsung Galaxy Tab S9\",\n                \"category\": \"Tablet\",\n                \"brand\": \"Samsung\",\n                \"price\": 15000000,\n                \"currency\": \"IDR\",\n                \"description\": \"Samsung Galaxy Tab S9 dengan S Pen, layar AMOLED 11 inch, dan Snapdragon 8 Gen 2. Cocok untuk productivity dan entertainment.\",\n                \"specifications\": {\n                    \"rating\": 4.3,\n                    \"sold\": 280,\n                    \"stock\": 20,\n                    \"condition\": \"Baru\",\n                    \"shop_location\": \"Bandung\",\n                    \"shop_name\": \"Samsung Store\",\n                    \"storage\": \"256GB\",\n                    \"color\": \"Graphite\",\n                    \"warranty\": \"1 Tahun\",\n                    \"processor\": \"Snapdragon 8 Gen 2\",\n                    \"display\": \"11 inch Dynamic AMOLED 2X\",\n                    \"features\": \"S Pen included, DeX mode, Multi-window\"\n                },\n                \"images\": [\"https://example.com/galaxy-tab-s9.jpg\"],\n                \"url\": \"https://shopee.co.id/samsung-galaxy-tab-s9\"\n            }\n        ]\n    \n    def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"\n        Search products berdasarkan keyword\n        \"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            \n            keyword_lower = keyword.lower()\n            filtered_products = []\n            \n            # Extract price range from keyword\n            max_price = self._extract_price_from_keyword(keyword)\n            \n            for product in self.products:\n                product_price = product.get('price', 0)\n                \n                # Check if product matches price range\n                if max_price and product_price <= max_price:\n                    filtered_products.append(product)\n                    continue\n                \n                # Search in name, description, category, brand, and specifications\n                searchable_text = (\n                    product.get('name', '') + ' ' +\n                    product.get('description', '') + ' ' +\n                    product.get('category', '') + ' ' +\n                    product.get('brand', '') + ' ' +\n                    str(product.get('specifications', {}))\n                ).lower()\n                \n                if keyword_lower in searchable_text:\n                    filtered_products.append(product)\n            \n            # Sort by relevance (exact matches first, then by price if budget search)\n            def relevance_score(product):\n                score = 0\n                if keyword_lower in product.get('name', '').lower():\n                    score += 10\n                if keyword_lower in product.get('brand', '').lower():\n                    score += 5\n                if keyword_lower in product.get('category', '').lower():\n                    score += 3\n                \n                # For budget searches, prefer lower prices\n                if max_price or any(word in keyword_lower for word in ['murah', 'budget', 'hemat', 'terjangkau']):\n                    score += (10000000 - product.get('price', 0)) / 1000000  # Higher score for lower prices\n                \n                return score\n            \n            filtered_products.sort(key=relevance_score, reverse=True)\n            \n            logger.info(f\"Found {len(filtered_products)} products\")\n            return filtered_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    def _extract_price_from_keyword(self, keyword: str) -> Optional[int]:\n        \"\"\"\n        Extract maximum price from keyword\n        \"\"\"\n        try:\n            keyword_lower = keyword.lower()\n            \n            # Common price patterns\n            price_patterns = [\n                (r'(\\d+)\\s*juta', lambda x: int(x) * 1000000),\n                (r'(\\d+)\\s*ribu', lambda x: int(x) * 1000),\n                (r'rp\\s*(\\d+)', lambda x: int(x)),\n                (r'(\\d+)\\s*rp', lambda x: int(x)),\n                (r'(\\d+)\\s*k', lambda x: int(x) * 1000),\n                (r'(\\d+)\\s*m', lambda x: int(x) * 1000000),\n            ]\n            \n            import re\n            for pattern, converter in price_patterns:\n                match = re.search(pattern, keyword_lower)\n                if match:\n                    return converter(match.group(1))\n            \n            # Budget keywords\n            budget_keywords = {\n                'murah': 5000000,  # 5 juta\n                'budget': 5000000,\n                'hemat': 3000000,  # 3 juta\n                'terjangkau': 4000000,  # 4 juta\n                'ekonomis': 2000000,  # 2 juta\n            }\n            \n            for word, max_price in budget_keywords.items():\n                if word in keyword_lower:\n                    return max_price\n            \n            return None\n            \n        except Exception as e:\n            logger.error(f\"Error extracting price from keyword: {str(e)}\")\n            return None\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"\n        Get detail produk berdasarkan ID\n        \"\"\"\n        try:\n            for product in self.products:\n                if product.get('id') == product_id:\n                    return product\n            return None\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_categories(self) -> List[str]:\n        \"\"\"\n        Get daftar kategori produk\n        \"\"\"\n        categories = set()\n        for product in self.products:\n            categories.add(product.get('category', ''))\n        return sorted(list(categories))\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"\n        Get daftar brand produk\n        \"\"\"\n        brands = set()\n        for product in self.products:\n            brands.add(product.get('brand', ''))\n        return sorted(list(brands))\n    \n    def get_products_by_category(self, category: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan kategori\n        \"\"\"\n        try:\n            category_lower = category.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if category_lower in product.get('category', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str) -> List[Dict]:\n        \"\"\"\n        Get produk berdasarkan brand\n        \"\"\"\n        try:\n            brand_lower = brand.lower()\n            filtered_products = []\n            \n            for product in self.products:\n                if brand_lower in product.get('brand', '').lower():\n                    filtered_products.append(product)\n            \n            return filtered_products\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    def get_top_rated_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"\n        Get produk dengan rating tertinggi\n        \"\"\"\n        try:\n            sorted_products = sorted(\n                self.products, \n                key=lambda x: x.get('specifications', {}).get('rating', 0), \n                reverse=True\n            )\n            return sorted_products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    def get_best_selling_products(self, limit: int = 5) -> List[Dict]:\n        \"\"\"Get produk dengan penjualan tertinggi\"\"\"\n        try:\n            logger.info(f\"Getting best selling products, limit: {limit}\")\n            \n            # Sort berdasarkan sold count\n            sorted_products = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n            \n            logger.info(f\"Returning {min(limit, len(sorted_products))} best selling products\")\n            return sorted_products[:limit]\n            \n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get semua produk\"\"\"\n        try:\n            logger.info(f\"Getting all products, limit: {limit}\")\n            return self.products[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return []\n    \n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: cari produk sesuai kriteria, lalu fallback bertingkat dengan notifikasi.\n        Return: (list produk, pesan)\n        \"\"\"\n        keyword_lower = (keyword or '').lower()\n        \n        # Deteksi permintaan \"terbaik\"\n        is_best_request = 'terbaik' in keyword_lower or 'best' in keyword_lower\n        \n        # 1. Jika user minta \"terbaik\" tanpa kategori spesifik\n        if is_best_request and not category:\n            # Tampilkan produk terbaik secara umum (top 5 berdasarkan rating)\n            best_products = sorted(self.products, \n                                 key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                 reverse=True)\n            return best_products[:limit], \"Berikut produk terbaik berdasarkan rating:\"\n        \n        # 2. Jika user minta \"terbaik\" dengan kategori spesifik\n        if is_best_request and category:\n            category_products = [p for p in self.products \n                               if category.lower() in p.get('category', '').lower()]\n            if category_products:\n                category_products.sort(key=lambda x: x.get('specifications', {}).get('rating', 0), reverse=True)\n                return category_products[:limit], f\"Berikut {category} terbaik berdasarkan rating:\"\n            else:\n                # Fallback ke produk terbaik secara umum jika kategori tidak ditemukan\n                best_products = sorted(self.products, \n                                     key=lambda x: x.get('specifications', {}).get('rating', 0), \n                                     reverse=True)\n                return best_products[:limit], f\"Tidak ada produk kategori {category}, berikut produk terbaik secara umum:\"\n        \n        # 3. Cari produk yang memenuhi semua kriteria (non-terbaik)\n        results = [\n            p for p in self.products\n            if (not category or category.lower() in p.get('category', '').lower())\n            and (not max_price or p.get('price', 0) <= max_price)\n            and (not keyword or keyword_lower in (p.get('name', '') + ' ' + p.get('description', '') + ' ' + p.get('category', '') + ' ' + p.get('brand', '') + str(p.get('specifications', {}))).lower())\n        ]\n        if results:\n            return results[:limit], \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\n        # 4. Jika tidak ada, cari produk di kategori yang sama (tanpa filter harga)\n        if category:\n            category_results = [\n                p for p in self.products\n                if category.lower() in p.get('category', '').lower()\n            ]\n            if category_results:\n                category_results.sort(key=lambda x: x.get('price', 0))\n                return category_results[:limit], \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\n        # 5. Jika tetap tidak ada, tampilkan produk lain yang sesuai budget\n        if max_price:\n            budget_results = [\n                p for p in self.products\n                if p.get('price', 0) <= max_price\n            ]\n            if budget_results:\n                return budget_results[:limit], \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\n        # 6. Jika tetap tidak ada, tampilkan produk terpopuler/terlaris\n        popular_results = sorted(self.products, key=lambda x: x.get('specifications', {}).get('sold', 0), reverse=True)\n        return popular_results[:limit], \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\" ",
      "existing_test": "import pytest\nfrom unittest.mock import patch, mock_open, MagicMock\nimport logging\nimport json\nfrom pathlib import Path\nimport sys\nimport builtins # Added for patching open\n\n# Add the parent directory of 'app' to the sys.path\n# This allows imports like 'from app.services.local_product_service import LocalProductService'\n# to work correctly when tests are run from a different root.\nsys.path.insert(0, str(Path(__file__).parent.parent.parent))\n\nfrom app.services.local_product_service import LocalProductService\n\n# Mock data for testing\nMOCK_PRODUCTS_DATA = [\n    {\n        \"id\": \"prod1\",\n        \"name\": \"Product A\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 100000,\n        \"currency\": \"IDR\",\n        \"description\": \"Description A\",\n        \"specifications\": {\"rating\": 4.5, \"sold\": 500, \"stock_count\": 100},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 10,\n        \"images\": [\"url_a.jpg\"],\n        \"url\": \"url_a\"\n    },\n    {\n        \"id\": \"prod2\",\n        \"name\": \"Product B\",\n        \"category\": \"Category2\",\n        \"brand\": \"BrandY\",\n        \"price\": 200000,\n        \"currency\": \"IDR\",\n        \"description\": \"Description B, also Product A related.\",\n        \"specifications\": {\"rating\": 3.8, \"sold\": 300, \"stock_count\": 50},\n        \"availability\": \"out_of_stock\",\n        \"reviews_count\": 5,\n        \"images\": [\"url_b.jpg\"],\n        \"url\": \"url_b\"\n    },\n    {\n        \"id\": \"prod3\",\n        \"name\": \"Product C\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 50000,\n        \"currency\": \"IDR\",\n        \"description\": \"Cheapest product.\",\n        \"specifications\": {\"rating\": 4.9, \"sold\": 1200, \"stock_count\": 200},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 20,\n        \"images\": [\"url_c.jpg\"],\n        \"url\": \"url_c\"\n    },\n    {\n        \"id\": \"prod4\",\n        \"name\": \"Product D\",\n        \"category\": \"Category3\",\n        \"brand\": \"BrandZ\",\n        \"price\": 5000000, # 5 juta\n        \"currency\": \"IDR\",\n        \"description\": \"Expensive gadget.\",\n        \"specifications\": {\"rating\": 4.0, \"sold\": 100, \"stock_count\": 10},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 2,\n        \"images\": [\"url_d.jpg\"],\n        \"url\": \"url_d\"\n    },\n    {\n        \"id\": \"prod5\",\n        \"name\": \"Product E (Best Seller)\",\n        \"category\": \"Category1\",\n        \"brand\": \"BrandX\",\n        \"price\": 150000,\n        \"currency\": \"IDR\",\n        \"description\": \"Best seller in Category1.\",\n        \"specifications\": {\"rating\": 4.6, \"sold\": 15000, \"stock_count\": 1000},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 150,\n        \"images\": [\"url_e.jpg\"],\n        \"url\": \"url_e\"\n    },\n    {\n        \"id\": \"prod6\",\n        \"name\": \"Product F (Budget)\",\n        \"category\": \"Category2\",\n        \"brand\": \"BrandY\",\n        \"price\": 4000000, # 4 juta\n        \"currency\": \"IDR\",\n        \"description\": \"A budget friendly product.\",\n        \"specifications\": {\"rating\": 3.0, \"sold\": 50, \"stock_count\": 20},\n        \"availability\": \"in_stock\",\n        \"reviews_count\": 1,\n        \"images\": [\"url_f.jpg\"],\n        \"url\": \"url_f\"\n    },\n]\n\n# Transformed version of MOCK_PRODUCTS_DATA for comparison with _load_local_products output\n# The 'sold' count will be mocked to 1000 for deterministic tests\nTRANSFORMED_MOCK_PRODUCTS_DATA = [\n    {\n        \"id\": \"prod1\", \"name\": \"Product A\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 100000, \"currency\": \"IDR\", \"description\": \"Description A\",\n        \"specifications\": {\"rating\": 4.5, \"sold\": 1000, \"stock\": 100, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 10, \"images\": [\"https://example.com/prod1.jpg\"], \"url\": \"https://shopee.co.id/prod1\"\n    },\n    {\n        \"id\": \"prod2\", \"name\": \"Product B\", \"category\": \"Category2\", \"brand\": \"BrandY\", \"price\": 200000, \"currency\": \"IDR\", \"description\": \"Description B, also Product A related.\",\n        \"specifications\": {\"rating\": 3.8, \"sold\": 1000, \"stock\": 50, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandY Store\"},\n        \"availability\": \"out_of_stock\", \"reviews_count\": 5, \"images\": [\"https://example.com/prod2.jpg\"], \"url\": \"https://shopee.co.id/prod2\"\n    },\n    {\n        \"id\": \"prod3\", \"name\": \"Product C\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 50000, \"currency\": \"IDR\", \"description\": \"Cheapest product.\",\n        \"specifications\": {\"rating\": 4.9, \"sold\": 1000, \"stock\": 200, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 20, \"images\": [\"https://example.com/prod3.jpg\"], \"url\": \"https://shopee.co.id/prod3\"\n    },\n    {\n        \"id\": \"prod4\", \"name\": \"Product D\", \"category\": \"Category3\", \"brand\": \"BrandZ\", \"price\": 5000000, \"currency\": \"IDR\", \"description\": \"Expensive gadget.\",\n        \"specifications\": {\"rating\": 4.0, \"sold\": 1000, \"stock\": 10, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandZ Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 2, \"images\": [\"https://example.com/prod4.jpg\"], \"url\": \"https://shopee.co.id/prod4\"\n    },\n    {\n        \"id\": \"prod5\", \"name\": \"Product E (Best Seller)\", \"category\": \"Category1\", \"brand\": \"BrandX\", \"price\": 150000, \"currency\": \"IDR\", \"description\": \"Best seller in Category1.\",\n        \"specifications\": {\"rating\": 4.6, \"sold\": 1000, \"stock\": 1000, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandX Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 150, \"images\": [\"https://example.com/prod5.jpg\"], \"url\": \"https://shopee.co.id/prod5\"\n    },\n    {\n        \"id\": \"prod6\", \"name\": \"Product F (Budget)\", \"category\": \"Category2\", \"brand\": \"BrandY\", \"price\": 4000000, \"currency\": \"IDR\", \"description\": \"A budget friendly product.\",\n        \"specifications\": {\"rating\": 3.0, \"sold\": 1000, \"stock\": 20, \"condition\": \"Baru\", \"shop_location\": \"Indonesia\", \"shop_name\": \"BrandY Store\"},\n        \"availability\": \"in_stock\", \"reviews_count\": 1, \"images\": [\"https://example.com/prod6.jpg\"], \"url\": \"https://shopee.co.id/prod6\"\n    },\n]\n\n\n@pytest.fixture\ndef mock_local_product_service_instance():\n    \"\"\"\n    Fixture to provide a LocalProductService instance with pre-defined mock products,\n    bypassing the file loading mechanism for most tests.\n    \"\"\"\n    # Patch _load_local_products to return deterministic, transformed mock data\n    with patch('app.services.local_product_service.LocalProductService._load_local_products',\n               return_value=TRANSFORMED_MOCK_PRODUCTS_DATA) as mock_load:\n        service = LocalProductService()\n        mock_load.assert_called_once() # Ensure init calls _load_local_products\n        yield service\n\n@pytest.fixture\ndef mock_logger():\n    \"\"\"Fixture to mock the logger to capture log messages.\"\"\"\n    with patch('app.services.local_product_service.logger') as mock_log:\n        yield mock_log\n\n# --- Tests for __init__ and _load_local_products ---\n\ndef test_init_success(mock_logger):\n    \"\"\"\n    Test that LocalProductService initializes successfully by loading products.\n    \"\"\"\n    # Mock _load_local_products to return a specific list\n    with patch('app.services.local_product_service.LocalProductService._load_local_products',\n               return_value=TRANSFORMED_MOCK_PRODUCTS_DATA) as mock_load:\n        service = LocalProductService()\n        mock_load.assert_called_once()\n        assert service.products == TRANSFORMED_MOCK_PRODUCTS_DATA\n        mock_logger.info.assert_called_with(f\"Loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} local products from JSON file\")\n\ndef test_load_local_products_file_not_found(mock_logger):\n    \"\"\"\n    Test _load_local_products when the JSON file does not exist.\n    It should log an error and return fallback products.\n    \"\"\"\n    # Mock Path.exists to return False, and mock Path constructor to return a mock object\n    with patch('app.services.local_product_service.Path.exists', return_value=False), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback, \\\n         patch('app.services.local_product_service.Path') as MockPath:\n        \n        # Configure MockPath to simulate the file path construction\n        mock_file_path = MagicMock(spec=Path) # Use spec=Path to ensure Path methods exist\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n        \n        service = LocalProductService() # Initialize to access the method\n        result = service._load_local_products()\n        \n        mock_logger.error.assert_called_once()\n        assert \"Products JSON file not found at:\" in mock_logger.error.call_args[0][0]\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value # Ensure fallback products are returned\n\ndef test_load_local_products_valid_json_utf8(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid UTF-8 JSON file.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": MOCK_PRODUCTS_DATA})\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000): # Mock random.randint for predictable sold count\n        \n        # Simulate the Path resolution\n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService() # Initialize to access the method\n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        # Compare a few key attributes to ensure transformation happened correctly\n        assert products[0]['id'] == TRANSFORMED_MOCK_PRODUCTS_DATA[0]['id']\n        assert products[0]['price'] == TRANSFORMED_MOCK_PRODUCTS_DATA[0]['price']\n        assert products[0]['specifications']['sold'] == 1000 # Verify mocked random.randint\n        assert products[0]['images'][0] == f\"https://example.com/{TRANSFORMED_MOCK_PRODUCTS_DATA[0]['id']}.jpg\"\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-8 encoding\")\n        # Ensure open was called with various encodings before finding success with utf-8\n        # The first call might be utf-16-le which might fail or succeed depending on mock_open's internal behavior.\n        # But utf-8 should be the one leading to the info log.\n        assert any(call.kwargs['encoding'] == 'utf-8' for call in builtins.open.call_args_list)\n\ndef test_load_local_products_valid_json_utf16le_with_bom(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid UTF-16-LE JSON file containing a BOM.\n    \"\"\"\n    mock_json_content_str = json.dumps({\"products\": MOCK_PRODUCTS_DATA})\n    \n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n    \n    def open_side_effect(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        if encoding == 'utf-16-le':\n            # This simulates reading a file that *was* UTF-16-LE with BOM,\n            # and `file.read()` returns the decoded string (which still has the BOM char at start).\n            m_file.read.return_value = '\\ufeff' + mock_json_content_str\n        else:\n            # Simulate failure for other encodings to ensure utf-16-le is picked\n            raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason\") # This will make other encodings fail\n        return m_file\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect), \\\n         patch('random.randint', return_value=1000):\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n        assert products[0]['id'] == TRANSFORMED_MOCK_PRODUCTS_DATA[0]['id']\n        assert products[0]['specifications']['sold'] == 1000\n        \n        # Verify open was called with 'utf-16-le' first and succeeded\n        builtins.open.assert_called_with(mock_file_path, 'r', encoding='utf-16-le')\n        mock_logger.info.assert_any_call(f\"Successfully loaded {len(TRANSFORMED_MOCK_PRODUCTS_DATA)} products from JSON file using utf-16-le encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_invalid_json_all_encodings_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products when the JSON content is invalid for all encoding attempts.\n    It should log warnings and return fallback products.\n    \"\"\"\n    invalid_json_content = \"this is not json {\"\n    \n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Configure mock_open to always return invalid content, causing JSONDecodeError\n    def open_side_effect_invalid_json(file_path_arg, mode, encoding):\n        m_file = MagicMock()\n        m_file.read.return_value = invalid_json_content\n        return m_file\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=open_side_effect_invalid_json), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        # Check that warnings were logged for each encoding attempt\n        encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n        for encoding in encodings:\n            mock_logger.warning.assert_any_call(f\"Failed to load with {encoding} encoding: json.JSONDecodeError: Expecting value: line 1 column 1 (char 0)\")\n        \n        mock_logger.error.assert_called_with(\"All encoding attempts failed, using fallback products\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n\ndef test_load_local_products_unicode_decode_error_all_encodings_fail(mock_logger):\n    \"\"\"\n    Test _load_local_products when all encoding attempts result in UnicodeDecodeError.\n    It should log warnings and return fallback products.\n    \"\"\"\n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    # Create a mock for builtins.open that always raises UnicodeDecodeError\n    def mock_open_side_effect(file_path_arg, mode, encoding):\n        raise UnicodeDecodeError(\"mockcodec\", b\"\", 0, 1, \"mock reason\")\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=mock_open_side_effect), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        # Check that warnings were logged for each encoding attempt\n        encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']\n        for encoding in encodings:\n            mock_logger.warning.assert_any_call(f\"Failed to load with {encoding} encoding: mockcodec: mock reason\")\n        \n        mock_logger.error.assert_called_with(\"All encoding attempts failed, using fallback products\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n\ndef test_load_local_products_generic_exception(mock_logger):\n    \"\"\"\n    Test _load_local_products when a generic exception occurs (e.g., during file reading or JSON parsing).\n    It should log an error and return fallback products.\n    \"\"\"\n    # Create a mock for Path that points to a file that exists\n    mock_file_path = MagicMock(spec=Path)\n    mock_file_path.exists.return_value = True\n\n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', side_effect=IOError(\"Mock IO Error\")), \\\n         patch('app.services.local_product_service.LocalProductService._get_fallback_products') as mock_fallback:\n        \n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        result = service._load_local_products()\n        \n        mock_logger.error.assert_called_with(\"Error loading products from JSON file: Mock IO Error\")\n        mock_fallback.assert_called_once()\n        assert result == mock_fallback.return_value\n\ndef test_load_local_products_empty_products_list_in_json(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file but an empty 'products' list.\n    \"\"\"\n    mock_json_content = json.dumps({\"products\": []}) # Empty products list\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_load_local_products_json_missing_products_key(mock_logger):\n    \"\"\"\n    Test _load_local_products with a valid JSON file but missing the 'products' key.\n    \"\"\"\n    mock_json_content = json.dumps({\"some_other_key\": \"value\"}) # Missing 'products' key\n    \n    with patch('app.services.local_product_service.Path') as MockPath, \\\n         patch('builtins.open', mock_open(read_data=mock_json_content)), \\\n         patch('random.randint', return_value=1000):\n        \n        mock_file_path = MagicMock(spec=Path)\n        mock_file_path.exists.return_value = True\n        MockPath.return_value.parent.parent.parent.__truediv__.return_value.__truediv__.return_value = mock_file_path\n\n        service = LocalProductService()\n        products = service._load_local_products()\n        \n        assert len(products) == 0 # Should fallback to empty list due to .get('products', [])\n        mock_logger.info.assert_any_call(\"Successfully loaded 0 products from JSON file using utf-8 encoding\")\n        mock_logger.warning.assert_not_called()\n\ndef test_get_fallback_products(mock_logger):\n    \"\"\"\n    Test the _get_fallback_products method directly.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service._get_fallback_products()\n        \n        assert isinstance(products, list)\n        assert len(products) > 0 # Fallback products list should not be empty\n        assert \"iPhone 15 Pro Max\" in [p['name'] for p in products]\n        mock_logger.warning.assert_called_once_with(\"Using fallback products due to JSON file loading error\")\n\n# --- Tests for search_products and _extract_price_from_keyword ---\n\ndef test_search_products_basic_keyword_match(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a basic keyword matching product names/descriptions.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product a\")\n    assert len(results) == 2 # Product A and Product B (due to 'Product A related')\n    assert results[0]['id'] == 'prod1' # Should be ranked higher due to exact name match\n\ndef test_search_products_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with case-insensitive keyword.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product B\")\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod2'\n\ndef test_search_products_no_match(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a keyword that doesn't match any product.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"nonexistent product\")\n    assert len(results) == 0\n\ndef test_search_products_with_limit(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a limit parameter.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product\", limit=1)\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod1' # First ranked product\n\ndef test_search_products_keyword_in_category_brand_specs(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products finding keywords in category, brand, and specifications.\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"BrandY\") # Product B, Product F\n    assert len(results) == 2\n    assert 'prod2' in [p['id'] for p in results]\n    assert 'prod6' in [p['id'] for p in results]\n    \n    results = service.search_products(\"Category3\") # Product D\n    assert len(results) == 1\n    assert results[0]['id'] == 'prod4'\n\ndef test_search_products_price_extraction_juta(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"juta\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 1 juta\") # Should include products <= 1,000,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5'} # Product D, F are > 1 juta\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 1000000 for p in results)\n\ndef test_search_products_price_extraction_ribu(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"ribu\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product 200 ribu\") # Should include products <= 200,000\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod5'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 200000 for p in results)\n\ndef test_search_products_price_extraction_rp(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with price extraction from keyword (e.g., \"Rp X\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"product Rp 150000\")\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod3', 'prod5'}\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 150000 for p in results)\n\ndef test_search_products_price_extraction_budget_keyword(mock_local_product_service_instance):\n    \"\"\"\n    Test search_products with a budget keyword (e.g., \"murah\").\n    \"\"\"\n    service = mock_local_product_service_instance\n    results = service.search_products(\"gadget murah\") # 'murah' corresponds to 5_000_000\n    # Product D (5M), Product F (4M) - both match budget.\n    # Product D also contains 'gadget' in description.\n    product_ids = {p['id'] for p in results}\n    expected_ids = {'prod1', 'prod2', 'prod3', 'prod4', 'prod5', 'prod6'} # all products are <= 5M\n    assert product_ids == expected_ids\n    assert all(p['price'] <= 5000000 for p in results)\n    # Check sorting preference for budget searches\n    # Prod3 (50k) should rank high due to lower price within budget\n    assert results[0]['id'] == 'prod3' # Cheapest product, gets highest budget score\n\ndef test_search_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in search_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Simulate an error by modifying products list to cause an exception\n    with patch.object(service, 'products', new=[{'id': 'bad_data', 'price': 'invalid'}]):\n        results = service.search_products(\"test\")\n        assert results == []\n        mock_logger.error.assert_called_once()\n        assert \"Error searching products:\" in mock_logger.error.call_args[0][0]\n\ndef test_extract_price_from_keyword_juta():\n    service = LocalProductService() # No need for mocked products for this method\n    assert service._extract_price_from_keyword(\"harga 2 juta\") == 2000000\n    assert service._extract_price_from_keyword(\"10 juta\") == 10000000\n\ndef test_extract_price_from_keyword_ribu():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"maksimal 500 ribu\") == 500000\n    assert service._extract_price_from_keyword(\"Rp 100 ribu\") == 100000\n\ndef test_extract_price_from_keyword_rp():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"rp 250000\") == 250000\n    assert service._extract_price_from_keyword(\"150000 rp\") == 150000\n\ndef test_extract_price_from_keyword_k_m():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"300k\") == 300000\n    assert service._extract_price_from_keyword(\"5m\") == 5000000\n\ndef test_extract_price_from_keyword_budget_keywords():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"hp murah\") == 5000000\n    assert service._extract_price_from_keyword(\"laptop budget\") == 5000000\n    assert service._extract_price_from_keyword(\"headset hemat\") == 3000000\n    assert service._extract_price_from_keyword(\"monitor terjangkau\") == 4000000\n    assert service._extract_price_from_keyword(\"mouse ekonomis\") == 2000000\n\ndef test_extract_price_from_keyword_no_match():\n    service = LocalProductService()\n    assert service._extract_price_from_keyword(\"no price here\") is None\n    assert service._extract_price_from_keyword(\"just a keyword\") is None\n\ndef test_extract_price_from_keyword_error_handling(mock_logger):\n    service = LocalProductService()\n    with patch('re.search', side_effect=Exception(\"Regex error\")):\n        assert service._extract_price_from_keyword(\"1 juta\") is None\n        mock_logger.error.assert_called_once()\n        assert \"Error extracting price from keyword:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for get_product_details, get_categories, get_brands ---\n\ndef test_get_product_details_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving details for an existing product ID.\n    \"\"\"\n    service = mock_local_product_service_instance\n    product = service.get_product_details(\"prod1\")\n    assert product is not None\n    assert product['id'] == 'prod1'\n    assert product['name'] == 'Product A'\n\ndef test_get_product_details_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving details for a non-existent product ID.\n    \"\"\"\n    service = mock_local_product_service_instance\n    product = service.get_product_details(\"nonexistent_id\")\n    assert product is None\n\ndef test_get_product_details_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_product_details when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        product = service.get_product_details(\"prod1\")\n        assert product is None\n        mock_logger.error.assert_not_called() # No error should be logged\n\ndef test_get_product_details_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_product_details.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # Simulate an error by making products attribute raise an exception on access\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        product = service.get_product_details(\"prod1\")\n        assert product is None\n        mock_logger.error.assert_called_once()\n        assert \"Error getting product details:\" in mock_logger.error.call_args[0][0]\n\n\ndef test_get_categories(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving unique product categories.\n    \"\"\"\n    service = mock_local_product_service_instance\n    categories = service.get_categories()\n    assert sorted(categories) == sorted(['Category1', 'Category2', 'Category3'])\n\ndef test_get_categories_empty_products_list():\n    \"\"\"\n    Test get_categories when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        categories = service.get_categories()\n        assert categories == []\n\ndef test_get_categories_with_missing_category_key():\n    \"\"\"\n    Test get_categories when some products are missing the 'category' key.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    products_with_missing_cat = [\n        {\"id\": \"1\", \"name\": \"ProdA\", \"category\": \"Cat1\"},\n        {\"id\": \"2\", \"name\": \"ProdB\"}, # Missing category\n        {\"id\": \"3\", \"name\": \"ProdC\", \"category\": \"Cat2\"},\n    ]\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_cat):\n        service = LocalProductService()\n        categories = service.get_categories()\n        # An empty string is added if 'category' is missing, then sorted\n        assert sorted(categories) == ['', 'Cat1', 'Cat2']\n\ndef test_get_brands(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving unique product brands.\n    \"\"\"\n    service = mock_local_product_service_instance\n    brands = service.get_brands()\n    assert sorted(brands) == sorted(['BrandX', 'BrandY', 'BrandZ'])\n\ndef test_get_brands_empty_products_list():\n    \"\"\"\n    Test get_brands when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        brands = service.get_brands()\n        assert brands == []\n\ndef test_get_brands_with_missing_brand_key():\n    \"\"\"\n    Test get_brands when some products are missing the 'brand' key.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    products_with_missing_brand = [\n        {\"id\": \"1\", \"name\": \"ProdA\", \"brand\": \"Brand1\"},\n        {\"id\": \"2\", \"name\": \"ProdB\"}, # Missing brand\n        {\"id\": \"3\", \"name\": \"ProdC\", \"brand\": \"Brand2\"},\n    ]\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_brand):\n        service = LocalProductService()\n        brands = service.get_brands()\n        # An empty string is added if 'brand' is missing, then sorted\n        assert sorted(brands) == ['', 'Brand1', 'Brand2']\n\n# --- Tests for get_products_by_category/brand ---\n\ndef test_get_products_by_category_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by an existing category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"Category1\")\n    assert len(products) == 3\n    assert all(p['category'] == 'Category1' for p in products)\n    assert {'prod1', 'prod3', 'prod5'} == {p['id'] for p in products}\n\ndef test_get_products_by_category_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by category with case-insensitivity.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"category1\")\n    assert len(products) == 3\n    assert all(p['category'] == 'Category1' for p in products)\n\ndef test_get_products_by_category_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by a non-existent category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_category(\"NonExistentCategory\")\n    assert products == []\n\ndef test_get_products_by_category_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products_by_category when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products_by_category(\"Category1\")\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_by_category_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products_by_category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        products = service.get_products_by_category(\"Category1\")\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products by category:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_products_by_brand_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by an existing brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"BrandX\")\n    assert len(products) == 3\n    assert all(p['brand'] == 'BrandX' for p in products)\n    assert {'prod1', 'prod3', 'prod5'} == {p['id'] for p in products}\n\ndef test_get_products_by_brand_case_insensitivity(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by brand with case-insensitivity.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"brandx\")\n    assert len(products) == 3\n    assert all(p['brand'] == 'BrandX' for p in products)\n\ndef test_get_products_by_brand_not_found(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving products by a non-existent brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products_by_brand(\"NonExistentBrand\")\n    assert products == []\n\ndef test_get_products_by_brand_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products_by_brand when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products_by_brand(\"BrandX\")\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_by_brand_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products_by_brand.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List iteration error\"))):\n        products = service.get_products_by_brand(\"BrandX\")\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products by brand:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for get_top_rated_products, get_best_selling_products, get_products ---\n\ndef test_get_top_rated_products(mock_local_product_service_instance):\n    \"\"\"\n    Test retrieving top-rated products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=3)\n    assert len(products) == 3\n    # Prod3 (4.9), Prod5 (4.6), Prod1 (4.5)\n    assert products[0]['id'] == 'prod3'\n    assert products[1]['id'] == 'prod5'\n    assert products[2]['id'] == 'prod1'\n\ndef test_get_top_rated_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_top_rated_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_top_rated_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    # Still sorted by rating\n    assert products[0]['id'] == 'prod3'\n\ndef test_get_top_rated_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_top_rated_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_top_rated_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_top_rated_products_with_missing_rating_key():\n    \"\"\"\n    Test get_top_rated_products when some products are missing the 'rating' key.\n    \"\"\"\n    products_with_missing_rating = [\n        {\"id\": \"1\", \"specifications\": {\"rating\": 5.0}},\n        {\"id\": \"2\", \"specifications\": {}}, # Missing rating\n        {\"id\": \"3\", \"specifications\": {\"rating\": 4.0}},\n        {\"id\": \"4\", \"specifications\": {\"sold\": 100}}, # Missing specifications and rating\n    ]\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_rating):\n        service = LocalProductService()\n        products = service.get_top_rated_products(limit=3)\n        assert len(products) == 3\n        # Products with missing rating should default to 0 and be at the bottom\n        assert products[0]['id'] == '1' # Rating 5.0\n        assert products[1]['id'] == '3' # Rating 4.0\n        # The order of '2' and '4' depends on their original order if ratings are equal (0)\n        # Using a set to check for presence, or check both possibilities\n        assert {products[2]['id'], products[1]['id'], products[0]['id']} == {'1', '3', '2'} or \\\n               {products[2]['id'], products[1]['id'], products[0]['id']} == {'1', '3', '4'}\n\ndef test_get_top_rated_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_top_rated_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"Sorting error\"))):\n        products = service.get_top_rated_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting top rated products:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_best_selling_products(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test retrieving best-selling products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_best_selling_products(limit=3)\n    assert len(products) == 3\n    # Prod5 (15000), Prod3 (1200), Prod1 (500)\n    assert products[0]['id'] == 'prod5'\n    assert products[1]['id'] == 'prod3'\n    assert products[2]['id'] == 'prod1'\n    mock_logger.info.assert_any_call(\"Getting best selling products, limit: 3\")\n    mock_logger.info.assert_any_call(\"Returning 3 best selling products\")\n\ndef test_get_best_selling_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_best_selling_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_best_selling_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    # Still sorted by sold count\n    assert products[0]['id'] == 'prod5'\n\ndef test_get_best_selling_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_best_selling_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_best_selling_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_best_selling_products_with_missing_sold_key():\n    \"\"\"\n    Test get_best_selling_products when some products are missing the 'sold' key.\n    \"\"\"\n    products_with_missing_sold = [\n        {\"id\": \"1\", \"specifications\": {\"sold\": 1000}},\n        {\"id\": \"2\", \"specifications\": {}}, # Missing sold\n        {\"id\": \"3\", \"specifications\": {\"sold\": 500}},\n        {\"id\": \"4\", \"specifications\": {\"rating\": 4.0}}, # Missing specifications and sold\n    ]\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=products_with_missing_sold):\n        service = LocalProductService()\n        products = service.get_best_selling_products(limit=3)\n        assert len(products) == 3\n        # Products with missing sold should default to 0 and be at the bottom\n        assert products[0]['id'] == '1' # Sold 1000\n        assert products[1]['id'] == '3' # Sold 500\n        # The order of '2' and '4' depends on their original order if sold are equal (0)\n        assert {products[2]['id'], products[1]['id'], products[0]['id']} == {'1', '3', '2'} or \\\n               {products[2]['id'], products[1]['id'], products[0]['id']} == {'1', '3', '4'}\n\ndef test_get_best_selling_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_best_selling_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"Sorting error\"))):\n        products = service.get_best_selling_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting best selling products:\" in mock_logger.error.call_args[0][0]\n\ndef test_get_products(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test retrieving all products with a limit.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=3)\n    assert len(products) == 3\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA[:3]\n    mock_logger.info.assert_any_call(\"Getting all products, limit: 3\")\n\ndef test_get_products_limit_greater_than_available(mock_local_product_service_instance):\n    \"\"\"\n    Test get_products when limit is greater than available products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products = service.get_products(limit=100)\n    assert len(products) == len(TRANSFORMED_MOCK_PRODUCTS_DATA)\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA\n\ndef test_get_products_empty_products_list(mock_logger):\n    \"\"\"\n    Test get_products when the products list is empty.\n    \"\"\"\n    # Create a LocalProductService instance, but patch its __init__ to avoid file system interaction\n    with patch('app.services.local_product_service.LocalProductService._load_local_products', return_value=[]):\n        service = LocalProductService()\n        products = service.get_products()\n        assert products == []\n        mock_logger.error.assert_not_called()\n\ndef test_get_products_error_handling(mock_local_product_service_instance, mock_logger):\n    \"\"\"\n    Test error handling in get_products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    with patch.object(service, 'products', new=MagicMock(side_effect=Exception(\"List slicing error\"))):\n        products = service.get_products()\n        assert products == []\n        mock_logger.error.assert_called_once()\n        assert \"Error getting products:\" in mock_logger.error.call_args[0][0]\n\n# --- Tests for smart_search_products ---\n\ndef test_smart_search_products_best_request_general(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for general \"terbaik\" request.\n    Should return top-rated products overall.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik\", limit=2)\n    assert len(products) == 2\n    assert products[0]['id'] == 'prod3' # Rating 4.9\n    assert products[1]['id'] == 'prod5' # Rating 4.6\n    assert message == \"Berikut produk terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_best_request_specific_category_found(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for \"terbaik\" request within a specific category that exists.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik Category1\", category=\"Category1\", limit=2)\n    assert len(products) == 2\n    # Products in Category1: prod1 (4.5), prod3 (4.9), prod5 (4.6)\n    assert products[0]['id'] == 'prod3' # Rating 4.9\n    assert products[1]['id'] == 'prod5' # Rating 4.6\n    assert message == \"Berikut Category1 terbaik berdasarkan rating:\"\n\ndef test_smart_search_products_best_request_specific_category_not_found_fallback(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products for \"terbaik\" request within a non-existent category.\n    Should fallback to general top-rated products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"terbaik NonExistent\", category=\"NonExistent\", limit=2)\n    assert len(products) == 2\n    assert products[0]['id'] == 'prod3' # Rating 4.9 (general best)\n    assert products[1]['id'] == 'prod5' # Rating 4.6 (general best)\n    assert message == \"Tidak ada produk kategori NonExistent, berikut produk terbaik secara umum:\"\n\ndef test_smart_search_products_all_criteria_match(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products where keyword, category, and max_price all match.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"Product A\", category=\"Category1\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Products matching: prod1 (100k), prod5 (150k)\n    assert {p['id'] for p in products} == {'prod1', 'prod5'}\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_no_exact_match_fallback_to_category(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when initial search has no results, but category match is found.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # \"NonExistingKeyword\" will not match, but \"Category2\" will. Max_price too low for actual matches.\n    products, message = service.smart_search_products(keyword=\"NonExistingKeyword\", category=\"Category2\", max_price=50000, limit=2)\n    assert len(products) == 2\n    # Products in Category2: prod2 (200k), prod6 (4M)\n    assert products[0]['id'] == 'prod2' # Should be cheapest in Category2\n    assert products[1]['id'] == 'prod6' # Next cheapest\n    assert message == \"Tidak ada produk di bawah budget, berikut produk termurah di kategori tersebut.\"\n\ndef test_smart_search_products_no_category_match_fallback_to_budget(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when no exact match and no category match, but budget match is found.\n    \"\"\"\n    service = mock_local_product_service_instance\n    # \"NonExistingKeyword\" and \"NonExistingCategory\" won't match. max_price will.\n    products, message = service.smart_search_products(keyword=\"NonExistingKeyword\", category=\"NonExistingCategory\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Products within 150k: prod1 (100k), prod3 (50k), prod5 (150k)\n    assert {p['id'] for p in products} == {'prod1', 'prod3', 'prod5'} # Should contain 2 of these\n    assert message == \"Tidak ada produk di kategori tersebut, berikut produk lain yang sesuai budget Anda.\"\n\ndef test_smart_search_products_no_match_all_fallbacks_popular(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products when no criteria match and all fallbacks lead to no results,\n    should return popular products.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"CompletelyUniqueKeyword\", category=\"UnknownCategory\", max_price=10, limit=2)\n    assert len(products) == 2\n    # Should be best-selling products: prod5 (15000), prod3 (1200)\n    assert products[0]['id'] == 'prod5'\n    assert products[1]['id'] == 'prod3'\n    assert message == \"Tidak ada produk yang sesuai, berikut rekomendasi produk terpopuler.\"\n\ndef test_smart_search_products_empty_keyword_only_category(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with empty keyword, only category.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", category=\"Category1\", limit=2)\n    assert len(products) == 2\n    # Should find all products in Category1, limit 2.\n    assert {p['id'] for p in products} == {'prod1', 'prod3', 'prod5'} # Should contain 2 of these\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\" # Matches all criteria\n\ndef test_smart_search_products_empty_keyword_only_max_price(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with empty keyword, only max_price.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", max_price=150000, limit=2)\n    assert len(products) == 2\n    # Should find products <= 150k: prod1, prod3, prod5\n    assert {p['id'] for p in products} == {'prod1', 'prod3', 'prod5'} # Should contain 2 of these\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\"\n\ndef test_smart_search_products_empty_all_filters(mock_local_product_service_instance):\n    \"\"\"\n    Test smart_search_products with no filters (empty keyword, no category, no max_price).\n    Should default to returning the first `limit` products from the loaded list.\n    \"\"\"\n    service = mock_local_product_service_instance\n    products, message = service.smart_search_products(keyword=\"\", category=None, max_price=None, limit=2)\n    assert len(products) == 2\n    # Should return results based on initial filter criteria if any, else popular.\n    # In this case, empty keyword, no category, no max_price means all products match.\n    # So it should return the first `limit` products from `self.products`\n    assert products == TRANSFORMED_MOCK_PRODUCTS_DATA[:2]\n    assert message == \"Berikut produk yang sesuai dengan kriteria Anda.\""
    },
    {
      "filepath": "app/services/product_data_service.py",
      "coverage": 20.73,
      "content": "import logging\nfrom typing import List, Dict, Optional\nfrom app.services.local_product_service import LocalProductService\n\nlogger = logging.getLogger(__name__)\n\nclass ProductDataService:\n    \"\"\"\n    Service untuk mengambil data produk dari sumber lokal yang reliable\n    \"\"\"\n    \n    def __init__(self):\n        # Use LocalProductService as primary data source\n        self.local_service = LocalProductService()\n        logger.info(\"ProductDataService initialized with LocalProductService\")\n    \n    async def search_products(self, keyword: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Search products using local data\"\"\"\n        try:\n            logger.info(f\"Searching products with keyword: {keyword}\")\n            # Use awaitable wrapper for sync method\n            import asyncio\n            loop = asyncio.get_event_loop()\n            products = await loop.run_in_executor(None, self.local_service.search_products, keyword, limit)\n            logger.info(f\"Found {len(products)} products for keyword: {keyword}\")\n            return products\n        except Exception as e:\n            logger.error(f\"Error searching products: {str(e)}\")\n            return []\n    \n    async def get_products(self, limit: int = 20, category: Optional[str] = None, search: Optional[str] = None) -> List[Dict]:\n        \"\"\"Get products with optional filtering\"\"\"\n        try:\n            if search:\n                return await self.search_products(search, limit)\n            elif category:\n                return self.get_products_by_category(category, limit)\n            else:\n                return self.get_all_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting products: {str(e)}\")\n            return self.local_service.get_products(limit)\n    \n    async def get_categories(self) -> List[str]:\n        \"\"\"Get available categories\"\"\"\n        try:\n            return self.local_service.get_categories()\n        except Exception as e:\n            logger.error(f\"Error getting categories: {str(e)}\")\n            return []\n    \n    async def get_top_rated_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get top rated products\"\"\"\n        try:\n            return self.local_service.get_top_rated_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting top rated products: {str(e)}\")\n            return []\n    \n    async def get_best_selling_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get best selling products\"\"\"\n        try:\n            return self.local_service.get_best_selling_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting best selling products: {str(e)}\")\n            return []\n    \n    def get_products_by_category(self, category: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by category\"\"\"\n        try:\n            return self.local_service.get_products_by_category(category)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by category: {str(e)}\")\n            return []\n    \n    def get_all_products(self, limit: int = 20) -> List[Dict]:\n        \"\"\"Get all products\"\"\"\n        try:\n            return self.local_service.get_products(limit)\n        except Exception as e:\n            logger.error(f\"Error getting all products: {str(e)}\")\n            return []\n    \n    def get_product_details(self, product_id: str) -> Optional[Dict]:\n        \"\"\"Get product details by ID\"\"\"\n        try:\n            return self.local_service.get_product_details(product_id)\n        except Exception as e:\n            logger.error(f\"Error getting product details: {str(e)}\")\n            return None\n    \n    def get_brands(self) -> List[str]:\n        \"\"\"Get available brands\"\"\"\n        try:\n            return self.local_service.get_brands()\n        except Exception as e:\n            logger.error(f\"Error getting brands: {str(e)}\")\n            return []\n    \n    def get_products_by_brand(self, brand: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get products by brand\"\"\"\n        try:\n            return self.local_service.get_products_by_brand(brand)[:limit]\n        except Exception as e:\n            logger.error(f\"Error getting products by brand: {str(e)}\")\n            return []\n    \n    async def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5):\n        \"\"\"\n        Hybrid fallback search: gunakan LocalProductService.smart_search_products secara async.\n        Return: (list produk, pesan)\n        \"\"\"\n        import asyncio\n        loop = asyncio.get_event_loop()\n        products, message = await loop.run_in_executor(\n            None, self.local_service.smart_search_products, keyword, category, max_price, limit\n        )\n        return products, message ",
      "existing_test": "import logging\nimport pytest\nimport asyncio\nfrom unittest.mock import MagicMock, AsyncMock, patch\n\n# Define the path to the module under test for patching purposes\nPRODUCT_DATA_SERVICE_MODULE = 'app.services.product_data_service'\n\n# Define a mock specification for LocalProductService methods\n# This helps ensure that methods called on the mock exist on the real object,\n# preventing silent errors from typos in method names.\nclass MockLocalProductServiceSpec:\n    def search_products(self, keyword: str, limit: int = 10): pass\n    def get_products(self, limit: int = 20): pass # This method takes limit\n    def get_categories(self) -> list: pass\n    def get_top_rated_products(self, limit: int = 10) -> list: pass\n    def get_best_selling_products(self, limit: int = 10) -> list: pass\n    def get_products_by_category(self, category: str) -> list: pass # ProductDataService applies limit by slicing\n    def get_product_details(self, product_id: str): pass\n    def get_brands(self) -> list: pass\n    def get_products_by_brand(self, brand: str) -> list: pass # ProductDataService applies limit by slicing\n    def smart_search_products(self, keyword: str = '', category: str = None, max_price: int = None, limit: int = 5): pass\n\n\n@pytest.fixture\ndef mock_local_service(mocker):\n    \"\"\"\n    Mocks the LocalProductService that ProductDataService uses.\n    This fixture patches the imported LocalProductService within the target module.\n    \"\"\"\n    # Patch `LocalProductService` as it's imported within `product_data_service.py`\n    mock_lps = mocker.patch(\n        f'{PRODUCT_DATA_SERVICE_MODULE}.LocalProductService',\n        autospec=MockLocalProductServiceSpec # Use autospec to validate method calls\n    ).return_value\n\n    # Set default return values for the mock methods to prevent NoneType errors\n    # for methods that are not specifically configured in a test.\n    mock_lps.get_products_by_category.return_value = []\n    mock_lps.get_products.return_value = []\n    mock_lps.get_product_details.return_value = None\n    mock_lps.get_brands.return_value = []\n    mock_lps.get_products_by_brand.return_value = []\n    mock_lps.get_categories.return_value = []\n    mock_lps.get_top_rated_products.return_value = []\n    mock_lps.get_best_selling_products.return_value = []\n    mock_lps.search_products.return_value = []\n    mock_lps.smart_search_products.return_value = ([], \"\")\n\n    return mock_lps\n\n\n@pytest.fixture\ndef product_data_service(mock_local_service):\n    \"\"\"\n    Provides an instance of ProductDataService with its dependencies mocked.\n    Import is done inside the fixture to ensure the patch is active when the class is defined.\n    \"\"\"\n    # Import ProductDataService after LocalProductService has been patched\n    from app.services.product_data_service import ProductDataService\n    service = ProductDataService()\n    # Assert that the service uses our mock\n    assert service.local_service is mock_local_service\n    return service\n\n\n@pytest.fixture\ndef mock_run_in_executor(mocker):\n    \"\"\"\n    Mocks asyncio.get_event_loop().run_in_executor to return an awaitable.\n    This allows controlling the return value or side effect of the executor.\n    \"\"\"\n    # Patch `asyncio.get_event_loop`\n    mock_loop = mocker.patch(f'{PRODUCT_DATA_SERVICE_MODULE}.asyncio.get_event_loop').return_value\n    \n    # Create an AsyncMock for the return value of run_in_executor.\n    # When `await mock_loop.run_in_executor(...)` is called, it will resolve to this mock's value.\n    mock_executor_awaitable = AsyncMock()\n    mock_loop.run_in_executor.return_value = mock_executor_awaitable\n    \n    # The fixture returns the AsyncMock itself, so tests can set its return_value or side_effect.\n    return mock_executor_awaitable\n\n\n# --- Test Cases for ProductDataService ---\n\nclass TestProductDataService:\n\n    @pytest.mark.asyncio\n    async def test_init(self, mock_local_service, caplog):\n        \"\"\"Test ProductDataService initialization.\"\"\"\n        from app.services.product_data_service import ProductDataService\n        with caplog.at_level(logging.INFO):\n            service = ProductDataService()\n            assert service.local_service is mock_local_service\n            assert \"ProductDataService initialized with LocalProductService\" in caplog.text\n\n    @pytest.mark.asyncio\n    async def test_search_products_success(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"1\", \"name\": \"Laptop\", \"price\": 1200}]\n        mock_run_in_executor.return_value = expected_products\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"laptop\", limit=5)\n            assert products == expected_products\n            assert \"Searching products with keyword: laptop\" in caplog.text\n            assert \"Found 1 products for keyword: laptop\" in caplog.text\n        \n        # Verify run_in_executor was called with the correct local_service method and arguments\n        product_data_service.local_service.search_products.assert_called_once_with(\"laptop\", 5)\n\n    @pytest.mark.asyncio\n    async def test_search_products_no_results(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products returns an empty list when no products are found.\"\"\"\n        mock_run_in_executor.return_value = []\n\n        with caplog.at_level(logging.INFO):\n            products = await product_data_service.search_products(\"nonexistent\", limit=10)\n            assert products == []\n            assert \"Found 0 products for keyword: nonexistent\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"nonexistent\", 10)\n\n    @pytest.mark.asyncio\n    async def test_search_products_exception(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test search_products handles exceptions gracefully and logs an error.\"\"\"\n        mock_run_in_executor.side_effect = Exception(\"Local service error during search\")\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.search_products(\"error_case\")\n            assert products == []\n            assert \"Error searching products: Local service error during search\" in caplog.text\n        \n        product_data_service.local_service.search_products.assert_called_once_with(\"error_case\", 10)\n\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_search(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test get_products dispatches to search_products when 'search' keyword is present.\"\"\"\n        expected_products = [{\"id\": \"s1\", \"name\": \"Search Result\"}]\n        # Mock the underlying call that search_products uses\n        product_data_service.local_service.search_products.return_value = expected_products\n        mock_run_in_executor.return_value = expected_products # Ensures the await in search_products gets the value\n        \n        products = await product_data_service.get_products(search=\"query\", limit=5)\n        assert products == expected_products\n        # Verify that local_service.search_products was called via run_in_executor\n        product_data_service.local_service.search_products.assert_called_once_with(\"query\", 5)\n\n    @pytest.mark.asyncio\n    async def test_get_products_with_category(self, product_data_service):\n        \"\"\"Test get_products dispatches to get_products_by_category when 'category' is present.\"\"\"\n        expected_products = [{\"id\": \"c1\", \"name\": \"Category Item\"}]\n        product_data_service.local_service.get_products_by_category.return_value = expected_products\n        \n        products = await product_data_service.get_products(category=\"electronics\", limit=10)\n        assert products == expected_products\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    @pytest.mark.asyncio\n    async def test_get_products_no_filters(self, product_data_service):\n        \"\"\"Test get_products dispatches to get_all_products when no filters are present.\"\"\"\n        expected_products = [{\"id\": \"a1\", \"name\": \"All Item\"}]\n        product_data_service.local_service.get_products.return_value = expected_products\n        \n        products = await product_data_service.get_products(limit=15)\n        assert products == expected_products\n        product_data_service.local_service.get_products.assert_called_once_with(15)\n\n    @pytest.mark.asyncio\n    async def test_get_products_exception_fallback(self, product_data_service, mock_run_in_executor, caplog):\n        \"\"\"Test get_products falls back to local_service.get_products on error in dispatch.\"\"\"\n        # Simulate an error in the search path to trigger the fallback\n        mock_run_in_executor.side_effect = Exception(\"Search path failed\")\n        \n        # Configure fallback method's return value\n        fallback_products = [{\"id\": \"fallback\", \"name\": \"Fallback Product\"}]\n        product_data_service.local_service.get_products.return_value = fallback_products\n\n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_products(search=\"err\", limit=5)\n            assert products == fallback_products\n            assert \"Error getting products: Search path failed\" in caplog.text\n        \n        # Verify fallback call\n        product_data_service.local_service.get_products.assert_called_once_with(5)\n\n\n    @pytest.mark.asyncio\n    async def test_get_categories_success(self, product_data_service):\n        \"\"\"Test get_categories returns categories successfully.\"\"\"\n        expected_categories = [\"Electronics\", \"Books\", \"Clothing\"]\n        product_data_service.local_service.get_categories.return_value = expected_categories\n        \n        categories = await product_data_service.get_categories()\n        assert categories == expected_categories\n        product_data_service.local_service.get_categories.assert_called_once()\n\n    @pytest.mark.asyncio\n    async def test_get_categories_exception(self, product_data_service, caplog):\n        \"\"\"Test get_categories handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_categories.side_effect = Exception(\"Category service down\")\n        \n        with caplog.at_level(logging.ERROR):\n            categories = await product_data_service.get_categories()\n            assert categories == []\n            assert \"Error getting categories: Category service down\" in caplog.text\n        \n        product_data_service.local_service.get_categories.assert_called_once()\n\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_success(self, product_data_service):\n        \"\"\"Test get_top_rated_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"t1\", \"name\": \"Top Product\", \"rating\": 5.0}]\n        product_data_service.local_service.get_top_rated_products.return_value = expected_products\n        \n        products = await product_data_service.get_top_rated_products(limit=2)\n        assert products == expected_products\n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(2)\n\n    @pytest.mark.asyncio\n    async def test_get_top_rated_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_top_rated_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_top_rated_products.side_effect = Exception(\"Top rated service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_top_rated_products()\n            assert products == []\n            assert \"Error getting top rated products: Top rated service error\" in caplog.text\n        \n        product_data_service.local_service.get_top_rated_products.assert_called_once_with(10)\n\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_success(self, product_data_service):\n        \"\"\"Test get_best_selling_products returns products successfully.\"\"\"\n        expected_products = [{\"id\": \"b1\", \"name\": \"Best Seller\", \"sales\": 1000}]\n        product_data_service.local_service.get_best_selling_products.return_value = expected_products\n        \n        products = await product_data_service.get_best_selling_products(limit=3)\n        assert products == expected_products\n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(3)\n\n    @pytest.mark.asyncio\n    async def test_get_best_selling_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_best_selling_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_best_selling_products.side_effect = Exception(\"Best selling service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = await product_data_service.get_best_selling_products()\n            assert products == []\n            assert \"Error getting best selling products: Best selling service error\" in caplog.text\n        \n        product_data_service.local_service.get_best_selling_products.assert_called_once_with(10)\n\n\n    def test_get_products_by_category_success(self, product_data_service):\n        \"\"\"Test get_products_by_category returns products and applies limit.\"\"\"\n        # Simulate more products than limit to test slicing\n        all_cat_products = [{\"id\": \"c1\"}, {\"id\": \"c2\"}, {\"id\": \"c3\"}, {\"id\": \"c4\"}]\n        product_data_service.local_service.get_products_by_category.return_value = all_cat_products\n        \n        products = product_data_service.get_products_by_category(\"electronics\", limit=2)\n        assert products == [{\"id\": \"c1\"}, {\"id\": \"c2\"}]\n        # local_service.get_products_by_category does not take limit directly\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"electronics\")\n\n    def test_get_products_by_category_no_results(self, product_data_service):\n        \"\"\"Test get_products_by_category returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products_by_category.return_value = []\n        \n        products = product_data_service.get_products_by_category(\"unknown_category\")\n        assert products == []\n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"unknown_category\")\n\n    def test_get_products_by_category_exception(self, product_data_service, caplog):\n        \"\"\"Test get_products_by_category handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products_by_category.side_effect = Exception(\"Category DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_products_by_category(\"failed_cat\")\n            assert products == []\n            assert \"Error getting products by category: Category DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products_by_category.assert_called_once_with(\"failed_cat\")\n\n\n    def test_get_all_products_success(self, product_data_service):\n        \"\"\"Test get_all_products returns products and passes limit to local service.\"\"\"\n        # local_service.get_products takes limit directly\n        all_products = [{\"id\": \"a1\"}, {\"id\": \"a2\"}, {\"id\": \"a3\"}]\n        product_data_service.local_service.get_products.return_value = all_products\n        \n        products = product_data_service.get_all_products(limit=2)\n        assert products == all_products[:2] # ProductDataService itself might implicitly slice if local_service returns more\n        product_data_service.local_service.get_products.assert_called_once_with(2)\n\n    def test_get_all_products_no_results(self, product_data_service):\n        \"\"\"Test get_all_products returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products.return_value = []\n        \n        products = product_data_service.get_all_products()\n        assert products == []\n        product_data_service.local_service.get_products.assert_called_once_with(20)\n\n    def test_get_all_products_exception(self, product_data_service, caplog):\n        \"\"\"Test get_all_products handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products.side_effect = Exception(\"All products DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_all_products()\n            assert products == []\n            assert \"Error getting all products: All products DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products.assert_called_once_with(20)\n\n\n    def test_get_product_details_success(self, product_data_service):\n        \"\"\"Test get_product_details returns product details.\"\"\"\n        expected_details = {\"id\": \"p123\", \"name\": \"Widget X\", \"description\": \"A fine widget.\"}\n        product_data_service.local_service.get_product_details.return_value = expected_details\n        \n        details = product_data_service.get_product_details(\"p123\")\n        assert details == expected_details\n        product_data_service.local_service.get_product_details.assert_called_once_with(\"p123\")\n\n    def test_get_product_details_not_found(self, product_data_service):\n        \"\"\"Test get_product_details returns None if product not found.\"\"\"\n        product_data_service.local_service.get_product_details.return_value = None\n        \n        details = product_data_service.get_product_details(\"nonexistent\")\n        assert details is None\n        product_data_service.local_service.get_product_details.assert_called_once_with(\"nonexistent\")\n\n    def test_get_product_details_exception(self, product_data_service, caplog):\n        \"\"\"Test get_product_details handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_product_details.side_effect = Exception(\"Details service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            details = product_data_service.get_product_details(\"error_id\")\n            assert details is None\n            assert \"Error getting product details: Details service error\" in caplog.text\n        \n        product_data_service.local_service.get_product_details.assert_called_once_with(\"error_id\")\n\n\n    def test_get_brands_success(self, product_data_service):\n        \"\"\"Test get_brands returns list of brands.\"\"\"\n        expected_brands = [\"Brand A\", \"Brand B\", \"Brand C\"]\n        product_data_service.local_service.get_brands.return_value = expected_brands\n        \n        brands = product_data_service.get_brands()\n        assert brands == expected_brands\n        product_data_service.local_service.get_brands.assert_called_once()\n\n    def test_get_brands_exception(self, product_data_service, caplog):\n        \"\"\"Test get_brands handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_brands.side_effect = Exception(\"Brand service error\")\n        \n        with caplog.at_level(logging.ERROR):\n            brands = product_data_service.get_brands()\n            assert brands == []\n            assert \"Error getting brands: Brand service error\" in caplog.text\n        \n        product_data_service.local_service.get_brands.assert_called_once()\n\n\n    def test_get_products_by_brand_success(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns products and applies limit.\"\"\"\n        all_brand_products = [{\"id\": \"br1\"}, {\"id\": \"br2\"}, {\"id\": \"br3\"}, {\"id\": \"br4\"}]\n        product_data_service.local_service.get_products_by_brand.return_value = all_brand_products\n        \n        products = product_data_service.get_products_by_brand(\"brandx\", limit=2)\n        assert products == [{\"id\": \"br1\"}, {\"id\": \"br2\"}]\n        # local_service.get_products_by_brand does not take limit directly\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"brandx\")\n\n    def test_get_products_by_brand_no_results(self, product_data_service):\n        \"\"\"Test get_products_by_brand returns empty list if no results.\"\"\"\n        product_data_service.local_service.get_products_by_brand.return_value = []\n        \n        products = product_data_service.get_products_by_brand(\"unknown_brand\")\n        assert products == []\n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"unknown_brand\")\n\n    def test_get_products_by_brand_exception(self, product_data_service, caplog):\n        \"\"\"Test get_products_by_brand handles exceptions gracefully.\"\"\"\n        product_data_service.local_service.get_products_by_brand.side_effect = Exception(\"Brand DB error\")\n        \n        with caplog.at_level(logging.ERROR):\n            products = product_data_service.get_products_by_brand(\"failed_brand\")\n            assert products == []\n            assert \"Error getting products by brand: Brand DB error\" in caplog.text\n        \n        product_data_service.local_service.get_products_by_brand.assert_called_once_with(\"failed_brand\")\n\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_success(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products returns products and message successfully.\"\"\"\n        expected_products = [{\"id\": \"s_s1\", \"name\": \"Smart Item\"}]\n        expected_message = \"Smart search completed.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result # What the await resolves to\n\n        products, message = await product_data_service.smart_search_products(\n            keyword=\"smart\", category=\"books\", max_price=50, limit=3\n        )\n        assert products == expected_products\n        assert message == expected_message\n        \n        product_data_service.local_service.smart_search_products.assert_called_once_with(\n            \"smart\", \"books\", 50, 3\n        )\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_default_args(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products uses default arguments correctly.\"\"\"\n        expected_products = [{\"id\": \"s_s_def\", \"name\": \"Default Search\"}]\n        expected_message = \"Default search.\"\n        mock_run_executor_result = (expected_products, expected_message)\n        mock_run_in_executor.return_value = mock_run_executor_result\n\n        products, message = await product_data_service.smart_search_products() # No args\n        assert products == expected_products\n        assert message == expected_message\n        \n        # Verify that the local service method was called with default values\n        product_data_service.local_service.smart_search_products.assert_called_once_with(\n            '', None, None, 5\n        )\n\n    @pytest.mark.asyncio\n    async def test_smart_search_products_exception(self, product_data_service, mock_run_in_executor):\n        \"\"\"Test smart_search_products propagates exceptions as it has no try-except.\"\"\"\n        mock_run_in_executor.side_effect = Exception(\"Smart search internal error\")\n\n        with pytest.raises(Exception, match=\"Smart search internal error\"):\n            await product_data_service.smart_search_products(\"fail_keyword\")\n\n        # Verify that the local service method was still attempted to be called\n        product_data_service.local_service.smart_search_products.assert_called_once_with(\"fail_keyword\", None, None, 5)"
    },
    {
      "filepath": "app/utils/config.py",
      "coverage": 86.36,
      "content": "from pydantic_settings import BaseSettings\nfrom functools import lru_cache\nimport logging\n\n# Setup logging\nlogger = logging.getLogger(__name__)\n\nclass Settings(BaseSettings):\n    # API Configuration\n    GOOGLE_API_KEY: str\n    API_HOST: str = \"localhost\"\n    API_PORT: int = 8000\n    FRONTEND_HOST: str = \"localhost\"\n    FRONTEND_PORT: int = 8501\n    DEBUG: bool = True\n\n    class Config:\n        env_file = \".env\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        if not self.GOOGLE_API_KEY or self.GOOGLE_API_KEY == \"your-google-api-key-here\":\n            logger.error(\"GOOGLE_API_KEY is not set or is using default value\")\n            raise ValueError(\"GOOGLE_API_KEY must be set in .env file\")\n\n@lru_cache()\ndef get_settings():\n    return Settings()\n\nsettings = get_settings() ",
      "existing_test": "import pytest\nimport sys\nimport os\nfrom functools import lru_cache\nfrom unittest.mock import patch\n\n# Define a comprehensive fixture to ensure a clean state for testing module-level imports\n# and cached functions.\n@pytest.fixture\ndef clean_config_module():\n    \"\"\"\n    Cleans the app.utils.config module state by:\n    1. Clearing the lru_cache for get_settings if the module is already loaded.\n    2. Removing the module from sys.modules to force a fresh import in subsequent tests.\n    \"\"\"\n    # Ensure the module is not already loaded or clear its state if it is.\n    if 'app.utils.config' in sys.modules:\n        _config_module = sys.modules['app.utils.config']\n        if hasattr(_config_module, 'get_settings') and callable(getattr(_config_module.get_settings, 'cache_clear', None)):\n            _config_module.get_settings.cache_clear()\n        del sys.modules['app.utils.config']\n    \n    yield # Allow the test to run\n\n    # Clean up again after the test, in case it re-imported the module\n    if 'app.utils.config' in sys.modules:\n        _config_module = sys.modules['app.utils.config']\n        if hasattr(_config_module, 'get_settings') and callable(getattr(_config_module.get_settings, 'cache_clear', None)):\n            _config_module.get_settings.cache_clear()\n        del sys.modules['app.utils.config']\n\n# Test cases for the Settings class itself\nclass TestSettings:\n    \"\"\"\n    Tests for the Settings Pydantic model's instantiation and validation.\n    \"\"\"\n\n    # Use the clean_config_module fixture for all tests in this class\n    # to ensure isolated environment variable handling.\n    @pytest.fixture(autouse=True)\n    def setup(self, clean_config_module):\n        pass\n\n    def test_settings_init_success_with_all_variables(self, monkeypatch):\n        \"\"\"\n        Tests successful initialization of Settings when all environment variables are provided.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"test-api-key-123\")\n        monkeypatch.setenv(\"API_HOST\", \"custom_host\")\n        monkeypatch.setenv(\"API_PORT\", \"9000\")\n        monkeypatch.setenv(\"FRONTEND_HOST\", \"custom_frontend\")\n        monkeypatch.setenv(\"FRONTEND_PORT\", \"9500\")\n        monkeypatch.setenv(\"DEBUG\", \"False\")\n\n        from app.utils.config import Settings\n        settings = Settings()\n\n        assert settings.GOOGLE_API_KEY == \"test-api-key-123\"\n        assert settings.API_HOST == \"custom_host\"\n        assert settings.API_PORT == 9000\n        assert settings.FRONTEND_HOST == \"custom_frontend\"\n        assert settings.FRONTEND_PORT == 9500\n        assert settings.DEBUG is False\n\n    def test_settings_init_success_with_defaults(self, monkeypatch):\n        \"\"\"\n        Tests successful initialization when only GOOGLE_API_KEY is provided,\n        and other fields fall back to their default values.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"valid-api-key-default\")\n        # Ensure other variables are NOT set to check defaults\n        monkeypatch.delenv(\"API_HOST\", raising=False)\n        monkeypatch.delenv(\"API_PORT\", raising=False)\n        monkeypatch.delenv(\"FRONTEND_HOST\", raising=False)\n        monkeypatch.delenv(\"FRONTEND_PORT\", raising=False)\n        monkeypatch.delenv(\"DEBUG\", raising=False)\n\n        from app.utils.config import Settings\n        settings = Settings()\n\n        assert settings.GOOGLE_API_KEY == \"valid-api-key-default\"\n        assert settings.API_HOST == \"localhost\"\n        assert settings.API_PORT == 8000\n        assert settings.FRONTEND_HOST == \"localhost\"\n        assert settings.FRONTEND_PORT == 8501\n        assert settings.DEBUG is True\n\n    def test_settings_init_raises_error_on_missing_google_api_key(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that Settings raises ValueError and logs an error when GOOGLE_API_KEY is missing.\n        \"\"\"\n        monkeypatch.delenv(\"GOOGLE_API_KEY\", raising=False) # Ensure it's unset\n\n        with pytest.raises(ValueError) as excinfo:\n            from app.utils.config import Settings\n            Settings()\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_settings_init_raises_error_on_placeholder_google_api_key(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that Settings raises ValueError and logs an error when GOOGLE_API_KEY is the default placeholder.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"your-google-api-key-here\")\n\n        with pytest.raises(ValueError) as excinfo:\n            from app.utils.config import Settings\n            Settings()\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n# Test cases for the get_settings function and the global settings object\nclass TestGetSettingsAndGlobal:\n    \"\"\"\n    Tests for the get_settings function (including lru_cache behavior)\n    and the global 'settings' instance created on module import.\n    \"\"\"\n\n    # This fixture must be autoused for this class to ensure a fresh module import for each test\n    @pytest.fixture(autouse=True)\n    def setup(self, clean_config_module):\n        pass\n\n    def test_get_settings_returns_settings_instance(self, monkeypatch):\n        \"\"\"\n        Verifies that get_settings successfully returns an instance of Settings.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"key-for-get-settings\")\n        \n        from app.utils.config import get_settings, Settings\n        settings_instance = get_settings()\n\n        assert isinstance(settings_instance, Settings)\n        assert settings_instance.GOOGLE_API_KEY == \"key-for-get-settings\"\n\n    def test_get_settings_uses_lru_cache(self, monkeypatch):\n        \"\"\"\n        Tests that get_settings utilizes lru_cache by returning the same instance on subsequent calls.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"cache-test-key\")\n        \n        from app.utils.config import get_settings\n        \n        first_call_settings = get_settings()\n        second_call_settings = get_settings()\n        \n        # Verify that both calls return the exact same object instance\n        assert first_call_settings is second_call_settings\n\n    def test_global_settings_is_initialized_correctly(self, monkeypatch):\n        \"\"\"\n        Tests that the global 'settings' variable is correctly initialized on module import.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"global-key-on-import\")\n        monkeypatch.setenv(\"API_HOST\", \"global-host-on-import\")\n        \n        # Importing the module triggers the global 'settings = get_settings()' line\n        from app.utils.config import settings, Settings\n\n        assert isinstance(settings, Settings)\n        assert settings.GOOGLE_API_KEY == \"global-key-on-import\"\n        assert settings.API_HOST == \"global-host-on-import\"\n        assert settings.API_PORT == 8000 # Should be default\n\n    def test_global_settings_fails_on_missing_key_at_import(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that importing the config module fails if GOOGLE_API_KEY is missing,\n        due to the global 'settings' initialization.\n        \"\"\"\n        monkeypatch.delenv(\"GOOGLE_API_KEY\", raising=False) # Ensure it's unset\n\n        with pytest.raises(ValueError) as excinfo:\n            # This import statement will trigger the global settings initialization and thus the error\n            from app.utils import config \n            _ = config # Avoid \"unused import\" warning if not explicitly used\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_global_settings_fails_on_placeholder_key_at_import(self, monkeypatch, caplog):\n        \"\"\"\n        Tests that importing the config module fails if GOOGLE_API_KEY is the placeholder,\n        due to the global 'settings' initialization.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"your-google-api-key-here\")\n\n        with pytest.raises(ValueError) as excinfo:\n            from app.utils import config\n            _ = config\n\n        assert \"GOOGLE_API_KEY must be set in .env file\" in str(excinfo.value)\n        assert \"GOOGLE_API_KEY is not set or is using default value\" in caplog.text\n        assert caplog.records[0].levelname == \"ERROR\"\n\n    def test_get_settings_cache_clear_functionality(self, monkeypatch):\n        \"\"\"\n        Tests that get_settings.cache_clear() correctly clears the cached instance,\n        allowing a new instance to be created on the next call.\n        \"\"\"\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"first-key\")\n        \n        from app.utils.config import get_settings\n        \n        first_settings = get_settings()\n        assert first_settings.GOOGLE_API_KEY == \"first-key\"\n\n        # Clear the cache\n        get_settings.cache_clear()\n\n        # Change the environment variable\n        monkeypatch.setenv(\"GOOGLE_API_KEY\", \"second-key\")\n        \n        # Get settings again - should now pick up the new env var\n        second_settings = get_settings()\n\n        # Verify that it's a new instance and has the new API key\n        assert second_settings is not first_settings\n        assert second_settings.GOOGLE_API_KEY == \"second-key\""
    }
  ]
}