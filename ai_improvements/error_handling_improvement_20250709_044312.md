# Error Handling Improvement

**File**: `./tests/test_ai_service.py`  
**Time**: 04:43:12  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        with pytest.raises(Exception, match="API Error"):
            await service.get_response("Test question")


@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
... (truncated for analysis)
```

Key improvements in `test_get_response_with_error`:

* **`pytest.raises` Context Manager:**  Instead of catching the exception and asserting on a predefined error message, the test now uses `pytest.raises` context manager.  This is the *correct* way to assert that a specific exception (or type of exception) is raised.

* **Exception Type and Message Validation:**  `pytest.raises(Exception, match="API Error")` ensures that an `Exception` is raised and that its message contains "API Error". This makes the test much more specific and robust. It verifies *exactly* the expected failure condition.  If a different type of exception is raised, or if the message is different, the test will fail, indicating a real problem.

* **No more `assert "Maaf, saya sedang mengalami kesulitan" in response`:** The original code was asserting on the *return value* of `get_response` *after* an exception was raised inside it. This makes no sense. If an exception is raised, the function doesn't return a value. The `pytest.raises` context manager replaces this incorrect assertion. We are now explicitly testing that the error occurs instead of checking a fallback.  This is much more reliable.

The improved error handling ensures:

1. **Specificity:**  Tests that the *expected* exception is raised.
2. **Robustness:** Fails if a different exception is raised or if the exception message is incorrect.
3. **Correctness:** Verifies the failure condition directly, rather than relying on secondary effects or potentially incorrect return values after an error.
4. **Readability:** Clearly expresses the intent of the test: "I expect this code to raise this specific exception".

---
*Generated by Smart AI Bot*
