# Code Comments

**File**: `./app/api/queries.py`  
**Time**: 13:08:21  
**Type**: code_comments

## Improvement

```python
import logging
from typing import List, Dict
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.services.product_data_service import ProductDataService
from app.services.ai_service import AIService
import re

# Setup logging
logger = logging.getLogger(__name__)

router = APIRouter()
product_service = ProductDataService()
ai_service = AIService()

class QueryRequest(BaseModel):
    question: str

class QueryResponse(BaseModel):
    answer: str
    products: List[dict]
    question: str
    note: str

@router.post("/ask", response_model=QueryResponse)
async def ask_question(request: QueryRequest):
    """Ask a question about products and get recommendations"""
    try:
        # Get AI response
        ai_response = await ai_service.get_response(request.question)
        
        # Get relevant products and fallback message
        # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
        category = None
        max_price = None
        
        # Deteksi kategori dengan lebih lengkap
        question_lower = request.question.lower()
        category_mapping = {
            'laptop': ['laptop', 'notebook', 'komputer'],
            'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],
            'tablet': ['tablet', 'ipad'],
            'headphone': ['headphone', 'earphone', 'headset', 'audio'],
            'kamera': ['kamera', 'camera', 'fotografi'],
            'audio': ['audio', 'speaker', 'sound'],
            'tv': ['tv', 'televisi'],
            'drone': ['drone', 'quadcopter'],
            'jam': ['jam', 'watch', 'smartwatch']
        }
        
        # Iterate through the category mappings to find a match in the user's question.
        for cat, keywords in category_mapping.items():
            for keyword in keywords:
                if keyword in question_lower:
                    category = cat
                    break  # Stop searching within this category if a keyword is found.
            if category:
                break  # Stop searching through categories if one is found.

        # Regular expression to find price mentions, considering various formats.
        price_match = re.search(r"(harga\s?)([0-9.,]+)\s?(juta|ribu|k|m|)", question_lower)
        if price_match:
             # Extract the price value and normalize it to a numeric format.
            price_str = price_match.group(2).replace('.', '')  # Remove thousands separators
            price_str = price_str.replace(',', '.')  # Replace decimal comma with a dot
            
            try:
                price = float(price_str)
            except ValueError:
                logger.warning(f"Could not parse price: {price_str}")
                price = None # Handle parsing failures

            # Apply multipliers based on the price unit
            unit = price_match.group(3).lower()
            if unit == "juta" or unit == "m":
                price *= 1000000
            elif unit == "ribu" or unit == "k":
                price *= 1000
                
            max_price = price  # Assign the extracted price to max_price
            logger.info(f"Extracted max_price: {max_price}")

        # Get products based on extracted information
        products = product_service.get_products(category=category, max_price=max_price)
        fallback_message = "Sorry, I couldn't find specific products matching your request." if not products else ""

        # Construct the response
        response_data = {
            "answer": ai_response,
            "products": products,
            "question": request.question,
            "note": fallback_message
        }
        return QueryResponse(**response_data)

    except Exception as e:
        logger.exception("Error processing question")
        raise HTTPException(status_code=500, detail=str(e))
```

---
*Generated by Smart AI Bot*
