# Security Review

**File**: `./app/models/__init__.py`  
**Time**: 03:28:33  
**Type**: security_review

## Improvement

```python
"""
Data models for the application.
"""

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from sqlalchemy.orm import declarative_base, relationship
from sqlalchemy.sql import func
from sqlalchemy.orm import Session
from sqlalchemy import create_engine
from sqlalchemy.exc import IntegrityError

Base = declarative_base()


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)  # Store password hash, NOT plain text
    email = Column(String, unique=True, index=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    items = relationship("Item", back_populates="owner")

    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}')>"


class Item(Base):
    __tablename__ = "items"

    id = Column(Integer, primary_key=True, index=True)
    title = Column(String, index=True, nullable=False)
    description = Column(String, nullable=True)
    owner_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    owner = relationship("User", back_populates="items")

    def __repr__(self):
        return f"<Item(title='{self.title}', owner_id={self.owner_id})>"


# Example usage (demonstrating password hashing - crucial security improvement)
if __name__ == '__main__':
    from sqlalchemy import create_engine
    from sqlalchemy.orm import sessionmaker
    import bcrypt  # Import bcrypt for password hashing

    engine = create_engine("sqlite:///:memory:")  # In-memory database for demonstration
    Base.metadata.create_all(engine)

    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = SessionLocal()

    # --- SECURE PASSWORD HANDLING ---
    password = "mysecretpassword"
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')  # Hash the password

    new_user = User(username="testuser", email="test@example.com", hashed_password=hashed_password)
    db.add(new_user)

    try:
        db.commit()
        print("User added successfully.")
    except IntegrityError as e:
        db.rollback()
        print(f"Error adding user: {e}")
    finally:
        db.close()

    # --- Password Verification example (demonstrating best practice) ---
    db = SessionLocal()
    retrieved_user = db.query(User).filter(User.username == "testuser").first()

    if retrieved_user:
      #Correct way to verify the password
      if bcrypt.checkpw(password.encode('utf-8'), retrieved_user.hashed_password.encode('utf-8')):
        print("Password is correct")
      else:
        print("Password incorrect")


    db.close()
```

**Security Improvement:**

The most critical security improvement is to **store password hashes instead of plain text passwords**.  This is implemented by:

1.  **Adding `bcrypt` dependency:** The code now imports the `bcrypt` library.  This is a strong and widely-used password hashing library.  *Before running, you must install it: `pip install bcrypt`*
2.  **Hashing Passwords:**  Before storing a user's password, the code uses `bcrypt.hashpw()` to hash the password using a randomly generated salt. The hash is stored in the `hashed_password` column. This makes it nearly impossible for an attacker to recover the original passwords if the database is compromised.
3.  **Password Verification:** When a user tries to log in, the code fetches the hashed password from the database and uses `bcrypt.checkpw()` to compare the entered password with the stored hash. `bcrypt.checkpw()` automatically handles the salting process, ensuring that the passwords are compared correctly.  Critically, *never* try to "decrypt" or reverse the hash.  Always compare a hash of the *entered* password to the stored hash.

**Explanation:**

*   **Why Hashing?** If an attacker gains access to the database, they will see only the hashed passwords, not the plain text passwords.  Strong hashing algorithms like `bcrypt` make it computationally infeasible to reverse the hashing process and recover the original passwords.

*   **Why bcrypt?** `bcrypt` is a password hashing function based on the Blowfish cipher, specifically designed to be slow and resistant to brute-force attacks, rainbow table attacks, and other common password cracking techniques.  It automatically handles salting, which is essential for security.

*   **Salting:** A salt is a random value that is added to the password before hashing. This makes it more difficult for attackers to use precomputed rainbow tables to crack passwords. `bcrypt` automatically generates and manages salts for each password.

*   **`nullable=False`**:  This is added to the `username`, `hashed_password`, and `email` columns.  This prevents null values from being stored in the database, which could lead to unexpected errors and potentially bypass authentication.

**How to use `bcrypt`:**

1.  **Install the library:** `pip install bcrypt`
2.  **Hash the password before storing:** Use `bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')` to hash the password. Store the *hashed* password in the database.  `encode('utf-8')` is crucial because `bcrypt` operates on bytes, not strings. `decode('utf-8')` converts it back to a string suitable for storing in the database.
3.  **Verify the password during login:** Use `bcrypt.checkpw(entered_password.encode('utf-8'), stored_hashed_password.encode('utf-8'))` to compare the entered password with the stored hashed password.

This change significantly improves the security of the application by protecting user passwords in case of a data breach.

---
*Generated by Smart AI Bot*
