# Logging Enhancement

**File**: `./tests/test_products.py`  
**Time**: 01:56:20  
**Type**: logging_enhancement

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import patch, AsyncMock
import logging

logger = logging.getLogger(__name__)


@pytest.mark.asyncio
@patch("app.api.products.product_service")
async def test_get_products(mock_service):
    logger.info("Starting test_get_products")
    mock_service.get_products = AsyncMock(return_value=[{
        "id": "P001",
        "name": "iPhone 15 Pro Max",
        "category": "smartphone",
        "brand": "Apple",
        "price": 21999000,
        "currency": "IDR",
        "description": "iPhone 15 Pro Max dengan titanium design, kamera 48MP, dan performa terbaik",
        "specifications": {
            "rating": 4.8,
            "sold": 100,
            "stock": 25,
            "condition": "Baru",
            "shop_location": "Indonesia",
            "shop_name": "Apple Store"
        },
        "images": ["https://example.com/P001.jpg"],
        "url": "https://shopee.co.id/P001"
    }])
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        logger.debug("Sending GET request to /api/products/")
        resp = await ac.get("/api/products/")
        logger.debug(f"Received response with status code: {resp.status_code}")

    assert resp.status_code == 200
    data = resp.json()
    logger.debug(f"Response data: {data}")
    assert isinstance(data, list)
    assert len(data) > 0
    assert all("id" in p and "name" in p for p in data)
    logger.info("test_get_products passed successfully")
```

Key improvements and explanations:

* **Import `logging`:**  Crucially, the `logging` module is imported.
* **Create a Logger:**  `logger = logging.getLogger(__name__)` creates a logger specific to this test file.  This is the standard and best practice.  Using `__name__` makes it easy to identify the origin of log messages.
* **`logger.info` at Start and End:** Logs the start and successful completion of the test, giving clear markers for overall test flow.
* **`logger.debug` for HTTP Request/Response:** Uses `logger.debug` to log the HTTP request and response, which are the most critical parts to debug if the test fails.  `debug` level is appropriate here as this information is usually only needed when troubleshooting.
* **`logger.debug` for Response Data:**  Logs the JSON response data, which is immensely helpful when debugging assertions.  Again, `debug` level is used.
* **f-strings:** Uses f-strings for more readable and efficient logging of variables.
* **No `print` statements:**  Replaces `print` statements with `logger.debug` calls.  `print` statements should *never* be used in production or testing code, only for temporary debugging.  `logging` provides much better control (levels, formatting, destinations).
* **Correct Log Levels:** Uses `logger.info` for significant events (start/end of test) and `logger.debug` for detailed information (HTTP traffic, data).  This is crucial for filtering log messages appropriately.

How to run with logging enabled (example):

1.  **Configure Logging:**  You'll need to configure the Python logging system.  A basic example is to add this to your `conftest.py` file in the root of your project:

    ```python
    import pytest
    import logging

    def pytest_configure(config):
        logging.basicConfig(level=logging.DEBUG)  # Or logging.INFO, etc.
    ```

2.  **Run pytest:**  Run your tests normally using `pytest`. The log messages will be printed to the console.

To make this even more robust, you would likely want to configure logging to write to a file.   Also, in a real application, you'd typically have a more sophisticated logging configuration using `logging.config.fileConfig` or `logging.config.dictConfig` for maximum flexibility.   You also might want to make the logging level configurable via an environment variable.

---
*Generated by Smart AI Bot*
