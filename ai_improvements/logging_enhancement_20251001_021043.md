# Logging Enhancement

**File**: `./app/api/products.py`  
**Time**: 02:10:43  
**Type**: logging_enhancement

## Improvement

```python
from fastapi import APIRouter, HTTPException
from app.services.product_data_service import ProductDataService
from app.models.product import ProductResponse
from typing import List, Optional
import logging

router = APIRouter()
product_service = ProductDataService()

logger = logging.getLogger(__name__)

@router.get("/", response_model=List[ProductResponse])
async def get_products(
    limit: Optional[int] = 20,
    category: Optional[str] = None,
    search: Optional[str] = None
):
    """Get products from local data source"""
    logger.info(f"get_products called with limit={limit}, category={category}, search={search}")
    try:
        products = await product_service.get_products(
            limit=limit,
            category=category,
            search=search
        )
        logger.info(f"Successfully retrieved {len(products)} products.")
        return products
    except Exception as e:
        logger.exception("Error in get_products")
        raise HTTPException(status_code=500, detail=str(e))
```

Key improvements and explanations:

* **Import `logging`:**  The code now imports the `logging` module, which is essential for using logging functionality in Python.
* **Create a logger instance:**  `logger = logging.getLogger(__name__)` creates a logger instance specific to this module.  Using `__name__` is best practice because it allows you to see exactly where the log message originated in your application.
* **`logger.info` at the start:** Logs the incoming parameters to the function.  This is invaluable for debugging because you can see exactly what the function was called with.
* **`logger.info` after success:** Logs the number of products retrieved.  This confirms that the function executed successfully *and* provides a useful metric.
* **`logger.exception` in the `except` block:**  Crucially, this logs the *entire* exception, including the traceback.  This is the most important logging statement because it provides the information needed to diagnose errors.  `logger.exception` automatically includes the exception information. Using `logger.error(str(e))` is much less useful because you lose the traceback.

How to use the logging setup (example):

```python
import logging

# Configure logging (usually in your main application setup)
logging.basicConfig(level=logging.INFO) # set the minimum level of events that will be logged
#  logging.basicConfig(level=logging.DEBUG) #For VERY detailed logging during development


# Now, when you run your FastAPI application, you will see log messages in your console.
# uvicorn main:app --reload  (or whatever your usual run command is)
```

This example configures basic logging to the console.  For production applications, you'll typically want to configure logging to a file, use more advanced formatting, and potentially integrate with a logging service (like ELK stack or similar).  The `logging.basicConfig` call should only happen *once* in your application, typically in the `main.py` or startup script.  It's best practice to configure logging early in the application lifecycle.

---
*Generated by Smart AI Bot*
