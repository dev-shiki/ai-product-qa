# Error Handling Improvement

**File**: `./app/api/queries.py`  
**Time**: 03:21:58  
**Type**: error_handling_improvement

## Improvement

```python
import logging
from typing import List, Dict
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.services.product_data_service import ProductDataService
from app.services.ai_service import AIService
import re

# Setup logging
logger = logging.getLogger(__name__)

router = APIRouter()
product_service = ProductDataService()
ai_service = AIService()

class QueryRequest(BaseModel):
    question: str

class QueryResponse(BaseModel):
    answer: str
    products: List[dict]
    question: str
    note: str

@router.post("/ask", response_model=QueryResponse)
async def ask_question(request: QueryRequest):
    """Ask a question about products and get recommendations"""
    try:
        # Get AI response
        try:
            ai_response = await ai_service.get_response(request.question)
        except Exception as e:
            logger.exception(f"Error getting AI response: {e}")
            raise HTTPException(status_code=500, detail="Failed to get response from AI service.")

        # Get relevant products and fallback message
        # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
        category = None
        max_price = None
        
        # Deteksi kategori dengan lebih lengkap
        question_lower = request.question.lower()
        category_mapping = {
            'laptop': ['laptop', 'notebook', 'komputer'],
            'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],
            'tablet': ['tablet', 'ipad'],
            'headphone': ['headphone', 'earphone', 'headset', 'audio'],
            'kamera': ['kamera', 'camera', 'fotografi'],
            'audio': ['audio', 'speaker', 'sound'],
            'tv': ['tv', 'televisi'],
            'drone': ['drone', 'quadcopter'],
            'jam': ['jam', 'watch', 'smartwatch']
        }
... (truncated)
```

Key improvements:

* **Specific `try-except` for `ai_service.get_response()`:**  Instead of a broad `try-except` encompassing the entire function, I've wrapped *only* the call to `ai_service.get_response()` in a `try-except` block. This is crucial. It allows us to handle errors specifically related to the AI service failing, without masking errors that might occur in the subsequent product data retrieval or other parts of the function.

* **Logging the exception:** `logger.exception(f"Error getting AI response: {e}")` logs the full exception traceback.  This provides significantly more information for debugging.  It's best practice to log exceptions where you handle them.  Using `logger.exception` automatically includes the traceback in the log message.

* **Raising an `HTTPException`:**  `raise HTTPException(status_code=500, detail="Failed to get response from AI service.")` transforms the underlying exception into an HTTP 500 error, which is the correct way to signal a server-side error to the client.  The `detail` provides a user-friendly message.  By raising an exception *after* logging, the error is properly handled by FastAPI, and the client receives an appropriate response.

* **Clearer Error Message:**  The `detail` in the `HTTPException` provides a more informative message to the client about what went wrong.  Avoid exposing internal exception details to the client directly.

Why these changes are important:

* **Robustness:** The application becomes more resilient to errors in the AI service. If the AI service is temporarily unavailable, the API will return an appropriate error response instead of crashing or returning an unexpected result.

* **Debuggability:** Detailed logging of exceptions makes it much easier to diagnose and fix problems.  The traceback information is invaluable.

* **Maintainability:**  Isolating the error handling to the specific part of the code that might fail makes the code more understandable and easier to maintain.

* **Proper HTTP Error Codes:** Using `HTTPException` with appropriate status codes (like 500 for server errors) ensures that the API behaves correctly and provides useful information to clients.  Clients can then handle errors gracefully.

This improved version provides a more robust, debuggable, and maintainable solution compared to a simple generic `try-except` around the whole function.  It's generally best to handle exceptions as close as possible to where they occur.

---
*Generated by Smart AI Bot*
