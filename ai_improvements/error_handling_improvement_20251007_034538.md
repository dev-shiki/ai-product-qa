# Error Handling Improvement

**File**: `./tests/test_ai_service.py`  
**Time**: 03:45:38  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        with pytest.raises(Exception, match="API Error"): # Improved error handling here
            await service.get_response("Test question")

@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
```

Key improvements in the `test_get_response_with_error` function:

1. **`pytest.raises` Context Manager:** Instead of letting the exception be caught implicitly and then asserting on a string in the response, the `pytest.raises` context manager is used. This is the *correct* way to test that an exception is raised.

2. **Explicit Exception Type Assertion:** The `pytest.raises` now specifies `Exception` (you can replace it with a more specific exception type if `AIService` is designed to raise particular custom exceptions).  It verifies that an `Exception` is raised.

3. **Exception Message Matching (Optional but Recommended):** The `match="API Error"` argument is added to `pytest.raises`. This ensures that the raised exception not only is of the correct type, but also has the expected message.  This makes the test far more robust.  Without the message matching, the test would pass even if *any* exception were raised within the `get_response` call.

This improved version is significantly better because:

- It directly asserts that an exception is raised, which is the correct behavior when an API error occurs.
- It verifies the type of exception being raised.
- It verifies the *message* of the exception being raised.
- It avoids relying on an arbitrary "error message" string in the return value, which is a brittle approach. If the error message in `AIService` ever changes, the test would fail even if the exception handling is correct.

This addresses the prompt by providing improved error handling for *one* part, specifically the `test_get_response_with_error` test. The other tests are left unchanged, as requested.

---
*Generated by Smart AI Bot*
