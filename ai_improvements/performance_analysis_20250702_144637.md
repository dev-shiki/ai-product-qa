# Performance Analysis

**File**: `./tests/test_queries.py`  
**Time**: 14:46:37  
**Type**: performance_analysis

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import patch, AsyncMock

from app.main import app  # Import app here, outside the test functions

@pytest.fixture(scope="module")
async def async_client():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
        yield client


@pytest.mark.asyncio
@patch("app.api.queries.product_service")
@patch("app.api.queries.ai_service")
async def test_ask_question(mock_ai, mock_product, async_client):
    mock_ai.get_response = AsyncMock(return_value="Jawaban AI")
    mock_product.smart_search_products = AsyncMock(return_value=(
        [{"id": "P001", "name": "iPhone 15 Pro Max"}], 
        "Berikut produk yang sesuai dengan kriteria Anda."
    ))
    resp = await async_client.post("/api/queries/ask", json={"question": "Apa laptop terbaik?"})
    assert resp.status_code == 200
    data = resp.json()
    assert data["answer"] == "Jawaban AI"
    assert isinstance(data["products"], list)
    assert len(data["products"]) > 0
    assert "note" in data
    assert data["note"] == "Berikut produk yang sesuai dengan kriteria Anda."

@pytest.mark.asyncio
async def test_get_suggestions(async_client):
    resp = await async_client.get("/api/queries/suggestions")
    assert resp.status_code == 200
    data = resp.json()
    assert "suggestions" in data
    assert isinstance(data["suggestions"], list)

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_categories(mock_service, async_client):
    mock_service.get_categories = AsyncMock(return_value=["smartphone", "laptop", "tablet"])
    resp = await async_client.get("/api/queries/categories")
    assert resp.status_code == 200
    data = resp.json()
    assert "categories" in data
    assert set(data["categories"]) >= {"smartphone", "laptop", "tablet"}

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_brands(mock_service, async_client):
    mock_service.get_brands.return_value = ["Apple", "Samsung", "Sony"]
    resp = await async_client.get("/api/queries/brands")
    assert resp.status_code == 200
    data = resp.json()
    assert "brands" in data
    assert set(data["brands"]) >= {"Apple", "Samsung", "Sony"}

# ... rest of the tests
```

**Justification:**

The primary performance improvement is the introduction of a `pytest.fixture` with `scope="module"` named `async_client`.  This significantly reduces test execution time by creating and reusing the `AsyncClient` instance across all tests within the module.

**Explanation:**

1. **Fixture for Reusing `AsyncClient`:**  The original code created a new `AsyncClient` instance within each test function.  Creating a new `AsyncClient` involves initializing the ASGI transport, which has a noticeable overhead.  By using a module-scoped fixture, the `AsyncClient` (and thus the ASGI transport) is created only once at the beginning of the test module and reused by all test functions.

2. **`scope="module"`:**  The `scope="module"` argument tells pytest to create the fixture once per test module.  This balances the need for isolation with the performance benefits of reuse.  If the `AsyncClient` were scoped to `session`, it would be created only once for the entire test session, but that could lead to potential side effects between test modules if the application state changes.

3. **Dependency Injection:** Each test function that needs the `AsyncClient` now includes it as an argument (e.g., `test_ask_question(..., async_client)`).  pytest automatically detects this and injects the `async_client` fixture into the function.

4. **Moved app import:** The import of `app` is moved outside the test functions to the top of the file. This means it is only imported once for the entire module, preventing redundant imports for each test case.  This is a minor optimization but helps to ensure that imports only happen once where possible.

**Why this is better:**

- **Reduces Overhead:**  Creating and tearing down the ASGI transport for each test is eliminated, saving time. This is especially important for applications with complex initialization.
- **Faster Execution:** Overall test suite execution time is significantly reduced.
- **Maintains Isolation:** While the `AsyncClient` is reused within a module, each test still has its own isolated context within the application.

This is a very common and effective optimization technique for asynchronous integration tests using `httpx` and ASGI applications. This approach avoids the repeated setup and teardown, leading to a considerable performance boost.

---
*Generated by Smart AI Bot*
