# Logging Enhancement

**File**: `./app/api/products.py`  
**Time**: 04:01:44  
**Type**: logging_enhancement

## Improvement

```python
from fastapi import APIRouter, HTTPException
from app.services.product_data_service import ProductDataService
from app.models.product import ProductResponse
from typing import List, Optional
import logging

router = APIRouter()
product_service = ProductDataService()

# Configure logging (basic configuration for simplicity)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@router.get("/", response_model=List[ProductResponse])
async def get_products(
    limit: Optional[int] = 20,
    category: Optional[str] = None,
    search: Optional[str] = None
):
    """Get products from local data source"""
    logger.info(f"get_products endpoint called with limit={limit}, category={category}, search={search}")  # Log entry
    try:
        products = await product_service.get_products(
            limit=limit,
            category=category,
            search=search
        )
        logger.info(f"Successfully retrieved {len(products)} products.") # Log success
        return products
    except Exception as e:
        logger.exception("An error occurred while retrieving products:") # Log exception with traceback
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/categories")
async def get_categories():
    """Get available product categories"""
    try:
        categories = await product_service.get_categories()
        return {"categories": categories}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/search")
async def search_products(query: str, limit: Optional[int] = 10):
    """Search products by query"""
    try:
        products = await product_service.search_products(query, limit)
        return {"products": products, "query": query, "source": "local"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/top-rated")
async def get_top_rated_products(limit: Optional[int] = 10):
    """Get top rated products"""
    try:
        products = await product_service.get_top_rated_products(limit)
        return {"products": products, "source": "local"}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
```

Key improvements and explanations:

* **Import `logging`:**  Crucially, you need to import the `logging` module.
* **Basic Logging Configuration:**  `logging.basicConfig(level=logging.INFO)` sets up basic logging.  This is *essential* to see any log output.  Without this, even if you have logging statements, they won't be displayed.  You can adjust the `level` (e.g., `logging.DEBUG`, `logging.WARNING`, `logging.ERROR`) to control the verbosity of the logs.  A production system would likely use a more sophisticated configuration (e.g., writing to a file, using a rotating log handler).
* **Logger Instance:** `logger = logging.getLogger(__name__)` creates a logger instance.  Using `__name__` is a best practice; it will name the logger after the module, making it easier to trace where log messages originate.
* **Logging Levels:**
    * `logger.info()`:  Used for general informational messages (e.g., start and end of a function, key parameters).
    * `logger.exception()`:  This is the *most important* change.  It logs the exception *and* its traceback.  The traceback is critical for debugging.  You should use `logger.exception()` inside `except` blocks when you want to log the full details of an error. This automatically includes the exception message and stack trace.
* **Clear Log Messages:** The log messages are now more informative.  They include:
    * The parameters passed to the function.
    * The number of products retrieved (on success).
    * A general error message when an exception occurs.
* **Placement of Logging Statements:**
    * Log at the *beginning* of the function to record when it's called and with what parameters.
    * Log *after* a successful operation to confirm it completed and to potentially log the result (e.g., number of items returned).
    * Log the *exception* within the `except` block *before* re-raising it as an `HTTPException`.  This ensures the error is logged even though the API client receives an error response.
* **No Logging in Other Functions (as Requested):** The solution only modifies the `get_products` function and adds logging there.

This revised answer provides a complete, correct, and practical implementation of logging for the given FastAPI endpoint.  It addresses the common pitfalls and provides the necessary configuration and logging levels to make the logs useful for debugging and monitoring.

---
*Generated by Smart AI Bot*
