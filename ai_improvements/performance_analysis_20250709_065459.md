# Performance Analysis

**File**: `./app/services/ai_service.py`  
**Time**: 06:54:59  
**Type**: performance_analysis

## Improvement

```python
import logging
from google import genai
from app.utils.config import get_settings
from app.services.product_data_service import ProductDataService
import re  # Import here to avoid re-importing in each call to get_response

# Setup logging
logger = logging.getLogger(__name__)

# Precompile the regular expression once for efficiency
CATEGORY_MAPPING = {
    'laptop': r'\b(laptop|notebook|komputer)\b',
    'smartphone': r'\b(smartphone|hp|handphone|phone|telepon|ponsel)\b',
    'tablet': r'\b(tablet|ipad)\b',
    'headphone': r'\b(headphone|earphone|headset|audio)\b',
    'kamera': r'\b(kamera|camera|fotografi)\b',
    'audio': r'\b(audio|speaker|sound)\b',
    'tv': r'\b(tv|televisi)\b',
    'drone': r'\b(drone|quadcopter)\b',
    'jam': r'\b(jam|watch|smartwatch)\b'
}
COMPILED_CATEGORY_MAPPING = {cat: re.compile(pattern, re.IGNORECASE) for cat, pattern in CATEGORY_MAPPING.items()}


class AIService:
    def __init__(self):
        """Initialize AI service with Google AI API"""
        try:
            settings = get_settings()
            # Use the new Google AI client
            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)
            self.product_service = ProductDataService()
            logger.info("Successfully initialized AI service with Google AI client")
        except Exception as e:
            logger.error(f"Error initializing AI service: {str(e)}")
            raise

    async def get_response(self, question: str) -> str:
        """Get AI response with product context and fallback message"""
        try:
            logger.info(f"Getting AI response for question: {question}")

            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
            category = None
            max_price = None

            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)
            question_lower = question.lower()

            for cat, compiled_regex in COMPILED_CATEGORY_MAPPING.items():
                if compiled_regex.search(question_lower):
                    category = cat
                    break

... (truncated for analysis)
```

**Justification for the Performance Improvement:**

The primary performance improvement lies in **pre-compiling the regular expressions** used for category detection.

1. **`re.compile()` and Pre-compilation:**  Regular expression compilation is an expensive operation.  In the original code, the regular expressions (implicitly created by using strings directly in `re.search` or similar functions) were compiled *every time* the `get_response` method was called.  By compiling them once during class initialization and storing them as `COMPILED_CATEGORY_MAPPING`, we avoid redundant recompilation on each call to `get_response`.  This can significantly reduce CPU usage, especially when the `get_response` method is called frequently.

2. **Import `re` at the top level:**  The `import re` statement has been moved to the top of the file. This prevents the import statement from being executed within the `get_response` method on every invocation, as repeated imports can incur unnecessary overhead.

3. **Use of Compiled Regex in Search:** The original code looped through a dictionary of categories and keywords.  The improved code loops through the pre-compiled regular expressions and uses `compiled_regex.search(question_lower)` to detect the category. Using `.search()` against the precompiled regex improves performance compared to iterating through lists of strings and using `in` operator repeatedly.

These optimizations address the bottleneck in category detection by minimizing redundant computations and improving the efficiency of the matching process. This will reduce the execution time and CPU resources needed for each call to `get_response`.

---
*Generated by Smart AI Bot*
