# Error Handling Improvement

**File**: `./tests/test_queries.py`  
**Time**: 03:11:07  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport, HTTPStatusError
from unittest.mock import patch, AsyncMock

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
@patch("app.api.queries.ai_service")
async def test_ask_question(mock_ai, mock_product):
    mock_ai.get_response = AsyncMock(return_value="Jawaban AI")
    mock_product.smart_search_products = AsyncMock(return_value=(
        [{"id": "P001", "name": "iPhone 15 Pro Max"}], 
        "Berikut produk yang sesuai dengan kriteria Anda."
    ))
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.post("/api/queries/ask", json={"question": "Apa laptop terbaik?"})
            resp.raise_for_status()  # Raise HTTPStatusError for bad responses (4xx or 5xx)
        except HTTPStatusError as e:
            pytest.fail(f"Request failed: {e}")  # Fail the test with the error message

    assert resp.status_code == 200
    data = resp.json()
    assert data["answer"] == "Jawaban AI"
    assert isinstance(data["products"], list)
    assert len(data["products"]) > 0
    assert "note" in data
    assert data["note"] == "Berikut produk yang sesuai dengan kriteria Anda."

@pytest.mark.asyncio
async def test_get_suggestions():
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/queries/suggestions")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"Request failed: {e}")
    assert resp.status_code == 200
    data = resp.json()
    assert "suggestions" in data
    assert isinstance(data["suggestions"], list)

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_categories(mock_service):
    mock_service.get_categories = AsyncMock(return_value=["smartphone", "laptop", "tablet"])
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/queries/categories")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"Request failed: {e}")
    assert resp.status_code == 200
    data = resp.json()
    assert "categories" in data
    assert set(data["categories"]) >= {"smartphone", "laptop", "tablet"}

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_brands(mock_service):
    mock_service.get_brands.return_value = ["Apple", "Samsung", "Sony"]
... (truncated for analysis)
```

Key improvements and explanations:

* **`resp.raise_for_status()`:**  This is the core of the error handling improvement.  After each `await ac.get(...)` or `await ac.post(...)`, we call `resp.raise_for_status()`. This method automatically raises an `HTTPStatusError` exception if the HTTP response status code indicates an error (4xx or 5xx). This is *much* better than just checking `resp.status_code == 200` because it handles all error status codes appropriately.

* **`try...except HTTPStatusError` block:** We wrap the HTTP request within a `try...except` block to catch the `HTTPStatusError` that `resp.raise_for_status()` might raise.

* **`pytest.fail(f"Request failed: {e}")`:** Inside the `except` block, instead of just silently failing or continuing, we now call `pytest.fail()`.  This is the *correct* way to signal a test failure within a pytest test.  Critically, we include the exception `e` in the `fail()` message.  This gives us the *specific error message* from the HTTP request, making debugging much easier (e.g., "404 Not Found", "500 Internal Server Error", etc.).

Why this is better:

* **Handles all error cases:** The original code only checked for a 200 status.  This improved code handles *all* HTTP error codes (4xx and 5xx).
* **Provides informative error messages:** The `pytest.fail()` message includes the actual error that occurred, making debugging much easier.  You'll know *why* the request failed.
* **Proper test failure:** `pytest.fail()` ensures that the test is marked as a failure in pytest's reporting.
* **Concise and readable:**  The changes are straightforward and don't add unnecessary complexity.

This solution provides robust error handling for the HTTP requests, making the tests more reliable and easier to debug.  It addresses the prompt's request to improve error handling in ONE part, which I have chosen to be the HTTP request section. Each HTTP request now has exception handling.

---
*Generated by Smart AI Bot*
