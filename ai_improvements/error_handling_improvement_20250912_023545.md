# Error Handling Improvement

**File**: `./tests/test_queries.py`  
**Time**: 02:35:45  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport, HTTPStatusError
from unittest.mock import patch, AsyncMock

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
@patch("app.api.queries.ai_service")
async def test_ask_question(mock_ai, mock_product):
    mock_ai.get_response = AsyncMock(return_value="Jawaban AI")
    mock_product.smart_search_products = AsyncMock(return_value=(
        [{"id": "P001", "name": "iPhone 15 Pro Max"}], 
        "Berikut produk yang sesuai dengan kriteria Anda."
    ))
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.post("/api/queries/ask", json={"question": "Apa laptop terbaik?"})
            resp.raise_for_status()  # Raise HTTPStatusError for bad responses (4xx or 5xx)
        except HTTPStatusError as e:
            pytest.fail(f"HTTP request failed: {e}")  # Fail the test with the exception message
        except Exception as e:
            pytest.fail(f"An unexpected error occurred: {e}")

    assert resp.status_code == 200
    data = resp.json()
    assert data["answer"] == "Jawaban AI"
    assert isinstance(data["products"], list)
    assert len(data["products"]) > 0
    assert "note" in data
    assert data["note"] == "Berikut produk yang sesuai dengan kriteria Anda."

@pytest.mark.asyncio
async def test_get_suggestions():
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/queries/suggestions")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"HTTP request failed: {e}")
        except Exception as e:
            pytest.fail(f"An unexpected error occurred: {e}")
    assert resp.status_code == 200
    data = resp.json()
    assert "suggestions" in data
    assert isinstance(data["suggestions"], list)

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_categories(mock_service):
    mock_service.get_categories = AsyncMock(return_value=["smartphone", "laptop", "tablet"])
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/queries/categories")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"HTTP request failed: {e}")
        except Exception as e:
            pytest.fail(f"An unexpected error occurred: {e}")

    assert resp.status_code == 200
    data = resp.json()
    assert "categories" in data
    assert set(data["categories"]) >= {"smartphone", "laptop", "tablet"}

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_brands(mock_service):
    mock_service.get_brands.return_value = ["Apple", "Samsung", "Sony"]
... (truncated for analysis)
```

Key improvements:

* **`resp.raise_for_status()`:**  This is the core improvement.  It's called after each HTTP request.  If the response status code indicates an error (4xx or 5xx), `raise_for_status()` raises an `HTTPStatusError` exception. This ensures that the test fails immediately if the API returns an error, rather than continuing and potentially leading to misleading assertion failures.
* **`try...except` block:** Each test case that makes an HTTP request is wrapped in a `try...except` block. This allows us to catch `HTTPStatusError` specifically and also catch any other unexpected exceptions that might occur during the request.
* **`pytest.fail()`:** Instead of just letting the exception propagate (which might be confusing for someone reading the test results), we explicitly call `pytest.fail()` within the `except` block. This ensures that the test is marked as failed, and the exception message is included in the test output, making it much easier to diagnose the problem.  The `f-string` provides the specific error message.
* **General Error Handling:** Catches generic `Exception` to identify unexpected failures, providing more robust testing.

This revised code provides much better error handling by:

1.  Explicitly checking for HTTP errors and failing the test if they occur.
2.  Providing informative error messages in the test output.
3.  Handling potential unexpected errors during the API call. This makes the tests more reliable and easier to debug. Critically, this identifies the cause of the failure in the test output much more clearly.

---
*Generated by Smart AI Bot*
