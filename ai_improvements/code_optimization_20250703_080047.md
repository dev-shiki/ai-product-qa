# Code Optimization

**File**: `./tests/test_ai_service.py`  
**Time**: 08:00:47  
**Type**: code_optimization

## Improvement

**Optimization:**  Instantiate `AIService` outside of each test function.

**Explanation:**  The `AIService` is instantiated within each test function.  Since the tests all mock the underlying API calls, the `AIService` object is likely the same in all tests and can be instantiated once and reused, reducing object creation overhead. This is especially true since the setup for each test is identical.

**Revised code snippet (showing the change):**

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.fixture
def ai_service():
    return AIService()


@pytest.mark.asyncio
async def test_get_response(ai_service):  # Inject the service fixture
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response

        response = await ai_service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error(ai_service): # Inject the service fixture
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")

        response = await ai_service.get_response("Test question")
        assert "Maaf, saya sedang mengalami kesulitan" in response

@pytest.mark.asyncio
async def test_get_response_with_empty_question(ai_service): # Inject the service fixture
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response

        response = await ai_service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question(ai_service): # Inject the service fixture
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response

        long_question = "A" * 1000
        response = await ai_service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response
```

This reduces redundancy, making the code cleaner and potentially slightly faster.  Using a pytest fixture ensures the same instance is used across all tests that need it.

---
*Generated by Smart AI Bot*
