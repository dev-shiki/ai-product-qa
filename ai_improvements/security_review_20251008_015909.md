# Security Review

**File**: `./app/services/ai_service.py`  
**Time**: 01:59:09  
**Type**: security_review

## Improvement

```python
import logging
from google import genai
from app.utils.config import get_settings
from app.services.product_data_service import ProductDataService
import re  # Moved import to the top for clarity

# Setup logging
logger = logging.getLogger(__name__)

class AIService:
    def __init__(self):
        """Initialize AI service with Google AI API"""
        try:
            settings = get_settings()
            # Use the new Google AI client
            self.client = genai.Client(api_key=settings.GOOGLE_API_KEY)
            self.product_service = ProductDataService()
            logger.info("Successfully initialized AI service with Google AI client")
        except Exception as e:
            logger.error(f"Error initializing AI service: {str(e)}")
            raise

    async def get_response(self, question: str) -> str:
        """Get AI response with product context and fallback message"""
        try:
            logger.info(f"Getting AI response for question: {question}")

            # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
            category = None
            max_price = None
            
            # Deteksi kategori dengan lebih lengkap (sama dengan API endpoint)
            question_lower = question.lower()
            category_mapping = {
                'laptop': ['laptop', 'notebook', 'komputer'],
                'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],
                'tablet': ['tablet', 'ipad'],
                'headphone': ['headphone', 'earphone', 'headset', 'audio'],
                'kamera': ['kamera', 'camera', 'fotografi'],
                'audio': ['audio', 'speaker', 'sound'],
                'tv': ['tv', 'televisi'],
                'drone': ['drone', 'quadcopter'],
                'jam': ['jam', 'watch', 'smartwatch']
            }
            
            for cat, keywords in category_mapping.items():
                if any(keyword in question_lower for keyword in keywords):
                    category = cat
                    break

            # Extract max_price using regular expression with input validation
            try:
                match = re.search(r"(maksimal|max|di bawah)\s*([0-9.,]+)", question_lower)  # Corrected regex
                if match:
                    price_str = match.group(2).replace('.', '')  # Remove thousand separators
                    price_str = price_str.replace(',', '.')  # Standardize decimal separator
                    max_price = float(price_str)

                    # Input validation: Limit the maximum price to prevent excessive queries.
                    MAX_ALLOWED_PRICE = 100000000  # Example maximum price (adjust as needed)
                    if max_price > MAX_ALLOWED_PRICE:
                        logger.warning(f"Maximum price exceeded limit.  Using default response.  User input: {question}")
                        return "Maaf, harga maksimal yang bisa saya proses adalah {:,}".format(MAX_ALLOWED_PRICE).replace(',', '.')  # return default.
                else:
                    max_price = None  # No maximum price found
            except ValueError:
                logger.warning(f"Invalid price format.  Using default response.  User input: {question}")
                return "Maaf, format harga tidak valid. Tolong gunakan format yang benar (contoh: maksimal 5000000)."


            logger.info(f"Extracted category: {category}, max_price: {max_price}")


            # Construct prompt with context
            prompt = f"""Anda adalah asisten toko online. Jawab pertanyaan dari user berdasarkan konteks produk.
            Jika pertanyaan tidak berhubungan dengan produk, jawab dengan sopan bahwa Anda hanya bisa membantu pertanyaan seputar produk.

            Konteks:
            """

            if category:
                product_data = self.product_service.get_products(category=category, max_price=max_price)
                if product_data:
                    prompt += f"Produk {category} yang tersedia:\n"
                    for product in product_data:
                        prompt += f"- {product['name']} (Harga: {product['price']})\n"
                else:
                    prompt += f"Tidak ada produk {category} yang tersedia dengan kriteria tersebut.\n"
            else:
                prompt += "Semua kategori produk tersedia.\n"

            prompt += f"\nPertanyaan user: {question}\n"
            prompt += "Jawaban:"

            # Get response from Google AI
            response = self.client.generate_text(prompt=prompt)
            logger.info(f"AI response: {response.result}")
            return response.result

        except Exception as e:
            logger.exception(f"Error getting AI response: {str(e)}")
            return "Maaf, ada kesalahan dalam memproses pertanyaan Anda."
```

**Security Improvement:**

**Input Validation and Sanitization (Specifically on `max_price`):**

The primary security improvement is the addition of more robust input validation and sanitization on the `max_price` extracted from the user's question. This addresses the potential for denial-of-service (DoS) attacks or unexpected behavior if a user provides an extremely large or malformed price value.

**Explanation:**

1. **Regular Expression Improvement:** The regex `r"(maksimal|max|di bawah)\s*([0-9.,]+)"` is used to extract the numerical part of the price. This regex handles both comma and period as separators in price inputs.

2. **Thousand Separator Removal and Standardized Decimal Separator:** The extracted price string `price_str` has thousand separators (periods in the Indonesian locale) removed using `.replace('.', '')` and then standardizes the decimal separator to a period using `.replace(',', '.')` to ensure that Python can correctly parse it as a float.

3. **ValueError Handling:** The `try...except ValueError` block specifically catches errors that occur when the extracted string cannot be converted to a float.  This prevents the application from crashing if the user enters an invalid price format. A user-friendly error message is returned in this case.

4. **Maximum Allowed Price Limit:** A `MAX_ALLOWED_PRICE` constant is introduced.  After extracting the `max_price`, it's checked against this limit.  If the `max_price` exceeds the limit, the application logs a warning and returns a pre-defined response indicating that the price is too high.  This prevents the application from potentially making excessively large database queries or API calls that could degrade performance or lead to a denial-of-service.  The error message helps the user understand the limitation.

**Why this is important:**

*   **DoS Prevention:** Without input validation, an attacker could supply a very large `max_price` value. This could lead to the `product_service.get_products` function making a very large database query, consuming significant resources and potentially slowing down or crashing the application.  The price limit mitigates this.

*   **Data Integrity:**  Validating the format of the `max_price` ensures that the application is working with correct data.  Without this, malformed input might lead to incorrect filtering of products or errors in subsequent processing.

*   **Error Handling and User Experience:**  By explicitly handling `ValueError` and providing user-friendly error messages, the application avoids unexpected crashes and guides the user towards providing valid input.

This combination of regex parsing, error handling, and price limiting provides a significantly more secure and robust solution compared to the original code.  Always validate and sanitize user input before using it in any potentially resource-intensive operations.  The exact `MAX_ALLOWED_PRICE` should be determined based on the specific requirements and capabilities of the `product_service`.

---
*Generated by Smart AI Bot*
