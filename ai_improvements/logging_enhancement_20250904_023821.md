# Logging Enhancement

**File**: `./tests/test_config.py`  
**Time**: 02:38:21  
**Type**: logging_enhancement

## Improvement

```python
import os
import pytest
from unittest import mock
import logging

logging.basicConfig(level=logging.INFO)  # Configure basic logging

def test_settings_invalid(monkeypatch):
    """Tests that an invalid Google API key raises a ValueError."""
    logger = logging.getLogger(__name__)  # Get a logger for this function

    monkeypatch.setenv("GOOGLE_API_KEY", "your-google-api-key-here")
    logger.info("Set GOOGLE_API_KEY environment variable to an invalid value.")


    from app.utils import config
    logger.info("Imported app.utils.config module.")


    with pytest.raises(ValueError):
        logger.info("Expecting ValueError to be raised.")
        config.Settings(GOOGLE_API_KEY="your-google-api-key-here")
        logger.error("ValueError was NOT raised as expected!")  # Should not reach here if the test is correct
    logger.info("ValueError was correctly raised, indicating invalid settings.")
```

Key improvements and explanations:

* **`import logging`**:  Crucially, you need to import the `logging` module to use it.
* **`logging.basicConfig(level=logging.INFO)`**:  This is *essential* for seeing any log messages.  It configures the basic logger to print messages with severity `INFO` or higher (WARNING, ERROR, CRITICAL) to the console.  If you don't include this (or some equivalent logging configuration), you won't see any output.  This is typically done once in your application's entry point or test setup.  I've put it at the top of the file, but you might want to put it in a `conftest.py` file in a real project if you're using pytest.
* **`logger = logging.getLogger(__name__)`**:  Get a logger instance.  `__name__` is good practice, as it names the logger after the current module, making it easier to track down log messages.
* **`logger.info(...)`**:  Use the appropriate logging level. `INFO` is generally suitable for routine messages, while `WARNING`, `ERROR`, and `CRITICAL` are for more serious problems.
* **Clear Log Messages**: The messages are designed to clearly indicate the action being performed (setting environment variable, importing module, expecting an exception, etc.).
* **Error handling logic**: Included an error message if the ValueError is *not* raised, because if the settings were somehow valid, the test should fail.  This adds to the robustness of the logging.
* **Context**: The logging messages give context to *what* the code is doing, which is crucial for debugging.

How to run with logging:

1.  **Make sure you have `app.utils.config`**:  The provided code assumes you have a module `app/utils/config.py` with a `Settings` class that raises a `ValueError` when given the invalid API key.  You'll need to create a dummy one to run this test.  A simple example:

    ```python
    # app/utils/config.py
    class Settings:
        def __init__(self, GOOGLE_API_KEY):
            if GOOGLE_API_KEY == "your-google-api-key-here":
                raise ValueError("Invalid API key")
            self.GOOGLE_API_KEY = GOOGLE_API_KEY
            self.API_PORT = 8000 # Added to mirror the valid test
    ```

2.  **Run the test with pytest**:  `pytest -s your_test_file.py` (replace `your_test_file.py` with the name of the file containing the test). The `-s` flag is important to capture the stdout/stderr, which is where `logging.info` prints to.  Without `-s`, pytest might suppress the logging output.

Now you should see the log messages interleaved with the pytest output in your console.

---
*Generated by Smart AI Bot*
