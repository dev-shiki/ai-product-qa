# Logging Enhancement

**File**: `./tests/test_ai_service.py`  
**Time**: 02:35:09  
**Type**: logging_enhancement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService
import logging

logger = logging.getLogger(__name__)


@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response

        logger.info("Calling get_response with question: %s", "Test question")  # Added logging
        response = await service.get_response("Test question")
        logger.info("Received response: %s", response)  # Added logging
        assert response == "Test response"
```

Key improvements and explanations:

* **Import `logging`:**  The `logging` module is now imported.  This is essential for using the logging functionality.
* **Create a logger:** `logger = logging.getLogger(__name__)` creates a logger instance specific to this module (`test_ai_service.py` in this case).  This is best practice because it allows you to configure logging for different parts of your application independently.  The `__name__` will automatically be the name of the module.
* **Log the question and response:**  `logger.info("Calling get_response with question: %s", "Test question")` logs the question being sent to the `get_response` function.  The `%s` is a placeholder for string formatting.  This is much better than string concatenation (e.g., `logger.info("Question: " + question)`) because it's more efficient and prevents potential errors if the variable is not a string.  I have added this logging statement right before calling `get_response`.
* **Log the response:** `logger.info("Received response: %s", response)` logs the response received from the `get_response` function. I have added this logging statement after calling `get_response`.
* **Logging Level:**  I used `logger.info`.  This means that the messages will only be displayed if the logging level is set to `INFO` or lower (e.g., `DEBUG`).  You can change this to `logger.debug`, `logger.warning`, `logger.error`, or `logger.critical` depending on the severity of the message. `INFO` is generally a good choice for recording normal operation events.

How to run with logging:

To actually see the log messages, you need to configure the logging system.  A simple way to do this is to add the following lines to your `conftest.py` file (create one if you don't have it):

```python
# conftest.py
import pytest
import logging

def pytest_configure(config):
    logging.basicConfig(level=logging.INFO)  # Or logging.DEBUG for more detailed logs
```

This will configure the basic logging system to output messages at the `INFO` level to the console.  You can customize this further to log to a file, use different formatting, etc.

Now, when you run your tests with `pytest`, you'll see the log messages in the console output along with the test results.  Critically, *if you don't configure the logging system, you won't see any output*, even though the logging statements are present in your code.

---
*Generated by Smart AI Bot*
