# Code Optimization

**File**: `./tests/test_queries.py`  
**Time**: 06:54:18  
**Type**: code_optimization

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import patch, AsyncMock

from app.main import app  # Import app once at the top

@pytest.fixture(scope="session")  # Define the client as a session-scoped fixture
async def client():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        yield ac

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
@patch("app.api.queries.ai_service")
async def test_ask_question(mock_ai, mock_product, client):  # Inject the client fixture
    mock_ai.get_response = AsyncMock(return_value="Jawaban AI")
    mock_product.smart_search_products = AsyncMock(return_value=(
        [{"id": "P001", "name": "iPhone 15 Pro Max"}], 
        "Berikut produk yang sesuai dengan kriteria Anda."
    ))
    resp = await client.post("/api/queries/ask", json={"question": "Apa laptop terbaik?"})
    assert resp.status_code == 200
    data = resp.json()
    assert data["answer"] == "Jawaban AI"
    assert isinstance(data["products"], list)
    assert len(data["products"]) > 0
    assert "note" in data
    assert data["note"] == "Berikut produk yang sesuai dengan kriteria Anda."

@pytest.mark.asyncio
async def test_get_suggestions(client): # Inject the client fixture
    resp = await client.get("/api/queries/suggestions")
    assert resp.status_code == 200
    data = resp.json()
    assert "suggestions" in data
    assert isinstance(data["suggestions"], list)

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_categories(mock_service, client):  # Inject the client fixture
    mock_service.get_categories = AsyncMock(return_value=["smartphone", "laptop", "tablet"])
    resp = await client.get("/api/queries/categories")
    assert resp.status_code == 200
    data = resp.json()
    assert "categories" in data
    assert set(data["categories"]) >= {"smartphone", "laptop", "tablet"}

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_brands(mock_service, client):  # Inject the client fixture
    mock_service.get_brands.return_value = ["Apple", "Samsung", "Sony"]
... (truncated for analysis)
```

**Improvement:**  Define `AsyncClient` as a `session`-scoped pytest fixture.

**Explanation:**

The original code creates a new `AsyncClient` instance within each test function.  Creating an `AsyncClient` involves setting up the ASGI transport which can be relatively expensive.  By defining the `AsyncClient` as a session-scoped fixture:

1.  The `AsyncClient` is created only once for the entire test session.
2.  Each test function then receives the *same* `AsyncClient` instance through fixture injection.

This significantly reduces the overhead of creating and tearing down the client for each test, resulting in faster test execution times.  This is a standard pytest pattern for expensive resources that can be reused across multiple tests.  I've also imported `app` once at the top, avoiding redundant imports in each test. This is a minor optimization, but contributes to cleaner code.  I then injected the client fixture into each test function that needs it.

---
*Generated by Smart AI Bot*
