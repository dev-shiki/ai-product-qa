# Performance Analysis

**File**: `./app/api/queries.py`  
**Time**: 03:43:21  
**Type**: performance_analysis

## Improvement

```python
import logging
from typing import List, Dict
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.services.product_data_service import ProductDataService
from app.services.ai_service import AIService
import re
import asyncio  # Import asyncio


# Setup logging
logger = logging.getLogger(__name__)

router = APIRouter()
product_service = ProductDataService()
ai_service = AIService()

class QueryRequest(BaseModel):
    question: str

class QueryResponse(BaseModel):
    answer: str
    products: List[dict]
    question: str
    note: str

@router.post("/ask", response_model=QueryResponse)
async def ask_question(request: QueryRequest):
    """Ask a question about products and get recommendations"""
    try:
        # Get AI response
        ai_response = await ai_service.get_response(request.question)
        
        # Get relevant products and fallback message
        # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
        category = None
        max_price = None
        
        # Deteksi kategori dengan lebih lengkap
        question_lower = request.question.lower()
        category_mapping = {
            'laptop': ['laptop', 'notebook', 'komputer'],
            'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],
            'tablet': ['tablet', 'ipad'],
            'headphone': ['headphone', 'earphone', 'headset', 'audio'],
            'kamera': ['kamera', 'camera', 'fotografi'],
            'audio': ['audio', 'speaker', 'sound'],
            'tv': ['tv', 'televisi'],
            'drone': ['drone', 'quadcopter'],
            'jam': ['jam', 'watch', 'smartwatch']
        }

        for cat, keywords in category_mapping.items():
            if any(keyword in question_lower for keyword in keywords):
                category = cat
                break  # Stop after the first match

        # Mencari harga maksimal (contoh sederhana, bisa ditingkatkan)
        price_match = re.search(r"(maksimal|kurang dari|di bawah) ([\d\.]+)", question_lower)
        if price_match:
            try:
                max_price = float(price_match.group(2).replace('.', ''))  # Bersihkan format angka
            except ValueError:
                logger.warning(f"Could not parse max_price from query: {request.question}")


        # Get products based on category and price
        products = await product_service.get_products(category=category, max_price=max_price)
        fallback_message = "Maaf, tidak ada produk yang sesuai dengan kriteria Anda." if not products else None

        # Construct response
        response_data = {
            "answer": ai_response,
            "products": products,
            "question": request.question,
            "note": fallback_message
        }

        return QueryResponse(**response_data)

    except Exception as e:
        logger.exception(f"Error processing query: {request.question}")
        raise HTTPException(status_code=500, detail=str(e))
```

**Justification:**

The core performance bottleneck is likely within the `product_service.get_products` call and the `ai_service.get_response` call.  Both are awaited, and could potentially benefit from parallel execution. However, given the instructions to provide *one* performance improvement, and without knowing the internal implementation of those services, it's safer to focus on a simpler improvement: eliminating redundant string processing in the category matching.

The original code iterated through the `category_mapping` and checked for multiple keywords for each category sequentially. Even if a category was found, the loop would continue unnecessarily. The added `break` statement after finding a matching category ensures that the loop terminates as soon as a category is identified, saving unnecessary iterations and string comparisons.

Specifically, the following line was added inside the category loop:

```python
                break  # Stop after the first match
```

This is a targeted, simple optimization that will reduce the overall execution time, especially when a matching category is found early in the `category_mapping`.  This reduces the number of times `question_lower` is searched.

---
*Generated by Smart AI Bot*
