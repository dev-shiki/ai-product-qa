# Error Handling Improvement

**File**: `./tests/test_ai_service.py`  
**Time**: 03:49:09  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        try:
            response = await service.get_response("Test question")
            assert "Maaf, saya sedang mengalami kesulitan" in response
        except Exception as e:
            pytest.fail(f"Unexpected exception: {e}")  # Fail the test if an exception occurs

@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
... (truncated for analysis)
```

Key improvements in the `test_get_response_with_error` function:

* **Explicit Exception Handling:**  Instead of implicitly relying on the AIService to catch and return a specific message in case of an error, the test now explicitly uses a `try...except` block. This allows the test to directly catch the `Exception` raised by `mock_generate.side_effect`.
* **`pytest.fail()`:**  If an exception *does* occur within the `try` block (meaning the `AIService` did *not* handle the exception as expected), the `pytest.fail()` function is called.  This immediately fails the test and provides a clear error message including the original exception.  This makes it much easier to diagnose problems when the error handling in `AIService` is incorrect.
* **Why This Is Better:**  The original test was fragile.  If the `AIService` *failed* to handle the exception and let it bubble up, the test would pass because the assertion would never be reached (and pytest doesn't automatically fail on unhandled exceptions).  This improved version *guarantees* that the test will fail if the `AIService` doesn't correctly handle the mocked exception, making the test much more reliable. Also, it provides the exact exception that was raised, simplifying debugging. This approach ensures that the test specifically verifies the error handling behavior of the AIService, making it more robust and informative.

---
*Generated by Smart AI Bot*
