# Error Handling Improvement

**File**: `./app/api/queries.py`  
**Time**: 05:08:00  
**Type**: error_handling_improvement

## Improvement

```python
import logging
from typing import List, Dict
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.services.product_data_service import ProductDataService
from app.services.ai_service import AIService
import re

# Setup logging
logger = logging.getLogger(__name__)

router = APIRouter()
product_service = ProductDataService()
ai_service = AIService()

class QueryRequest(BaseModel):
    question: str

class QueryResponse(BaseModel):
    answer: str
    products: List[dict]
    question: str
    note: str

@router.post("/ask", response_model=QueryResponse)
async def ask_question(request: QueryRequest):
    """Ask a question about products and get recommendations"""
    try:
        # Get AI response
        try:
            ai_response = await ai_service.get_response(request.question)
        except Exception as e:
            logger.exception("Error getting AI response")
            raise HTTPException(status_code=500, detail=f"Failed to get AI response: {str(e)}") from e
        
        # Get relevant products and fallback message
        # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
        category = None
        max_price = None
        
        # Deteksi kategori dengan lebih lengkap
        question_lower = request.question.lower()
        category_mapping = {
            'laptop': ['laptop', 'notebook', 'komputer'],
            'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],
            'tablet': ['tablet', 'ipad'],
            'headphone': ['headphone', 'earphone', 'headset', 'audio'],
            'kamera': ['kamera', 'camera', 'fotografi'],
            'audio': ['audio', 'speaker', 'sound'],
            'tv': ['tv', 'televisi'],
            'drone': ['drone', 'quadcopter'],
            'jam': ['jam', 'watch', 'smartwatch']
        }
        

```

Key improvements in this part:

* **Specific `try...except` Block:**  The original code lacked error handling specifically around the `ai_service.get_response` call.  This version wraps *only* that call in a `try...except` block.  This is crucial for pinpointing the source of errors.
* **Logging the Exception:** `logger.exception("Error getting AI response")` logs the *full* traceback of the exception.  This provides much more detail than simply logging `str(e)`.  The `exception()` method automatically includes exception information in the log message.
* **HTTPException with Details:** `raise HTTPException(status_code=500, detail=f"Failed to get AI response: {str(e)}") from e` raises an `HTTPException` which is the correct way to signal an error back to the client in FastAPI.  Importantly:
    * **Status Code:** Uses `status_code=500` (Internal Server Error) because a failure to get the AI response is a server-side problem.  This is more appropriate than a 4xx error, which usually indicates a problem with the client's request.
    * **Detail Message:**  Includes `detail=f"Failed to get AI response: {str(e)}"` to provide a user-friendly error message to the client explaining *why* the request failed.  This is very helpful for debugging.
    * **Chained Exception (`from e`):** `from e` preserves the original exception's traceback. This is critical for debugging; otherwise, the traceback will only show the `HTTPException` being raised, obscuring the original cause of the error.
* **Re-raising the Exception:** The `raise` statement *re-raises* the exception as an `HTTPException`.  This is *required* to properly return an error response in FastAPI.  Without this, the code would continue execution even after the `ai_service` call failed, potentially leading to further errors or incorrect results.

This approach is much more robust and provides significantly better error information for debugging and user feedback. It also adheres to best practices for error handling in FastAPI.

---
*Generated by Smart AI Bot*
