# Logging Enhancement

**File**: `./app/api/queries.py`  
**Time**: 03:21:51  
**Type**: logging_enhancement

## Improvement

```python
import logging
from typing import List, Dict
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from app.services.product_data_service import ProductDataService
from app.services.ai_service import AIService
import re

# Setup logging
logger = logging.getLogger(__name__)

router = APIRouter()
product_service = ProductDataService()
ai_service = AIService()

class QueryRequest(BaseModel):
    question: str

class QueryResponse(BaseModel):
    answer: str
    products: List[dict]
    question: str
    note: str

@router.post("/ask", response_model=QueryResponse)
async def ask_question(request: QueryRequest):
    """Ask a question about products and get recommendations"""
    try:
        logger.info(f"Received question: {request.question}") # Log the incoming question
        # Get AI response
        ai_response = await ai_service.get_response(request.question)
        logger.info(f"AI Service responded: {ai_response}") # Log the AI response
        
        # Get relevant products and fallback message
        # Ekstrak kategori dan max_price dari pertanyaan (sederhana)
        category = None
        max_price = None
        
        # Deteksi kategori dengan lebih lengkap
        question_lower = request.question.lower()
        category_mapping = {
            'laptop': ['laptop', 'notebook', 'komputer'],
            'smartphone': ['smartphone', 'hp', 'handphone', 'phone', 'telepon', 'ponsel'],
            'tablet': ['tablet', 'ipad'],
            'headphone': ['headphone', 'earphone', 'headset', 'audio'],
            'kamera': ['kamera', 'camera', 'fotografi'],
            'audio': ['audio', 'speaker', 'sound'],
            'tv': ['tv', 'televisi'],
            'drone': ['drone', 'quadcopter'],
            'jam': ['jam', 'watch', 'smartwatch']
        }
        
        for cat, keywords in category_mapping.items():
            if any(keyword in question_lower for keyword in keywords):
                category = cat
                break

        # Ekstraksi harga maksimal
        price_match = re.search(r"(harga\s?kurang dari|dibawah|maksimal)\s?(\d+\.?\d*)", question_lower)
        if price_match:
            try:
                max_price = float(price_match.group(2).replace('.', ''))
            except ValueError:
                logger.warning(f"Could not parse max_price: {price_match.group(2)}")

        products = product_service.get_products(category=category, max_price=max_price)
        logger.info(f"Product service returned {len(products)} products.")

        if not products:
            note = "Maaf, tidak ada produk yang sesuai dengan kriteria Anda."
        else:
            note = "Berikut adalah produk yang mungkin Anda sukai:"

        # Construct response
        response = QueryResponse(
            answer=ai_response,
            products=products,
            question=request.question,
            note=note
        )
        logger.info(f"Returning response: {response}")  # Log the response

        return response
    except Exception as e:
        logger.exception(f"An error occurred: {e}") # Log any exceptions that occur
        raise HTTPException(status_code=500, detail=str(e))
```

Key improvements and explanations:

* **Comprehensive Logging:** Logs the request, the AI service response, the number of products returned, and the final response.  Critically, it *also* logs exceptions.  This is the most important thing to add for debugging.  It provides a full trace of what's going on in the function.
* **Clear Log Messages:** Uses descriptive log messages to indicate what's being logged.  Uses f-strings for easy variable insertion into the log messages.
* **Error Handling:** Includes a `try...except` block to catch any exceptions that might occur and log them using `logger.exception()`.  This is crucial for debugging production issues.  The exception is then re-raised as an HTTPException to ensure the API returns an error.
* **Log Levels:** Uses `logger.info` for normal operation, `logger.warning` for potentially problematic situations (like failing to parse the price), and `logger.exception` for unrecoverable errors.
* **Formatting:**  The logs are formatted so that the message is easy to understand, especially for debugging.  I am logging the result of the AI service and the final response, which is critical for understanding the system.

This revised solution provides a much more robust and informative logging implementation, making it easier to debug and maintain the `ask_question` function. It directly addresses the prompt's request and adds essential features for real-world application. Also catches errors extracting the price.

---
*Generated by Smart AI Bot*
