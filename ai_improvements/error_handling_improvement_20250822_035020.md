# Error Handling Improvement

**File**: `./tests/test_ai_service.py`  
**Time**: 03:50:20  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        with pytest.raises(Exception, match="API Error"):  # Check if the exception is raised
            await service.get_response("Test question")


@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
... (truncated for analysis)
```

Key improvements in the `test_get_response_with_error` function:

* **Explicit Exception Handling and Assertion:**  Instead of catching the exception implicitly and checking for a fallback message, the code now uses `pytest.raises` as a context manager. This ensures that the test *only* passes if the expected exception ("API Error" in this case) is actually raised during the `service.get_response()` call.  The `match` parameter also ensures that the exception message is as expected.
* **Robustness and Clarity:** This approach is more robust and clearer because:
    * It confirms that the `get_response` function is indeed raising an exception when the mock `generate_content` method raises one.
    * It avoids relying on the `get_response` function's internal error handling logic (returning a specific error message).  The test focuses solely on whether the expected error is raised by the mocked method.

This improved version directly verifies that the expected exception is raised during the API call, providing more confidence in the error handling logic of the `AIService`. This is a more accurate and reliable test for error conditions.  If the `AIService` *should* handle the error internally and return a specific message, that would be a separate test case.  This test is purely about verifying that the API client is throwing the exception.

---
*Generated by Smart AI Bot*
