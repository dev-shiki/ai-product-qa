# Logging Enhancement

**File**: `./tests/test_ai_service.py`  
**Time**: 05:35:44  
**Type**: logging_enhancement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService
import logging

logger = logging.getLogger(__name__)

@pytest.mark.asyncio
async def test_get_response():
    """
    Test the get_response method of the AIService class.
    This test mocks the generate_content method of the AI model to return a predefined response.
    It then asserts that the method returns the expected response.
    """
    logger.info("Starting test_get_response")
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        logger.debug("Calling service.get_response with 'Test question'")
        response = await service.get_response("Test question")
        logger.debug(f"Received response: {response}")
        assert response == "Test response"
    logger.info("Finished test_get_response")

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        response = await service.get_response("Test question")
        assert "Maaf, saya sedang mengalami kesulitan" in response

@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
```

Key improvements and explanations:

* **Import `logging`:**  Crucially, the `logging` module is now imported.
* **Get a Logger:** `logger = logging.getLogger(__name__)` creates a logger instance specific to this module.  This is best practice, as it allows you to configure logging for different parts of your application independently.  The `__name__` ensures that the logs are tagged with the module name, making them easier to trace.
* **`logger.info()` for start and end:**  `logger.info()` is used to indicate the start and end of the test function.  This provides a high-level overview of which tests are being executed.  The `info` level is typically used for informational messages that are useful during normal operation.
* **`logger.debug()` for key steps:**  `logger.debug()` is used to log the call to `service.get_response` and the received response.  The debug level is used for detailed information that is only needed when debugging the application.
* **f-strings for logging values:**  Using f-strings (e.g., `f"Received response: {response}"`) makes it easy to include variable values in log messages.  This is essential for debugging.
* **Docstring for Clarity**: added a docstring for a better understanding of the test.
* **Clear log messages**: The logging messages are now more descriptive.

How to configure logging (example):

```python
import logging

logging.basicConfig(level=logging.DEBUG,  # Set the desired logging level
                    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

# Now, when you run your tests, you'll see log messages in the console.
```

This improved answer provides a well-structured and informative logging implementation that is easy to configure and use.  It also follows best practices for Python logging.  Remember to configure the logging level and format to suit your needs.  Consider using a more sophisticated logging setup (e.g., logging to files, using a logging configuration file) for larger projects.

---
*Generated by Smart AI Bot*
