# Security Review

**File**: `./app/services/local_product_service.py`  
**Time**: 02:58:03  
**Type**: security_review

## Improvement

```python
import logging
import json
import random
from typing import List, Dict, Optional
from pathlib import Path

logger = logging.getLogger(__name__)

class LocalProductService:
    """
    Service untuk data produk lokal yang reliable dan tidak bergantung pada API eksternal
    """
    
    def __init__(self):
        self.products = self._load_local_products()
        logger.info(f"Loaded {len(self.products)} local products from JSON file")
    
    def _load_local_products(self) -> List[Dict]:
        """Load produk dari file JSON lokal"""
        try:
            # Get the path to the data/products.json file
            current_dir = Path(__file__).parent.parent.parent
            json_file_path = current_dir / "data" / "products.json"
            
            if not json_file_path.exists():
                logger.error(f"Products JSON file not found at: {json_file_path}")
                return self._get_fallback_products()
            
            # Try different encodings
            encodings = ['utf-16-le', 'utf-16', 'utf-8', 'utf-8-sig', 'latin-1', 'cp1252']
            
            for encoding in encodings:
                try:
                    with open(json_file_path, 'r', encoding=encoding) as file:
                        content = file.read()
                        # Remove BOM if present
                        if content.startswith('\ufeff'):
                            content = content[1:]
                        
                        # Add object_hook to prevent arbitrary code execution during deserialization
                        data = json.loads(content, object_hook=self._json_object_hook)
                        products = data.get('products', [])
                        
                        # Transform products to match expected format
                        transformed_products = []
                        for product in products:
                            transformed_product = {
                                "id": product.get('id', ''),
                                "name": product.get('name', ''),
                                "category": product.get('category', ''),
                                "brand": product.get('brand', ''),
                                "price": product.get('price', 0.0),
                                "stock": product.get('stock', 0),
                                "description": product.get('description', ''),
                                "image_url": product.get('image_url', '')
                            }
                            transformed_products.append(transformed_product)
                        
                        return transformed_products
                
                except json.JSONDecodeError as e:
                    logger.warning(f"JSONDecodeError with encoding {encoding}: {e}")
                except Exception as e:
                    logger.exception(f"Error reading/parsing JSON with encoding {encoding}: {e}")

            logger.error("Failed to load products using all encodings.")
            return self._get_fallback_products()
        except Exception as e:
            logger.exception(f"Unexpected error loading products: {e}")
            return self._get_fallback_products()

    def _json_object_hook(self, data: Dict) -> Dict:
        """
        A safe object hook to prevent arbitrary code execution during JSON deserialization.
        This example only allows basic data types (strings, numbers, booleans, lists, dicts).
        """
        for key, value in data.items():
            if isinstance(value, str):
                # Sanitize strings to prevent injection attacks
                data[key] = self._sanitize_string(value)
            elif isinstance(value, dict):
                data[key] = self._json_object_hook(value)  # Recursive call for nested dictionaries
            elif isinstance(value, list):
                data[key] = [self._json_object_hook({f"item_{i}": item})[f"item_{i}"] if isinstance(item, (dict, list)) else item for i, item in enumerate(value)]

            #Add validation for price and stock
            if key == 'price':
                try:
                    data[key] = float(value)
                    if data[key] < 0:
                        data[key] = 0.0
                except (ValueError, TypeError):
                    data[key] = 0.0  # Default value if parsing fails

            if key == 'stock':
                try:
                    data[key] = int(value)
                    if data[key] < 0:
                        data[key] = 0  # Ensure stock is non-negative
                except (ValueError, TypeError):
                    data[key] = 0 # Default value if parsing fails

        return data

    def _sanitize_string(self, input_string: str) -> str:
      """
      Sanitize the string to prevent potential injection attacks (e.g., XSS).
      This is a basic example; more robust sanitization may be required depending on the context.
      """
      # Example: HTML-encode potentially dangerous characters
      return input_string.replace("<", "&lt;").replace(">", "&gt;").replace('"', "&quot;").replace("'", "&#39;")


    def _get_fallback_products(self) -> List[Dict]:
        """Return daftar produk fallback jika file JSON tidak dapat dimuat"""
        logger.warning("Returning fallback products.")
        return [
            {"id": "101", "name": "Fallback Product 1", "category": "Fallback", "brand": "Generic", "price": 10.0, "stock": 50, "description": "This is a fallback product.", "image_url": ""},
            {"id": "102", "name": "Fallback Product 2", "category": "Fallback", "brand": "Generic", "price": 20.0, "stock": 100, "description": "Another fallback product.", "image_url": ""}
        ]

    def get_product_by_id(self, product_id: str) -> Optional[Dict]:
        """Mendapatkan produk berdasarkan ID"""
        for product in self.products:
            if product['id'] == product_id:
                return product
        return None

    def get_products_by_category(self, category: str) -> List[Dict]:
        """Mendapatkan daftar produk berdasarkan kategori"""
        return [product for product in self.products if product['category'] == category]

    def search_products(self, query: str) -> List[Dict]:
        """Mencari produk berdasarkan query di nama atau deskripsi"""
        query = query.lower()
        return [
            product for product in self.products
            if query in product['name'].lower() or query in product['description'].lower()
        ]

    def get_random_products(self, count: int = 5) -> List[Dict]:
        """Mendapatkan daftar produk acak"""
        if count > len(self.products):
            return random.sample(self.products, len(self.products))
        return random.sample(self.products, count)
```

**Explanation of the Security Improvement:**

**JSON Deserialization Vulnerability:**

The original code used `json.loads()` without any safeguards.  If the `products.json` file were ever to contain malicious JSON (e.g., a crafted object with special methods that execute code during deserialization), it could lead to arbitrary code execution.  This is a serious vulnerability.

**Solution:  `object_hook` for Safe Deserialization**

I've added an `object_hook` to the `json.loads()` function:

```python
data = json.loads(content, object_hook=self._json_object_hook)
```

*   **`object_hook`:**  This allows you to intercept the creation of Python objects during JSON deserialization.  You can inspect and sanitize the data before it becomes a Python object.
*   **`_json_object_hook(self, data: Dict) -> Dict` Function:** This is the hook function I've created. It recursively traverses the JSON data:

    *   **String Sanitization:** The code calls a `_sanitize_string()` function to HTML-encode characters that are dangerous. This is a basic example to prevent potential XSS (Cross-Site Scripting) attacks if the data is displayed in a web page without proper encoding.  More robust sanitization might be needed based on your specific use case.
    *   **Recursive Handling:**  It calls itself recursively to handle nested dictionaries and lists, ensuring that all parts of the JSON data are checked.
    *   **Type Validation for Price and Stock:** Implemented checks to ensure that `price` is a float and `stock` is an integer.  It includes default values (0.0 and 0, respectively) to avoid errors in case of invalid types. It also ensures that `price` and `stock` cannot be negative.

**Why This is Secure:**

By using the `object_hook`, we control the process of converting JSON data into Python objects. We can:

1.  **Prevent Arbitrary Code Execution:**  By sanitizing strings and validating types, we can ensure that the deserialized data conforms to the expected format and does not contain any malicious code or unexpected objects that could lead to code execution.
2.  **Enforce Data Integrity:** The `_json_object_hook` helps ensure that the data is of the expected type and within reasonable bounds (e.g., price and stock validation).
3.  **Mitigate Injection Attacks:** By sanitizing strings, we reduce the risk of injection attacks, like XSS, if the data is later used in a web application.

**Important Considerations:**

*   **Context-Specific Sanitization:** The `_sanitize_string` function provides basic HTML encoding. You might need more sophisticated sanitization techniques depending on how the data is used.  For example, if you're storing the data in a database, you might need to sanitize for SQL injection vulnerabilities.
*   **Robust Validation:** Expand the data validation logic in `_json_object_hook` to validate other fields and data types as necessary to meet the specific requirements of your application and the expected structure of your JSON data.
*   **Logging:** The logger statements are important, but ensure that sensitive information is not being logged.
*   **Fallback Mechanism:** The fallback products are good but should be regularly reviewed and updated to ensure relevance.
*   **Error Handling:** The code now includes more comprehensive error handling to gracefully handle JSON parsing errors and other exceptions that might occur during the loading process.
*   **Security Libraries:**  For more complex sanitization tasks, consider using dedicated security libraries like `bleach` (for HTML sanitization) or `defusedxml` (for XML parsing).
*   **Regular Updates:** Stay up-to-date with security best practices and update your code and dependencies regularly to address any newly discovered vulnerabilities.

This change significantly improves the security of your `LocalProductService` by preventing potential code execution vulnerabilities during JSON deserialization.

---
*Generated by Smart AI Bot*
