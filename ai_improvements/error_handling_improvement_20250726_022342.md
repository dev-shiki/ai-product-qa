# Error Handling Improvement

**File**: `./tests/test_ai_service.py`  
**Time**: 02:23:42  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        try:
            response = await service.get_response("Test question")
            assert "Maaf, saya sedang mengalami kesulitan" in response
        except Exception as e:
            pytest.fail(f"Test failed with unexpected exception: {e}")


@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak valid"
        mock_generate.return_value = mock_response
        
        question_with_special_chars = "!@#$%^&*()"
        response = await service.get_response(question_with_special_chars)
        assert "Pertanyaan tidak valid" in response
```

Key improvements in the `test_get_response_with_error` function:

* **Explicit Exception Handling:** The code now includes a `try...except` block around the call to `service.get_response()`. This allows us to specifically catch any exceptions that might be raised during the API call.
* **`pytest.fail()` for Unexpected Exceptions:**  Inside the `except` block, we use `pytest.fail(f"Test failed with unexpected exception: {e}")`.  This is crucial.  If *any* other exception than the one we're expecting (the `mock_generate.side_effect` exception) is raised, the test will fail and the traceback will show exactly what went wrong.  This is *much* better than simply letting an unexpected exception crash the test without clear information.
* **Clearer Failure Message:** The `pytest.fail()` message includes the exception object `e`, providing detailed information about the unexpected error.

This revised version is significantly more robust because:

1. **It doesn't silently pass if an unexpected error occurs.**  The original code would only pass if the *exact* expected error occurred. If, for example, there was a network error when connecting to the mocked `generate_content` function, the test would crash or, worse, silently pass because the assertion `assert "Maaf, saya sedang mengalami kesulitan" in response` would likely also raise an error.  The `try...except` block prevents this and makes the test more reliable.
2. **It provides detailed error information in case of failure.**  The original code only told you that the assertion failed. The new code tells you *what* exception was raised, making debugging much easier.

This approach adheres to best practices for exception handling in tests: always be explicit about what exceptions you expect to be raised, and always fail the test if an unexpected exception occurs.

---
*Generated by Smart AI Bot*
