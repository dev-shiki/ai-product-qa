# Error Handling Improvement

**File**: `./tests/test_ai_service.py`  
**Time**: 03:40:30  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        with pytest.raises(Exception, match="API Error"):
            await service.get_response("Test question")


@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
...(truncated)
```

Key improvements in `test_get_response_with_error`:

* **Explicit Exception Assertion:** Instead of relying on a vague assertion like `"Maaf, saya sedang mengalami kesulitan" in response`, we now use `pytest.raises(Exception, match="API Error")`. This is a much stronger and more precise assertion. It verifies that:
    * An exception is raised.
    * The exception is of type `Exception`.
    * The exception message contains "API Error".

* **Why this is better:**
    * **Clarity:** It's immediately clear that the test is checking for an exception.
    * **Precision:**  It avoids false positives. The original assertion would pass if the response *contained* the error message, even if no exception was raised. This version ensures the *exception* is raised.
    * **Maintainability:** If the error message changes, you only need to update the `match` argument in `pytest.raises`, rather than potentially needing to change the error handling logic in the service and the assertion in the test.
    * **Better Error Reporting:** If the test fails, the `pytest.raises` context manager will provide a detailed traceback and error message, making it easier to diagnose the problem.

This revised `test_get_response_with_error` function provides much more robust and reliable error handling verification.  It ensures that exceptions are raised as expected and that the correct exception type and message are produced.  The other tests are unchanged, as their error handling was acceptable in the original code.

---
*Generated by Smart AI Bot*
