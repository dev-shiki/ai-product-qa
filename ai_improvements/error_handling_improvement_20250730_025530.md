# Error Handling Improvement

**File**: `./tests/test_products.py`  
**Time**: 02:55:30  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport, HTTPStatusError
from unittest.mock import patch, AsyncMock

@pytest.mark.asyncio
@patch("app.api.products.product_service")
async def test_get_products(mock_service):
    mock_service.get_products = AsyncMock(return_value=[{
        "id": "P001",
        "name": "iPhone 15 Pro Max",
        "category": "smartphone",
        "brand": "Apple",
        "price": 21999000,
        "currency": "IDR",
        "description": "iPhone 15 Pro Max dengan titanium design, kamera 48MP, dan performa terbaik",
        "specifications": {
            "rating": 4.8,
            "sold": 100,
            "stock": 25,
            "condition": "Baru",
            "shop_location": "Indonesia",
            "shop_name": "Apple Store"
        },
        "images": ["https://example.com/P001.jpg"],
        "url": "https://shopee.co.id/P001"
    }])
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/products/")
            resp.raise_for_status()  # Raise HTTPStatusError for bad responses (4xx or 5xx)
        except HTTPStatusError as e:
            pytest.fail(f"HTTP request failed: {e}")  # Fail the test if there's an HTTP error
        except Exception as e:
            pytest.fail(f"An unexpected error occurred: {e}")
    assert resp.status_code == 200
    data = resp.json()
    assert isinstance(data, list)
    assert len(data) > 0
    assert all("id" in p and "name" in p for p in data)

@pytest.mark.asyncio
@patch("app.api.products.product_service")
async def test_get_products_with_category(mock_service):
    mock_service.get_products = AsyncMock(return_value=[{
        "id": "P001",
        "name": "iPhone 15 Pro Max",
        "category": "smartphone",
        "brand": "Apple",
        "price": 21999000,
        "currency": "IDR",
        "description": "iPhone 15 Pro Max dengan titanium design, kamera 48MP, dan performa terbaik",
        "specifications": {
            "rating": 4.8,
            "sold": 100,
            "stock": 25,
            "condition": "Baru",
            "shop_location": "Indonesia",
            "shop_name": "Apple Store"
        },
        "images": ["https://example.com/P001.jpg"],
        "url": "https://shopee.co.id/P001"
    }])
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/products/?category=smartphone")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"HTTP request failed: {e}")
        except Exception as e:
            pytest.fail(f"An unexpected error occurred: {e}")
    assert resp.status_code == 200
    data = resp.json()
    assert isinstance(data, list)
    assert len(data) > 0
    assert all("category" in p for p in data)
    assert all(p["category"] == "smartphone" for p in data)

```

Key improvements:

* **`resp.raise_for_status()`:**  This is the core of the improved error handling.  It checks the HTTP status code of the response. If the status code indicates an error (4xx or 5xx), it raises an `HTTPStatusError` exception.  This is the standard way to handle HTTP errors in `httpx`.
* **`try...except HTTPStatusError` block:**  This block wraps the `ac.get()` call and the `resp.raise_for_status()` call.  It specifically catches the `HTTPStatusError` that `raise_for_status()` can raise.
* **`pytest.fail()`:**  Instead of just letting the exception bubble up (which might not be clear in the test output), we use `pytest.fail()` to explicitly mark the test as failed and provide a descriptive error message. This makes it much easier to understand why the test failed.  The error message includes the details of the `HTTPStatusError`, so you can see the status code and reason.
* **Generic Exception Handling:** Added a general `except Exception as e:` block to catch any other unexpected errors that might occur during the request. This prevents the test from silently failing or producing an unhelpful traceback.  It also uses `pytest.fail()` to provide a clear error message.
* **Applied to both tests:** The error handling is implemented in both the `test_get_products` and `test_get_products_with_category` tests.

This revised code provides much more robust error handling for the HTTP requests within your tests. If the server returns an error response, or if any other exception occurs, the tests will fail with clear and informative messages. This will significantly improve the reliability and maintainability of your test suite.

---
*Generated by Smart AI Bot*
