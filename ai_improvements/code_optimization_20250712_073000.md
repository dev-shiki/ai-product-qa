# Code Optimization

**File**: `./app/api/products.py`  
**Time**: 07:30:00  
**Type**: code_optimization

## Improvement

**Improvement:**  Use a single exception handler for all routes.

**Explanation:**

The current code repeats the `try...except` block with `HTTPException(status_code=500, detail=str(e))` in every route. This is redundant.  FastAPI provides a way to define exception handlers that apply to all routes within the application or router.  This makes the code more concise and easier to maintain.  While this specific example is short, in larger applications, it significantly reduces boilerplate.

**Refactored Example (Showing how you'd set it up in the main app file):**

```python
# main.py or app.py (where you create the FastAPI app)
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from app.routers import product_router  # Import your router
from fastapi import APIRouter
from app.services.product_data_service import ProductDataService
from app.models.product import ProductResponse
from typing import List, Optional


# Define exception handler function
async def exception_handler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content={"detail": str(exc)},
    )


app = FastAPI()
app.add_exception_handler(Exception, exception_handler)
app.include_router(product_router)  # Register the router

# product_router.py (or your router file)
router = APIRouter()
product_service = ProductDataService()

@router.get("/", response_model=List[ProductResponse])
async def get_products(
    limit: Optional[int] = 20,
    category: Optional[str] = None,
    search: Optional[str] = None
):
    """Get products from local data source"""
    products = await product_service.get_products(
        limit=limit,
        category=category,
        search=search
    )
    return products


@router.get("/categories")
async def get_categories():
    """Get available product categories"""
    categories = await product_service.get_categories()
    return {"categories": categories}


@router.get("/search")
async def search_products(query: str, limit: Optional[int] = 10):
    """Search products by query"""
    products = await product_service.search_products(query, limit)
    return {"products": products, "query": query, "source": "local"}


@router.get("/top-rated")
async def get_top_rated_products(limit: Optional[int] = 10):
    """Get top rated products"""
    products = await product_service.get_top_rated_products(limit)
    return {"products": products, "source": "local"}
```

Key Changes and Explanation:

1. **Exception Handler Function:** I created a separate function `exception_handler` that takes a `Request` and an `Exception` as arguments.  It returns a `JSONResponse` with the appropriate 500 status code and error details.

2. **`app.add_exception_handler()`:** In the `FastAPI` app's creation (typically in `main.py` or `app.py`), the `add_exception_handler()` method is used to register the `exception_handler` function for the `Exception` type (or any other specific exception you want to handle globally).

3. **Simplified Routes:**  Now, in the router file (e.g., `product_router.py`), you can remove the `try...except` blocks from each route.  If any exception occurs within a route, FastAPI will automatically call the registered `exception_handler`.

This approach centralizes error handling, making your code cleaner, easier to read, and more maintainable.  It also ensures consistent error responses across your API.  This is superior to using a decorator for each route because it only needs to be configured once for the entire application. It's far more scalable as new routes are added.

---
*Generated by Smart AI Bot*
