# Error Handling Improvement

**File**: `./tests/test_queries.py`  
**Time**: 03:14:34  
**Type**: error_handling_improvement

## Improvement

```python
import pytest
from httpx import AsyncClient, ASGITransport, HTTPStatusError
from unittest.mock import patch, AsyncMock

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
@patch("app.api.queries.ai_service")
async def test_ask_question(mock_ai, mock_product):
    mock_ai.get_response = AsyncMock(return_value="Jawaban AI")
    mock_product.smart_search_products = AsyncMock(return_value=(
        [{"id": "P001", "name": "iPhone 15 Pro Max"}], 
        "Berikut produk yang sesuai dengan kriteria Anda."
    ))
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.post("/api/queries/ask", json={"question": "Apa laptop terbaik?"})
            resp.raise_for_status()  # Raise HTTPStatusError for bad responses (4xx or 5xx)
        except HTTPStatusError as e:
            pytest.fail(f"Request failed with status code {e.response.status_code}: {e}")

    assert resp.status_code == 200
    data = resp.json()
    assert data["answer"] == "Jawaban AI"
    assert isinstance(data["products"], list)
    assert len(data["products"]) > 0
    assert "note" in data
    assert data["note"] == "Berikut produk yang sesuai dengan kriteria Anda."

@pytest.mark.asyncio
async def test_get_suggestions():
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/queries/suggestions")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"Request failed with status code {e.response.status_code}: {e}")

    assert resp.status_code == 200
    data = resp.json()
    assert "suggestions" in data
    assert isinstance(data["suggestions"], list)

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_categories(mock_service):
    mock_service.get_categories = AsyncMock(return_value=["smartphone", "laptop", "tablet"])
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        try:
            resp = await ac.get("/api/queries/categories")
            resp.raise_for_status()
        except HTTPStatusError as e:
            pytest.fail(f"Request failed with status code {e.response.status_code}: {e}")

    assert resp.status_code == 200
    data = resp.json()
    assert "categories" in data
    assert set(data["categories"]) >= {"smartphone", "laptop", "tablet"}

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_brands(mock_service):
    mock_service.get_brands.return_value = ["Apple", "Samsung", "Sony"]
... (truncated for analysis)
```

Key improvements and explanations:

* **`resp.raise_for_status()`:** This is the core of the improvement.  It's called *after* the request.  This method checks if the HTTP response status code indicates an error (4xx or 5xx). If it does, it raises an `HTTPStatusError` exception.  This means the test will *fail* if the API returns an error code, which is crucial for robust testing.

* **`try...except HTTPStatusError` block:**  The `raise_for_status()` call is wrapped in a `try...except` block.  This allows the test to gracefully handle the `HTTPStatusError` exception if it's raised.  Instead of the test crashing, it now *fails explicitly* using `pytest.fail()`.  This provides a much clearer and more informative error message indicating the failure was due to a bad HTTP response.  The error message now includes the status code and the error as a string.

* **`pytest.fail(f"Request failed...")`:**  This ensures that the test is marked as a failure when an `HTTPStatusError` occurs. The f-string provides a descriptive error message, including the status code and exception information for debugging.  This makes it very easy to identify the root cause of the test failure.

* **Where to add Error Handling:** I've added the error handling to the `test_ask_question`, `test_get_suggestions`, and `test_get_categories` functions.  Ideally, *every* test that makes an HTTP request should have this type of error handling.

This revised code provides much better error handling for HTTP requests.  Now, if the API returns a non-200 status code, the tests will fail gracefully with informative error messages, making it much easier to diagnose issues.  It demonstrates a complete and correct implementation of `raise_for_status()` with exception handling within the pytest framework.

---
*Generated by Smart AI Bot*
