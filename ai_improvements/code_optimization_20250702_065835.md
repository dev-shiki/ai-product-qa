# Code Optimization

**File**: `./tests/test_products.py`  
**Time**: 06:58:35  
**Type**: code_optimization

## Improvement

**Optimization:**

Move the `from app.main import app` and the `AsyncClient` instantiation outside the test functions and into a `pytest.fixture`.

**Explanation:**

The `app` import and `AsyncClient` setup are the same in both test functions.  By moving this setup to a fixture, it's only created once for all the tests that need it, instead of once per test.  This reduces redundant initialization, improving overall test suite runtime, especially as the number of tests grows.

Here's an example of how to implement this:

```python
import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import patch, AsyncMock

@pytest.fixture
async def app_client():
    from app.main import app
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as ac:
        yield ac

@pytest.mark.asyncio
@patch("app.api.products.product_service")
async def test_get_products(mock_service, app_client): # Inject the fixture
    mock_service.get_products = AsyncMock(return_value=[{
        "id": "P001",
        "name": "iPhone 15 Pro Max",
        "category": "smartphone",
        "brand": "Apple",
        "price": 21999000,
        "currency": "IDR",
        "description": "iPhone 15 Pro Max dengan titanium design, kamera 48MP, dan performa terbaik",
        "specifications": {
            "rating": 4.8,
            "sold": 100,
            "stock": 25,
            "condition": "Baru",
            "shop_location": "Indonesia",
            "shop_name": "Apple Store"
        },
        "images": ["https://example.com/P001.jpg"],
        "url": "https://shopee.co.id/P001"
    }])
    resp = await app_client.get("/api/products/") # Use injected client
    assert resp.status_code == 200
    data = resp.json()
    assert isinstance(data, list)
    assert len(data) > 0
    assert all("id" in p and "name" in p for p in data)

@pytest.mark.asyncio
@patch("app.api.products.product_service")
async def test_get_products_with_category(mock_service, app_client): # Inject the fixture
    mock_service.get_products = AsyncMock(return_value=[{
        "id": "P001",
        "name": "iPhone 15 Pro Max",
        "category": "smartphone",
        "brand": "Apple",
        "price": 21999000,
        "currency": "IDR",
        "description": "iPhone 15 Pro Max dengan titanium design, kamera 48MP, dan performa terbaik",
        "specifications": {
            "rating": 4.8,
            "sold": 100,
            "stock": 25,

...(truncated)
```
Key changes:

1.  **`app_client` fixture:**  This fixture imports the `app` and creates an `AsyncClient` instance. The `yield` statement makes the client available to tests that request it.  `yield` also handles the teardown of the `AsyncClient` after all tests using the fixture are complete.
2.  **Fixture injection:**  Each test function now accepts `app_client` as an argument.  pytest automatically provides the client created by the fixture.
3.  **Usage:** The tests now use `app_client` to make the HTTP requests.

This promotes code reuse and reduces the overhead of setting up the test environment for each individual test.

---
*Generated by Smart AI Bot*
