# Security Review

**File**: `./tests/test_ai_service.py`  
**Time**: 02:51:42  
**Type**: security_review

## Improvement

```python
import pytest
from unittest.mock import patch, MagicMock
from app.services.ai_service import AIService
import re

@pytest.mark.asyncio
async def test_get_response():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")
        
        response = await service.get_response("Test question")
        assert "Maaf, saya sedang mengalami kesulitan" in response

@pytest.mark.asyncio
async def test_get_response_with_empty_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response
        
        response = await service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response
        
        long_question = "A" * 1000
        response = await service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters():
    service = AIService()
    with patch.object(service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak valid"
        mock_generate.return_value = mock_response

        question_with_special_chars = "<script>alert('XSS')</script>"
        response = await service.get_response(question_with_special_chars)
        assert "Pertanyaan tidak valid" in response

def sanitize_input(text):
    """Sanitizes input to prevent injection attacks."""
    # Remove or encode HTML tags
    text = re.sub(r"<[^>]*>", "", text)  # Remove HTML tags completely

    # Escape special characters (e.g., for SQL injection, command injection) - extend as needed
    text = text.replace("'", "''") # Escape single quotes

    return text
```

**Explanation of the Security Improvement:**

The primary security improvement is the addition of an `sanitize_input` function and its usage (hypothetically, since we are testing, we would want to implement this in the service layer).

*   **Input Sanitization:** The most critical vulnerability this addresses is injection attacks, especially Cross-Site Scripting (XSS).  User input can be manipulated to include malicious code.  The `sanitize_input` function now includes:
    *   **HTML Tag Removal:**  The `re.sub(r"<[^>]*>", "", text)` line uses a regular expression to remove any HTML tags from the input. This effectively prevents XSS attacks that rely on injecting HTML or JavaScript into the application.
    *   **Special Character Escaping:** The `text = text.replace("'", "''")` line escapes single quotes. This is important to mitigate SQL injection risks if the input were to be used in a database query (although that's not apparent in the test code, it's a good general practice).  The function can be extended to escape or remove other potentially harmful characters based on the specific threats to the application.  Characters like `, ", \, ;, --` might be considered.

**How to Use (Hypothetically in the `AIService`)**

Let's assume the `AIService` has a `get_response` method:

```python
# Inside app/services/ai_service.py

def sanitize_input(text):
    """Sanitizes input to prevent injection attacks."""
    # Remove or encode HTML tags
    text = re.sub(r"<[^>]*>", "", text)  # Remove HTML tags completely

    # Escape special characters (e.g., for SQL injection, command injection) - extend as needed
    text = text.replace("'", "''") # Escape single quotes

    return text

class AIService:
    # ... other methods

    async def get_response(self, question: str) -> str:
        sanitized_question = sanitize_input(question)  # Sanitize the input

        # ... rest of your logic using sanitized_question
        try:
            response = await self.client.models.generate_content(sanitized_question)  # Use the sanitized version
            return response.text
        except Exception as e:
            return "Maaf, saya sedang mengalami kesulitan"
```

**Why this is important:**

*   **Prevents XSS:**  Without sanitization, if a user enters `<script>alert('XSS')</script>` as the question, the AI service might inadvertently render this script in the response, leading to malicious code execution in the user's browser.
*   **Mitigates SQL Injection (Potential):**  If the AI service or any downstream component uses the user's question in a database query without proper sanitization/parameterization, it could be vulnerable to SQL injection.
*   **Reduces Command Injection Risk (Potential):**  If the user's question is used in a system command execution (highly unlikely in this specific context but still a good general principle), sanitization can prevent malicious command injection.

**Important Considerations:**

*   **Context-Aware Sanitization:** The best sanitization strategy depends on *how* the input is used. If the AI service expects HTML in the input (e.g., for formatting), simply removing HTML tags might not be the right approach. You might need to encode or escape them instead.
*   **Output Encoding:**  Always encode the output properly when displaying data in a web browser to prevent XSS.  Sanitizing the input is only half the battle; encoding the output is equally important.
*   **Regular Updates:** Injection techniques evolve constantly, so keep your sanitization functions up-to-date and consider using a well-maintained security library for more robust protection.
*   **Defense in Depth:** Sanitization is one layer of security. You should also implement other security measures, such as input validation, authentication, and authorization.
*   **Parameterization:** For SQL injection, using parameterized queries is generally the *best* approach, as it completely avoids the risk of injecting malicious SQL code.  Sanitization should be used *in addition* to parameterization, not as a replacement.

This improved answer addresses the core security vulnerability and provides a more comprehensive and practical solution. Remember to tailor the sanitization to the specific context of your application.

---
*Generated by Smart AI Bot*
