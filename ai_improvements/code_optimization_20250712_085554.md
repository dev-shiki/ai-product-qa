# Code Optimization

**File**: `./tests/test_ai_service.py`  
**Time**: 08:55:54  
**Type**: code_optimization

## Improvement

**Optimization:**  Instantiate `AIService` once using `pytest.fixture`

**Explanation:**  The code repeatedly creates a new `AIService` instance in each test function.  Creating the service instance once at the beginning of the test session and reusing it for all tests will reduce the overhead of object instantiation and potentially any associated setup within the `AIService` constructor. This will save time, especially if the constructor is heavy.

```python
import pytest
from unittest.mock import patch, AsyncMock, MagicMock
from app.services.ai_service import AIService

@pytest.fixture
def ai_service():
    return AIService()

@pytest.mark.asyncio
async def test_get_response(ai_service): #service becomes ai_service
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Test response"
        mock_generate.return_value = mock_response

        response = await ai_service.get_response("Test question")
        assert response == "Test response"

@pytest.mark.asyncio
async def test_get_response_with_error(ai_service): #service becomes ai_service
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_generate.side_effect = Exception("API Error")

        response = await ai_service.get_response("Test question")
        assert "Maaf, saya sedang mengalami kesulitan" in response

@pytest.mark.asyncio
async def test_get_response_with_empty_question(ai_service): #service becomes ai_service
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan tidak boleh kosong"
        mock_generate.return_value = mock_response

        response = await ai_service.get_response("")
        assert "Pertanyaan tidak boleh kosong" in response

@pytest.mark.asyncio
async def test_get_response_with_long_question(ai_service): #service becomes ai_service
    with patch.object(ai_service.client.models, 'generate_content') as mock_generate:
        mock_response = MagicMock()
        mock_response.text = "Pertanyaan terlalu panjang"
        mock_generate.return_value = mock_response

        long_question = "A" * 1000
        response = await ai_service.get_response(long_question)
        assert "Pertanyaan terlalu panjang" in response

@pytest.mark.asyncio
async def test_get_response_with_special_characters(ai_service): #service becomes ai_service
    service = ai_service
```

Key improvements:

*   **`@pytest.fixture`**:  This decorator turns the `ai_service()` function into a pytest fixture.  Fixtures are functions that run before a test function to provide data or set up state.
*   **Dependency Injection:** The test functions now accept `ai_service` as an argument.  Pytest automatically provides the value returned by the `ai_service` fixture.
*   **Code Reusability:** This significantly reduces code duplication, improving maintainability.
*   **Potential Performance Improvement:** Reduces object instantiation overhead.  While the performance gain might be small for simple objects, it can be noticeable for services with expensive initialization (e.g., connecting to databases, loading large models).

---
*Generated by Smart AI Bot*
