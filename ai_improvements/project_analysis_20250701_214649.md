# Project Analysis

**File**: `./tests/test_queries.py`  
**Time**: 21:46:49  
**Type**: project_analysis

## Improvement

**Optimization:** Cache the `AsyncClient` instance and the `app` object for reuse across tests.

**Explanation:**

Currently, each test function creates a new `AsyncClient` and imports the `app` from `app.main`.  Creating a new client and re-importing the app for each test incurs unnecessary overhead. By creating these once at the module level, we can reuse them across all tests, reducing setup time.

**Improved Code (Illustrative - requires changes outside function scope):**

```python
import pytest
from httpx import AsyncClient, ASGITransport
from unittest.mock import patch, AsyncMock

from app.main import app  # Import app once at module level

@pytest.fixture(scope="module") # Create fixture for reusability in all tests
async def async_client():
    async with AsyncClient(transport=ASGITransport(app=app), base_url="http://test") as client:
        yield client

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
@patch("app.api.queries.ai_service")
async def test_ask_question(mock_ai, mock_product, async_client): # Pass async_client
    mock_ai.get_response = AsyncMock(return_value="Jawaban AI")
    mock_product.smart_search_products = AsyncMock(return_value=(
        [{"id": "P001", "name": "iPhone 15 Pro Max"}], 
        "Berikut produk yang sesuai dengan kriteria Anda."
    ))
    resp = await async_client.post("/api/queries/ask", json={"question": "Apa laptop terbaik?"}) # use async_client
    assert resp.status_code == 200
    data = resp.json()
    assert data["answer"] == "Jawaban AI"
    assert isinstance(data["products"], list)
    assert len(data["products"]) > 0
    assert "note" in data
    assert data["note"] == "Berikut produk yang sesuai dengan kriteria Anda."

@pytest.mark.asyncio
async def test_get_suggestions(async_client): # Pass async_client
    resp = await async_client.get("/api/queries/suggestions") # use async_client
    assert resp.status_code == 200
    data = resp.json()
    assert "suggestions" in data
    assert isinstance(data["suggestions"], list)

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_categories(mock_service, async_client): # Pass async_client
    mock_service.get_categories = AsyncMock(return_value=["smartphone", "laptop", "tablet"])
    resp = await async_client.get("/api/queries/categories") # use async_client
    assert resp.status_code == 200
    data = resp.json()
    assert "categories" in data
    assert set(data["categories"]) >= {"smartphone", "laptop", "tablet"}

@pytest.mark.asyncio
@patch("app.api.queries.product_service")
async def test_get_brands(mock_service, async_client): # Pass async_client
    mock_service.get_brands.return_value = ["Apple", "Samsung", "Sony"]

```

**Explanation of changes:**

1.  **`from app.main import app`:**  Import the app once outside the test functions.
2.  **`@pytest.fixture(scope="module")`**: The `async_client` fixture is now created once per module. This minimizes setup and teardown overhead.  The fixture yields the client, which is available to the test functions.
3.  **`async def test_xxx(async_client)`:**  All test functions now accept the `async_client` fixture as an argument.
4.  **`resp = await async_client.get(...)`:** Each test now uses the injected `async_client` object.

This approach significantly improves performance, especially when you have many tests that rely on the same HTTP client.  Module-scoped fixtures are a powerful feature of pytest for optimizing test execution.

---
*Generated by Smart AI Bot*
