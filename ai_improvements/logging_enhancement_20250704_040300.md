# Logging Enhancement

**File**: `./app/api/products.py`  
**Time**: 04:03:00  
**Type**: logging_enhancement

## Improvement

```python
from fastapi import APIRouter, HTTPException
from app.services.product_data_service import ProductDataService
from app.models.product import ProductResponse
from typing import List, Optional
import logging

router = APIRouter()
product_service = ProductDataService()

# Configure logging (if not already configured)
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


@router.get("/", response_model=List[ProductResponse])
async def get_products(
    limit: Optional[int] = 20,
    category: Optional[str] = None,
    search: Optional[str] = None
):
    """Get products from local data source"""
    logger.info(f"get_products called with limit={limit}, category={category}, search={search}")
    try:
        products = await product_service.get_products(
            limit=limit,
            category=category,
            search=search
        )
        logger.info(f"get_products returning {len(products)} products")
        return products
    except Exception as e:
        logger.exception("Error in get_products")
        raise HTTPException(status_code=500, detail=str(e))
```

Key improvements and explanations:

* **Import `logging`:**  Crucially, the `logging` module is imported. This is necessary to use the logging functionality.
* **Configure Logging (if necessary):**  The `logging.basicConfig(level=logging.INFO)` line sets up basic logging to the console.  If your application already has a logging configuration, you should *not* include this line; it will override existing settings.  The important thing is that logging is configured *somewhere* so that the `logger` object can actually write logs. I have added this here in case the user does not have existing logging configuration.
* **Get a Logger:** `logger = logging.getLogger(__name__)` retrieves a logger instance specific to the current module.  This is best practice, as it allows you to configure logging on a per-module basis if needed.  Using `__name__` ensures that the logger's name reflects the module it's in.
* **Logging at the Start:** `logger.info(f"get_products called with limit={limit}, category={category}, search={search}")` logs the input parameters when the function is called. This is extremely valuable for debugging because you know exactly what the function was asked to do.  Using an f-string allows you to easily include the values of variables in the log message.
* **Logging on Success:** `logger.info(f"get_products returning {len(products)} products")` logs the number of products returned. This gives you insight into the function's behavior and can help you spot performance issues or unexpected results.
* **Logging Exceptions:** `logger.exception("Error in get_products")` is *critical*.  This logs the exception message *and* a full stack trace.  The stack trace is essential for pinpointing the exact location of the error within the function and the functions it calls.  `logger.exception` should be used *inside* the `except` block.  It's far more useful than just logging `str(e)`.
* **Log Levels:** Using `logger.info` for general information and `logger.exception` for errors is good practice.  Other log levels include `debug`, `warning`, and `error`. Choose the level that's appropriate for the severity of the message.

This revised answer provides a complete and practical solution for adding effective logging to the `get_products` function, addressing the original prompt's requirements and following best practices.  It's now a much more robust and debuggable piece of code.

---
*Generated by Smart AI Bot*
